{"version":3,"sources":["../src/programmers/IsProgrammer.ts","../src/programmers/CheckerProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\nimport { ValueFactory } from \"../factories/ValueFactory\";\n\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"./helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { disable_function_importer_declare } from \"./helpers/disable_function_importer_declare\";\nimport { check_object } from \"./internal/check_object\";\nimport { feature_object_entries } from \"./internal/feature_object_entries\";\n\nexport namespace IsProgrammer {\n  export const configure =\n    (options?: Partial<CONFIG.IOptions>) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig => ({\n      prefix: \"$i\",\n      equals: !!options?.object,\n      trace: false,\n      path: false,\n      numeric: OptionPredicator.numeric({\n        numeric: options?.numeric,\n      }),\n      atomist: () => (entry) => () =>\n        [\n          ...(entry.expression ? [entry.expression] : []),\n          ...(entry.conditions.length === 0\n            ? []\n            : [\n                entry.conditions\n                  .map((set) =>\n                    set\n                      .map((s) => s.expression)\n                      .reduce((a, b) => ts.factory.createLogicalAnd(a, b)),\n                  )\n                  .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n              ]),\n        ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n      combiner: () => (type: \"and\" | \"or\") => {\n        const initial: ts.TrueLiteral | ts.FalseLiteral =\n          type === \"and\" ? ts.factory.createTrue() : ts.factory.createFalse();\n        const binder =\n          type === \"and\"\n            ? ts.factory.createLogicalAnd\n            : ts.factory.createLogicalOr;\n        return (_input: ts.Expression, binaries: CheckerProgrammer.IBinary[]) =>\n          binaries.length\n            ? binaries\n                .map((binary) => binary.expression)\n                .reduce((x, y) => binder(x, y))\n            : initial;\n      },\n      joiner: {\n        object:\n          options?.object ||\n          check_object({\n            equals: !!options?.object,\n            undefined: OptionPredicator.undefined({\n              undefined: options?.undefined,\n            }),\n            assert: true,\n            reduce: ts.factory.createLogicalAnd,\n            positive: ts.factory.createTrue(),\n            superfluous: () => ts.factory.createFalse(),\n          })(project)(importer),\n        array: (input, arrow) =>\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"every\"),\n            undefined,\n            [arrow],\n          ),\n        failure: () => ts.factory.createFalse(),\n      },\n      success: ts.factory.createTrue(),\n    });\n\n  export namespace CONFIG {\n    export interface IOptions {\n      numeric: boolean;\n      undefined: boolean;\n      object: (\n        input: ts.Expression,\n        entries: IExpressionEntry<ts.Expression>[],\n      ) => ts.Expression;\n    }\n  }\n\n  /* -----------------------------------------------------------\n        WRITERS\n    ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression, disable?: boolean) =>\n    (equals: boolean) => {\n      const importer: FunctionImporter =\n        disable === <any>{}\n          ? disable_function_importer_declare(\n              new FunctionImporter(modulo.getText()),\n            )\n          : new FunctionImporter(modulo.getText());\n\n      // CONFIGURATION\n      const config: CheckerProgrammer.IConfig = {\n        ...configure({\n          object: check_object({\n            equals,\n            undefined: OptionPredicator.undefined(project.options),\n            assert: true,\n            reduce: ts.factory.createLogicalAnd,\n            positive: ts.factory.createTrue(),\n            superfluous: () => ts.factory.createFalse(),\n          })(project)(importer),\n          numeric: OptionPredicator.numeric(project.options),\n        })(project)(importer),\n        trace: equals,\n        addition: () => importer.declare(modulo),\n      };\n\n      config.decoder = () => (input, target, explore) => {\n        if (\n          target.size() === 1 &&\n          target.objects.length === 1 &&\n          target.isRequired() === true &&\n          target.nullable === false\n        ) {\n          // ONLY WHEN OBJECT WITH SOME ATOMIC PROPERTIES\n          const obj: MetadataObject = target.objects[0]!;\n          if (\n            obj._Is_simple(explore.from === \"top\" ? 0 : 1) &&\n            (equals === false ||\n              OptionPredicator.undefined(project.options) === false)\n          )\n            return ts.factory.createLogicalAnd(\n              ExpressionFactory.isObject({\n                checkNull: true,\n                checkArray: false,\n              })(input),\n              config.joiner.object(\n                ts.factory.createAsExpression(\n                  input,\n                  TypeFactory.keyword(\"any\"),\n                ),\n                feature_object_entries(config as any)(importer)(obj)(\n                  ts.factory.createAsExpression(\n                    input,\n                    TypeFactory.keyword(\"any\"),\n                  ),\n                  \"top\",\n                ),\n              ),\n            );\n        }\n        return CheckerProgrammer.decode(project)(config)(importer)(\n          input,\n          target,\n          explore,\n        );\n      };\n\n      // GENERATE CHECKER\n      return CheckerProgrammer.write(project)(config)(importer);\n    };\n\n  export const write_function_statements =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection) => {\n      const config = configure()(project)(importer);\n      const objects =\n        CheckerProgrammer.write_object_functions(project)(config)(importer)(\n          collection,\n        );\n      const unions =\n        CheckerProgrammer.write_union_functions(project)(config)(importer)(\n          collection,\n        );\n      const arrays =\n        CheckerProgrammer.write_array_functions(project)(config)(importer)(\n          collection,\n        );\n      const tuples =\n        CheckerProgrammer.write_tuple_functions(project)(config)(importer)(\n          collection,\n        );\n\n      return [\n        ...objects.filter((_, i) => importer.hasLocal(`${config.prefix}o${i}`)),\n        ...unions.filter((_, i) => importer.hasLocal(`${config.prefix}u${i}`)),\n        ...arrays.filter((_, i) => importer.hasLocal(`${config.prefix}a${i}`)),\n        ...tuples.filter((_, i) => importer.hasLocal(`${config.prefix}t${i}`)),\n      ];\n    };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  export const decode = (project: IProject) => (importer: FunctionImporter) =>\n    CheckerProgrammer.decode(project)(configure()(project)(importer))(importer);\n\n  export const decode_object =\n    (project: IProject) => (importer: FunctionImporter) =>\n      CheckerProgrammer.decode_object(configure()(project)(importer))(importer);\n\n  export const decode_to_json =\n    (checkNull: boolean) =>\n    (input: ts.Expression): ts.Expression =>\n      ts.factory.createLogicalAnd(\n        ExpressionFactory.isObject({\n          checkArray: false,\n          checkNull,\n        })(input),\n        ts.factory.createStrictEquality(\n          ts.factory.createStringLiteral(\"function\"),\n          ValueFactory.TYPEOF(IdentifierFactory.access(input)(\"toJSON\")),\n        ),\n      );\n\n  export const decode_functional = (input: ts.Expression) =>\n    ts.factory.createStrictEquality(\n      ts.factory.createStringLiteral(\"function\"),\n      ValueFactory.TYPEOF(input),\n    );\n}\n","import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../factories/MetadataFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\nimport { ValueFactory } from \"../factories/ValueFactory\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../schemas/metadata/MetadataArray\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../transformers/IProject\";\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { FeatureProgrammer } from \"./FeatureProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { AtomicPredicator } from \"./helpers/AtomicPredicator\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { ICheckEntry } from \"./helpers/ICheckEntry\";\nimport { IExpressionEntry } from \"./helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { UnionExplorer } from \"./helpers/UnionExplorer\";\nimport { check_array_length } from \"./internal/check_array_length\";\nimport { check_bigint } from \"./internal/check_bigint\";\nimport { check_native } from \"./internal/check_native\";\nimport { check_number } from \"./internal/check_number\";\nimport { check_string } from \"./internal/check_string\";\nimport { check_template } from \"./internal/check_template\";\nimport { decode_union_object } from \"./internal/decode_union_object\";\nimport { wrap_metadata_rest_tuple } from \"./internal/wrap_metadata_rest_tuple\";\n\nexport namespace CheckerProgrammer {\n  export interface IConfig {\n    prefix: string;\n    path: boolean;\n    trace: boolean;\n    equals: boolean;\n    numeric: boolean;\n    addition?: () => ts.Statement[];\n    decoder?: () => FeatureProgrammer.Decoder<Metadata, ts.Expression>;\n    combiner: IConfig.Combiner;\n    atomist: (\n      explore: IExplore,\n    ) => (check: ICheckEntry) => (input: ts.Expression) => ts.Expression;\n    joiner: IConfig.IJoiner;\n    success: ts.Expression;\n  }\n  export namespace IConfig {\n    export interface Combiner {\n      (explorer: IExplore): {\n        (logic: \"and\" | \"or\"): {\n          (\n            input: ts.Expression,\n            binaries: IBinary[],\n            expected: string,\n          ): ts.Expression;\n        };\n      };\n    }\n    export interface IJoiner {\n      object(input: ts.Expression, entries: IExpressionEntry[]): ts.Expression;\n      array(input: ts.Expression, arrow: ts.ArrowFunction): ts.Expression;\n      tuple?: undefined | ((exprs: ts.Expression[]) => ts.Expression);\n\n      failure(\n        value: ts.Expression,\n        expected: string,\n        explore?: undefined | FeatureProgrammer.IExplore,\n      ): ts.Expression;\n      is?(expression: ts.Expression): ts.Expression;\n      required?(exp: ts.Expression): ts.Expression;\n      full?:\n        | undefined\n        | ((\n            condition: ts.Expression,\n          ) => (\n            input: ts.Expression,\n            expected: string,\n            explore: IExplore,\n          ) => ts.Expression);\n    }\n  }\n  export type IExplore = FeatureProgrammer.IExplore;\n\n  export interface IBinary {\n    expression: ts.Expression;\n    combined: boolean;\n  }\n\n  /* -----------------------------------------------------------\n        WRITERS\n    ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write(project)(configure(project)(config)(importer))(\n        importer,\n      );\n\n  export const write_object_functions =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write_object_functions(\n        configure(project)(config)(importer),\n      )(importer);\n\n  export const write_union_functions =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write_union_functions(\n        configure(project)({ ...config, numeric: false })(importer),\n      );\n\n  export const write_array_functions =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  export const write_tuple_functions =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const configure =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => ({\n      types: {\n        input: () => TypeFactory.keyword(\"any\"),\n        output: (type, name) =>\n          ts.factory.createTypePredicateNode(\n            undefined,\n            \"input\",\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ),\n      },\n      trace: config.trace,\n      path: config.path,\n      prefix: config.prefix,\n      initializer: (project) => (importer) => (type) => {\n        const collection: MetadataCollection = new MetadataCollection();\n        const result = MetadataFactory.analyze(\n          project.checker,\n          project.context,\n        )({\n          escape: false,\n          constant: true,\n          absorb: true,\n        })(collection)(type);\n        if (result.success === false)\n          throw TransformerError.from(`typia.${importer.method}`)(\n            result.errors,\n          );\n        return [collection, result.data];\n      },\n      addition: config.addition,\n      decoder: () => config.decoder?.() ?? decode(project)(config)(importer),\n      objector: {\n        checker: () => config.decoder?.() ?? decode(project)(config)(importer),\n        decoder: () => decode_object(config)(importer),\n        joiner: config.joiner.object,\n        unionizer: config.equals\n          ? decode_union_object(decode_object(config)(importer))(\n              (input, obj, explore) =>\n                decode_object(config)(importer)(input, obj, {\n                  ...explore,\n                  tracable: true,\n                }),\n            )(config.joiner.is ?? ((expr) => expr))((value, expected) =>\n              ts.factory.createReturnStatement(\n                config.joiner.failure(value, expected),\n              ),\n            )\n          : (input, targets, explore) =>\n              config.combiner(explore)(\"or\")(\n                input,\n                targets.map((obj) => ({\n                  expression: decode_object(config)(importer)(\n                    input,\n                    obj,\n                    explore,\n                  ),\n                  combined: true,\n                })),\n                `(${targets.map((t) => t.name).join(\" | \")})`,\n              ),\n        failure: (value, expected) =>\n          ts.factory.createReturnStatement(\n            config.joiner.failure(value, expected),\n          ),\n        is: config.joiner.is,\n        required: config.joiner.required,\n        full: config.joiner.full,\n        type: TypeFactory.keyword(\"boolean\"),\n      },\n      generator: {\n        unions: config.numeric\n          ? () =>\n              FeatureProgrammer.write_union_functions(\n                configure(project)({ ...config, numeric: false })(importer),\n              )\n          : undefined,\n        arrays: () => write_array_functions(project)(config)(importer),\n        tuples: () => write_tuple_functions(project)(config)(importer),\n      },\n    });\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  /**\n   * @internal\n   */\n  export const decode =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: IExplore,\n    ): ts.Expression => {\n      if (meta.any) return config.success;\n\n      const top: IBinary[] = [];\n      const binaries: IBinary[] = [];\n      const add = create_add(binaries)(input);\n      const getConstantValue = (value: number | string | bigint | boolean) => {\n        if (typeof value === \"string\")\n          return ts.factory.createStringLiteral(value);\n        else if (typeof value === \"bigint\")\n          return ExpressionFactory.bigint(value);\n        return ts.factory.createIdentifier(value.toString());\n      };\n\n      //----\n      // CHECK OPTIONAL\n      //----\n      // @todo -> should be elaborated\n      const checkOptional: boolean = meta.empty() || meta.isUnionBucket();\n\n      // NULLABLE\n      if (checkOptional || meta.nullable)\n        (meta.nullable ? add : create_add(top)(input))(\n          meta.nullable,\n          ValueFactory.NULL(),\n        );\n\n      // UNDEFINDABLE\n      if (checkOptional || !meta.isRequired())\n        (meta.isRequired() ? create_add(top)(input) : add)(\n          !meta.isRequired(),\n          ValueFactory.UNDEFINED(),\n        );\n\n      // FUNCTIONAL\n      if (meta.functional === true)\n        if (OptionPredicator.functional(project.options) || meta.size() !== 1)\n          add(\n            true,\n            ts.factory.createStringLiteral(\"function\"),\n            ValueFactory.TYPEOF(input),\n          );\n        else\n          binaries.push({\n            combined: false,\n            expression: config.success,\n          });\n\n      //----\n      // VALUES\n      //----\n      // CONSTANT VALUES\n      for (const constant of meta.constants)\n        if (AtomicPredicator.constant(meta)(constant.type))\n          for (const v of constant.values) add(true, getConstantValue(v.value));\n      if (meta.escaped !== null)\n        binaries.push({\n          combined: false,\n          expression:\n            meta.escaped.original.size() === 1 &&\n            meta.escaped.original.natives.length === 1\n              ? check_native(meta.escaped.original.natives[0]!)(input)\n              : ts.factory.createLogicalAnd(\n                  decode(project)(config)(importer)(\n                    input,\n                    meta.escaped.original,\n                    explore,\n                  ),\n                  ts.factory.createLogicalAnd(\n                    IsProgrammer.decode_to_json(false)(input),\n                    decode_escaped(project)(config)(importer)(\n                      input,\n                      meta.escaped.returns,\n                      explore,\n                    ),\n                  ),\n                ),\n        });\n\n      // ATOMIC VALUES\n      for (const atom of meta.atomics)\n        if (AtomicPredicator.atomic(meta)(atom.type) === false) continue;\n        else if (atom.type === \"number\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_number(project, config.numeric)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else if (atom.type === \"bigint\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_bigint(project)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else if (atom.type === \"string\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_string(project)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else\n          add(\n            true,\n            ts.factory.createStringLiteral(atom.type),\n            ValueFactory.TYPEOF(input),\n          );\n\n      // TEMPLATE LITERAL VALUES\n      if (meta.templates.length)\n        if (AtomicPredicator.template(meta))\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_template(meta.templates)(input),\n            )(input),\n            combined: false,\n          });\n\n      // NATIVE CLASSES\n      for (const native of meta.natives)\n        binaries.push({\n          expression: check_native(native)(input),\n          combined: false,\n        });\n\n      //----\n      // INSTANCES\n      //----\n      interface IInstance {\n        pre: ts.Expression;\n        body: ts.Expression | null;\n        expected: string;\n      }\n      const instances: IInstance[] = [];\n      const prepare =\n        (pre: ts.Expression, expected: string) =>\n        (body: ts.Expression | null) =>\n          instances.push({\n            pre,\n            expected,\n            body,\n          });\n\n      // SETS\n      if (meta.sets.length) {\n        const install = prepare(\n          check_native(\"Set\")(input),\n          meta.sets.map((elem) => `Set<${elem.getName()}>`).join(\" | \"),\n        );\n        if (meta.sets.some((elem) => elem.any)) install(null);\n        else\n          install(\n            explore_sets(project)(config)(importer)(input, meta.sets, {\n              ...explore,\n              from: \"array\",\n            }),\n          );\n      }\n\n      // MAPS\n      if (meta.maps.length) {\n        const install = prepare(\n          check_native(\"Map\")(input),\n          meta.maps\n            .map(({ key, value }) => `Map<${key}, ${value}>`)\n            .join(\" | \"),\n        );\n        if (meta.maps.some((elem) => elem.key.any && elem.value.any))\n          install(null);\n        else\n          install(\n            explore_maps(project)(config)(importer)(input, meta.maps, {\n              ...explore,\n              from: \"array\",\n            }),\n          );\n      }\n\n      // ARRAYS AND TUPLES\n      if (meta.tuples.length + meta.arrays.length > 0) {\n        const install = prepare(\n          config.atomist(explore)({\n            expected: [\n              ...meta.tuples.map((t) => t.type.name),\n              ...meta.arrays.map((a) => a.getName()),\n            ].join(\" | \"),\n            expression: ExpressionFactory.isArray(input),\n            conditions: [],\n          })(input),\n          [...meta.tuples, ...meta.arrays]\n            .map((elem) => elem.type.name)\n            .join(\" | \"),\n        );\n        if (meta.arrays.length === 0)\n          if (meta.tuples.length === 1)\n            install(\n              decode_tuple(project)(config)(importer)(input, meta.tuples[0]!, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n          // TUPLE ONLY\n          else\n            install(\n              explore_tuples(project)(config)(importer)(input, meta.tuples, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n        else if (meta.arrays.some((elem) => elem.type.value.any)) install(null);\n        else if (meta.tuples.length === 0)\n          if (meta.arrays.length === 1)\n            // ARRAY ONLY\n            install(\n              decode_array(project)(config)(importer)(input, meta.arrays[0]!, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n          else\n            install(\n              explore_arrays(project)(config)(importer)(input, meta.arrays, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n        else\n          install(\n            explore_arrays_and_tuples(project)(config)(importer)(\n              input,\n              [...meta.tuples, ...meta.arrays],\n              explore,\n            ),\n          );\n      }\n\n      // OBJECT\n      if (meta.objects.length > 0)\n        prepare(\n          ExpressionFactory.isObject({\n            checkNull: true,\n            checkArray: meta.objects.some((obj) =>\n              obj.properties.every(\n                (prop) => !prop.key.isSoleLiteral() || !prop.value.isRequired(),\n              ),\n            ),\n          })(input),\n          meta.objects.map((obj) => obj.name).join(\" | \"),\n        )(\n          explore_objects(config)(importer)(input, meta, {\n            ...explore,\n            from: \"object\",\n          }),\n        );\n\n      if (instances.length) {\n        const transformer =\n          (merger: (x: ts.Expression, y: ts.Expression) => ts.Expression) =>\n          (ins: IInstance) =>\n            ins.body\n              ? {\n                  expression: merger(ins.pre, ins.body),\n                  combined: true,\n                }\n              : {\n                  expression: ins.pre,\n                  combined: false,\n                };\n        if (instances.length === 1)\n          binaries.push(\n            transformer((pre, body) =>\n              config.combiner(explore)(\"and\")(\n                input,\n                [pre, body].map((expression) => ({\n                  expression,\n                  combined: expression !== pre,\n                })),\n                meta.getName(),\n              ),\n            )(instances[0]!),\n          );\n        else\n          binaries.push({\n            expression: config.combiner(explore)(\"or\")(\n              input,\n              instances.map(transformer(ts.factory.createLogicalAnd)),\n              meta.getName(),\n            ),\n            combined: true,\n          });\n      }\n\n      //----\n      // COMBINE CONDITIONS\n      //----\n      return top.length && binaries.length\n        ? config.combiner(explore)(\"and\")(\n            input,\n            [\n              ...top,\n              {\n                expression: config.combiner(explore)(\"or\")(\n                  input,\n                  binaries,\n                  meta.getName(),\n                ),\n                combined: true,\n              },\n            ],\n            meta.getName(),\n          )\n        : binaries.length\n          ? config.combiner(explore)(\"or\")(input, binaries, meta.getName())\n          : config.success;\n    };\n\n  export const decode_object =\n    (config: IConfig) => (importer: FunctionImporter) => {\n      const func = FeatureProgrammer.decode_object(config)(importer);\n      return (input: ts.Expression, obj: MetadataObject, explore: IExplore) => {\n        obj.validated = true;\n        return func(input, obj, explore);\n      };\n    };\n\n  const decode_array =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, array: MetadataArray, explore: IExplore) => {\n      if (array.type.recursive === false)\n        return decode_array_inline(project)(config)(importer)(\n          input,\n          array,\n          explore,\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.useLocal(`${config.prefix}a${array.type.index}`),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)({\n            ...explore,\n            source: \"function\",\n            from: \"array\",\n          })(input),\n        ),\n        config.joiner.failure(input, array.type.name, explore),\n      );\n    };\n\n  const decode_array_inline =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: IExplore,\n    ): ts.Expression => {\n      const length = check_array_length(project)(array)(input);\n      const main = FeatureProgrammer.decode_array({\n        prefix: config.prefix,\n        trace: config.trace,\n        path: config.path,\n        decoder: () => decode(project)(config)(importer),\n      })(importer)(config.joiner.array)(input, array, explore);\n      return length.expression === null && length.conditions.length === 0\n        ? main\n        : ts.factory.createLogicalAnd(\n            config.atomist(explore)(length)(input),\n            main,\n          );\n    };\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: IExplore,\n    ): ts.Expression => {\n      if (tuple.type.recursive === false)\n        return decode_tuple_inline(project)(config)(importer)(\n          input,\n          tuple.type,\n          explore,\n        );\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)({\n            ...explore,\n            source: \"function\",\n          })(input),\n        ),\n        config.joiner.failure(input, tuple.type.name, explore),\n      );\n    };\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: IExplore,\n    ): ts.Expression => {\n      const binaries: ts.Expression[] = tuple.elements\n        .filter((meta) => meta.rest === null)\n        .map((meta, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            meta,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest: ts.Expression | null =\n        tuple.elements.length && tuple.elements.at(-1)!.rest !== null\n          ? decode(project)(config)(importer)(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(input)(\"slice\"),\n                undefined,\n                [ExpressionFactory.number(tuple.elements.length - 1)],\n              ),\n              wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n              {\n                ...explore,\n                start: tuple.elements.length - 1,\n              },\n            )\n          : null;\n\n      const arrayLength = ts.factory.createPropertyAccessExpression(\n        input,\n        \"length\",\n      );\n      return config.combiner(explore)(\"and\")(\n        input,\n        [\n          ...(rest === null\n            ? tuple.elements.every((t) => t.optional === false)\n              ? [\n                  {\n                    combined: false,\n                    expression: ts.factory.createStrictEquality(\n                      arrayLength,\n                      ExpressionFactory.number(tuple.elements.length),\n                    ),\n                  },\n                ]\n              : [\n                  {\n                    combined: false,\n                    expression: ts.factory.createLogicalAnd(\n                      ts.factory.createLessThanEquals(\n                        ExpressionFactory.number(\n                          tuple.elements.filter((t) => t.optional === false)\n                            .length,\n                        ),\n                        arrayLength,\n                      ),\n                      ts.factory.createGreaterThanEquals(\n                        ExpressionFactory.number(tuple.elements.length),\n                        arrayLength,\n                      ),\n                    ),\n                  },\n                ]\n            : []),\n          ...(config.joiner.tuple\n            ? [\n                {\n                  expression: config.joiner.tuple(binaries),\n                  combined: true,\n                },\n              ]\n            : binaries.map((expression) => ({\n                expression,\n                combined: true,\n              }))),\n          ...(rest !== null\n            ? [\n                {\n                  expression: rest,\n                  combined: true,\n                },\n              ]\n            : []),\n        ],\n        `[${tuple.elements.map((t) => t.getName()).join(\", \")}]`,\n      );\n    };\n\n  const decode_escaped =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, meta: Metadata, explore: IExplore): ts.Expression =>\n      ts.factory.createCallExpression(\n        ts.factory.createParenthesizedExpression(\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n            undefined,\n            undefined,\n            decode(project)(config)(importer)(\n              ts.factory.createIdentifier(\"input\"),\n              meta,\n              explore,\n            ),\n          ),\n        ),\n        undefined,\n        [\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"toJSON\"),\n            undefined,\n            [],\n          ),\n        ],\n      );\n\n  /* -----------------------------------------------------------\n        UNION TYPE EXPLORERS\n    ----------------------------------------------------------- */\n  const explore_sets =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      sets: Metadata[],\n      explore: IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.set({\n          checker: decode(project)(config)(importer),\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        })([])(input, sets, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_maps =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      maps: Metadata.Entry[],\n      explore: IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.map({\n          checker: (input, entry, explore) => {\n            const func = decode(project)(config)(importer);\n            return ts.factory.createLogicalAnd(\n              func(\n                ts.factory.createElementAccessExpression(input, 0),\n                entry[0],\n                {\n                  ...explore,\n                  postfix: `${explore.postfix}[0]`,\n                },\n              ),\n              func(\n                ts.factory.createElementAccessExpression(input, 1),\n                entry[1],\n                {\n                  ...explore,\n                  postfix: `${explore.postfix}[1]`,\n                },\n              ),\n            );\n          },\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        })([])(input, maps, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_tuples =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuples: MetadataTuple[],\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.tuple({\n          checker: decode_tuple(project)(config)(importer),\n          decoder: decode_tuple(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, tuples, explore);\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      arrays: MetadataArray[],\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: decode(project)(config)(importer),\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, arrays, explore);\n\n  const explore_arrays_and_tuples =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: Array<MetadataArray | MetadataTuple>,\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array_or_tuple({\n          checker: (front, target, explore, array) =>\n            target instanceof MetadataTuple\n              ? decode_tuple(project)(config)(importer)(front, target, explore)\n              : config.atomist(explore)({\n                  expected: elements\n                    .map((elem) =>\n                      elem instanceof MetadataArray\n                        ? elem.getName()\n                        : elem.type.name,\n                    )\n                    .join(\" | \"),\n                  expression: decode(project)(config)(importer)(\n                    front,\n                    target,\n                    explore,\n                  ),\n                  conditions: [],\n                })(array),\n          decoder: (input, target, explore) =>\n            target instanceof MetadataTuple\n              ? decode_tuple(project)(config)(importer)(input, target, explore)\n              : decode_array(project)(config)(importer)(input, target, explore),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (input: ts.Expression, elements: T[], explore: IExplore): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.emplaceUnion(\n              config.prefix,\n              elements.map((e) => e.type.name).join(\" | \"),\n              () =>\n                arrow(\n                  FeatureProgrammer.parameterDeclarations(config)(\n                    TypeFactory.keyword(\"any\"),\n                  )(ts.factory.createIdentifier(\"input\")),\n                )({\n                  ...explore,\n                  postfix: \"\",\n                })(ts.factory.createIdentifier(\"input\")),\n            ),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)(explore)(input),\n        ),\n        config.joiner.failure(\n          input,\n          elements.map((e) => e.type.name).join(\" | \"),\n          explore,\n        ),\n      );\n    };\n\n  const explore_objects =\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, meta: Metadata, explore: IExplore) =>\n      meta.objects.length === 1\n        ? decode_object(config)(importer)(input, meta.objects[0]!, explore)\n        : ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}u${meta.union_index!}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)(explore)(input),\n          );\n}\n\nconst create_add =\n  (binaries: CheckerProgrammer.IBinary[]) =>\n  (defaultInput: ts.Expression) =>\n  (\n    exact: boolean,\n    left: ts.Expression,\n    right: ts.Expression = defaultInput,\n  ) => {\n    const factory = exact\n      ? ts.factory.createStrictEquality\n      : ts.factory.createStrictInequality;\n    binaries.push({\n      expression: factory(left, right),\n      combined: false,\n    });\n  };\n"],"mappings":"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","names":["ts","ts","CheckerProgrammer","write","project","config","importer","FeatureProgrammer","configure","write_object_functions","write_union_functions","numeric","write_array_functions","collection","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","ts","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","types","input","output","name","createTypePredicateNode","createTypeReferenceNode","getFullName","checker","path","initializer","MetadataCollection","result","MetadataFactory","analyze","context","escape","absorb","success","TransformerError","method","errors","data","addition","decoder","decode","objector","decode_object","joiner","object","unionizer","equals","decode_union_object","obj","explore","is","expr","value","expected","createReturnStatement","failure","targets","combiner","expression","combined","join","required","full","generator","unions","meta","any","top","binaries","add","create_add","getConstantValue","createStringLiteral","ExpressionFactory","bigint","toString","checkOptional","empty","isUnionBucket","nullable","ValueFactory","NULL","isRequired","UNDEFINED","functional","OptionPredicator","options","size","TYPEOF","push","constants","AtomicPredicator","v","values","escaped","original","natives","length","check_native","createLogicalAnd","IsProgrammer","decode_to_json","decode_escaped","returns","atom","atomics","atomic","atomist","check_number","check_bigint","check_string","templates","template","check_template","native","instances","prepare","pre","body","sets","install","elem","getName","some","explore_sets","maps","key","explore_maps","isArray","conditions","decode_tuple","explore_tuples","decode_array","explore_arrays","explore_arrays_and_tuples","objects","isObject","checkNull","checkArray","properties","every","prop","isSoleLiteral","explore_objects","transformer","merger","ins","func","validated","array","createLogicalOr","createCallExpression","useLocal","index","argumentsArray","check_array_length","main","elements","rest","createElementAccessExpression","slice","at","IdentifierFactory","access","number","wrap_metadata_rest_tuple","start","arrayLength","createPropertyAccessExpression","optional","createStrictEquality","createLessThanEquals","createGreaterThanEquals","createParenthesizedExpression","parameter","UnionExplorer","set","entry","explore_array_like_union_types","array_or_tuple","front","target","MetadataTuple","arrow","parameters","e","emplaceUnion","union_index","defaultInput","exact","left","right","createStrictInequality","IsProgrammer","configure","options","project","importer","prefix","equals","object","trace","path","numeric","OptionPredicator","atomist","entry","expression","conditions","length","map","set","s","reduce","a","b","ts","factory","createLogicalAnd","createLogicalOr","x","y","combiner","type","initial","createTrue","createFalse","binder","_input","binaries","binary","joiner","check_object","undefined","assert","positive","superfluous","array","input","arrow","createCallExpression","IdentifierFactory","access","failure","success","write","modulo","disable","disable_function_importer_declare","FunctionImporter","getText","config","addition","declare","decoder","target","explore","size","objects","isRequired","nullable","obj","_Is_simple","from","ExpressionFactory","isObject","checkNull","checkArray","createAsExpression","TypeFactory","keyword","feature_object_entries","CheckerProgrammer","decode","write_function_statements","collection","write_object_functions","unions","write_union_functions","arrays","write_array_functions","tuples","write_tuple_functions","filter","_","i","hasLocal","decode_object","decode_to_json","createStrictEquality","createStringLiteral","ValueFactory","TYPEOF","decode_functional"]}