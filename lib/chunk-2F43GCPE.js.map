{"version":3,"sources":["../src/factories/ExpressionFactory.ts"],"names":["ts","ExpressionFactory","number","value","factory","createPrefixUnaryExpression","SyntaxKind","MinusToken","createNumericLiteral","Math","abs","bigint","createCallExpression","createIdentifier","undefined","toString","isRequired","input","createStrictInequality","isArray","isObject","options","conditions","createStrictEquality","createStringLiteral","createTypeOfExpression","checkNull","push","createNull","checkArray","createFalse","length","reduce","x","y","createLogicalAnd","isInstanceOf","type","createBinaryExpression","createToken","InstanceOfKeyword","coalesce","QuestionQuestionToken","currying","target","parameters","prev","param","slice","selfCall","body","isCallExpression","createParenthesizedExpression","createArrowFunction","getEscapedText","printer","printNode","EmitHint","Expression","getSourceFile","transpile","context","script","file","createSourceFile","RandomGenerator","uuid","ScriptTarget","ESNext","ScriptKind","TS","statement","statements","ReferenceError","isExpressionStatement","TypeError","visitor","node","isIdentifier","text","visitEachChild","cloneNode","expression"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { RandomGenerator } from \"../utils/RandomGenerator\";\n\nexport namespace ExpressionFactory {\n  export const number = (value: number) =>\n    value < 0\n      ? ts.factory.createPrefixUnaryExpression(\n          ts.SyntaxKind.MinusToken,\n          ts.factory.createNumericLiteral(Math.abs(value)),\n        )\n      : ts.factory.createNumericLiteral(value);\n\n  export const bigint = (value: number | bigint) =>\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"BigInt\"),\n      undefined,\n      [ts.factory.createIdentifier(value.toString())],\n    );\n\n  export const isRequired = (input: ts.Expression): ts.Expression =>\n    ts.factory.createStrictInequality(\n      ts.factory.createIdentifier(\"undefined\"),\n      input,\n    );\n\n  export const isArray = (input: ts.Expression): ts.Expression =>\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"Array.isArray\"),\n      undefined,\n      [input],\n    );\n\n  export const isObject =\n    (options: { checkNull: boolean; checkArray: boolean }) =>\n    (input: ts.Expression): ts.Expression => {\n      const conditions: ts.Expression[] = [\n        ts.factory.createStrictEquality(\n          ts.factory.createStringLiteral(\"object\"),\n          ts.factory.createTypeOfExpression(input),\n        ),\n      ];\n      if (options.checkNull === true)\n        conditions.push(\n          ts.factory.createStrictInequality(ts.factory.createNull(), input),\n        );\n      if (options.checkArray === true)\n        conditions.push(\n          ts.factory.createStrictEquality(\n            ts.factory.createFalse(),\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"Array.isArray\"),\n              undefined,\n              [input],\n            ),\n          ),\n        );\n\n      return conditions.length === 1\n        ? conditions[0]!\n        : conditions.reduce((x, y) => ts.factory.createLogicalAnd(x, y));\n    };\n\n  export const isInstanceOf =\n    (type: string) =>\n    (input: ts.Expression): ts.Expression => {\n      return ts.factory.createBinaryExpression(\n        input,\n        ts.factory.createToken(ts.SyntaxKind.InstanceOfKeyword),\n        ts.factory.createIdentifier(type),\n      );\n    };\n\n  export const coalesce =\n    (x: ts.Expression) =>\n    (y: ts.Expression): ts.Expression =>\n      ts.factory.createBinaryExpression(\n        x,\n        ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n        y,\n      );\n\n  export const currying =\n    (target: ts.Expression) => (parameters: ts.Expression[]) => {\n      if (parameters.length === 0)\n        return ts.factory.createCallExpression(target, undefined, undefined);\n      let prev: ts.CallExpression = ts.factory.createCallExpression(\n        target,\n        undefined,\n        [parameters[0]!],\n      );\n      for (const param of parameters.slice(1))\n        prev = ts.factory.createCallExpression(prev, undefined, [param]);\n      return prev;\n    };\n\n  export const selfCall = (body: ts.ConciseBody) =>\n    ts.isCallExpression(body)\n      ? body\n      : ts.factory.createCallExpression(\n          ts.factory.createParenthesizedExpression(\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [],\n              undefined,\n              undefined,\n              body,\n            ),\n          ),\n          undefined,\n          undefined,\n        );\n\n  export const getEscapedText =\n    (printer: ts.Printer) =>\n    (input: ts.Expression): string =>\n      printer.printNode(ts.EmitHint.Expression, input, input.getSourceFile());\n\n  export const transpile =\n    (context: ts.TransformationContext) => (script: string) => {\n      const file: ts.SourceFile = ts.createSourceFile(\n        `${RandomGenerator.uuid()}.ts`,\n        script,\n        ts.ScriptTarget.ESNext,\n        true,\n        ts.ScriptKind.TS,\n      );\n      const statement: ts.Statement | undefined = file.statements[0];\n      if (statement === undefined)\n        throw new ReferenceError(\n          \"Error on ExpressionFactory.transpile(): no statement exists.\",\n        );\n      else if (!ts.isExpressionStatement(statement))\n        throw new TypeError(\n          \"Error on ExpressionFactory.transpile(): statement is not an expression statement.\",\n        );\n      return (input: ts.Expression): ts.Expression => {\n        const visitor = (node: ts.Node): ts.Node => {\n          if (ts.isIdentifier(node) && node.text === \"$input\") return input;\n          return ts.visitEachChild(\n            (ts.factory as any).cloneNode(node),\n            visitor,\n            context,\n          );\n        };\n        return visitor(statement.expression) as ts.Expression;\n      };\n    };\n}\n"]}