{"version":3,"sources":["../src/programmers/notations/NotationValidateGeneralProgrammer.ts"],"names":["ts","NotationValidateGeneralProgrammer","write","rename","project","modulo","type","name","factory","createArrowFunction","undefined","IdentifierFactory","parameter","TypeFactory","keyword","createTypeReferenceNode","NotationGeneralProgrammer","returnType","getFullName","checker","createBlock","StatementFactory","constant","ValidateProgrammer","options","functional","numeric","createAsExpression","createCallExpression","createIdentifier","createIfStatement","createExpressionStatement","createBinaryExpression","SyntaxKind","EqualsToken","createReturnStatement"],"mappings":";;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAWEC,oCAAAA;qCACFC,QACX,CAACC,WACD,CAACC,YACD,CAACC,WACD,CAACC,MAAeC,SACdP,GAAGQ,QAAQC,oBACTC,QACAA,QACA;IAACC,kBAAkBC,UAAU,SAASC,YAAYC,QAAQ,KAAA,CAAA;KAC1Dd,GAAGQ,QAAQO,wBACT,qBAAqBC,0BAA0BC,WAAWd,MAAAA,EACxDI,QAAQM,YAAYK,YAAYd,QAAQe,OAAO,EAAEb,IAAAA,CAAAA,CAAAA,GAC/C,GAENI,QACAV,GAAGQ,QAAQY,YAAY;IACrBC,iBAAiBC,SACf,YACAC,mBAAmBrB,MAAM;MACvB,GAAGE;MACHoB,SAAS;QACP,GAAGpB,QAAQoB;QACXC,YAAY;QACZC,SAAS;MACX;IACF,CAAA,EAAGrB,MAAAA,EAAQ,KAAA,EAAOC,MAAMC,IAAAA,CAAAA;IAE1Bc,iBAAiBC,SACf,WACAN,0BAA0Bd,MAAMC,MAAAA,EAAQ;MACtC,GAAGC;MACHoB,SAAS;QACP,GAAGpB,QAAQoB;QACXC,YAAY;QACZC,SAAS;MACX;IACF,CAAA,EAAGrB,MAAAA,EAAQC,MAAMC,IAAAA,CAAAA;IAEnBc,iBAAiBC,SACf,UACAtB,GAAGQ,QAAQmB,mBACT3B,GAAGQ,QAAQoB,qBACT5B,GAAGQ,QAAQqB,iBAAiB,UAAA,GAC5BnB,QACA;MAACV,GAAGQ,QAAQqB,iBAAiB,OAAA;KAAS,GAExChB,YAAYC,QAAQ,KAAA,CAAA,CAAA;IAGxBd,GAAGQ,QAAQsB,kBACT9B,GAAGQ,QAAQqB,iBAAiB,gBAAA,GAC5B7B,GAAGQ,QAAQuB,0BACT/B,GAAGQ,QAAQwB,uBACThC,GAAGQ,QAAQqB,iBAAiB,aAAA,GAC5B7B,GAAGiC,WAAWC,aACdlC,GAAGQ,QAAQoB,qBACT5B,GAAGQ,QAAQqB,iBAAiB,SAAA,GAC5BnB,QACA;MAACV,GAAGQ,QAAQqB,iBAAiB,OAAA;KAAS,CAAA,CAAA,CAAA;IAK9C7B,GAAGQ,QAAQ2B,sBACTnC,GAAGQ,QAAQqB,iBAAiB,QAAA,CAAA;GAE/B,CAAA;AAET,GArEiB5B,sCAAAA,oCAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\nimport { NotationGeneralProgrammer } from \"./NotationGeneralProgrammer\";\n\nexport namespace NotationValidateGeneralProgrammer {\n  export const write =\n    (rename: (str: string) => string) =>\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string) =>\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n        ts.factory.createTypeReferenceNode(\n          `typia.IValidation<${NotationGeneralProgrammer.returnType(rename)(\n            name ?? TypeFactory.getFullName(project.checker)(type),\n          )}>`,\n        ),\n        undefined,\n        ts.factory.createBlock([\n          StatementFactory.constant(\n            \"validate\",\n            ValidateProgrammer.write({\n              ...project,\n              options: {\n                ...project.options,\n                functional: false,\n                numeric: true,\n              },\n            })(modulo)(false)(type, name),\n          ),\n          StatementFactory.constant(\n            \"general\",\n            NotationGeneralProgrammer.write(rename)({\n              ...project,\n              options: {\n                ...project.options,\n                functional: false,\n                numeric: false,\n              },\n            })(modulo)(type, name),\n          ),\n          StatementFactory.constant(\n            \"output\",\n            ts.factory.createAsExpression(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"validate\"),\n                undefined,\n                [ts.factory.createIdentifier(\"input\")],\n              ),\n              TypeFactory.keyword(\"any\"),\n            ),\n          ),\n          ts.factory.createIfStatement(\n            ts.factory.createIdentifier(\"output.success\"),\n            ts.factory.createExpressionStatement(\n              ts.factory.createBinaryExpression(\n                ts.factory.createIdentifier(\"output.data\"),\n                ts.SyntaxKind.EqualsToken,\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"general\"),\n                  undefined,\n                  [ts.factory.createIdentifier(\"input\")],\n                ),\n              ),\n            ),\n          ),\n          ts.factory.createReturnStatement(\n            ts.factory.createIdentifier(\"output\"),\n          ),\n        ]),\n      );\n}\n"]}