{"version":3,"sources":["../src/programmers/ValidateProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { check_everything } from \"./internal/check_everything\";\nimport { check_object } from \"./internal/check_object\";\n\nexport namespace ValidateProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (type: ts.Type, name?: string) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n\n      const is = IsProgrammer.write(project)(modulo, true)(equals)(\n        type,\n        name ?? TypeFactory.getFullName(project.checker)(type),\n      );\n      const validate: ts.ArrowFunction = CheckerProgrammer.write(project)({\n        prefix: \"$v\",\n        path: true,\n        trace: true,\n        numeric: OptionPredicator.numeric(project.options),\n        equals,\n        atomist: (explore) => (entry) => (input) =>\n          [\n            ...(entry.expression ? [entry.expression] : []),\n            ...(entry.conditions.length === 0\n              ? []\n              : entry.conditions.length === 1\n                ? entry.conditions[0]!.map((cond) =>\n                    ts.factory.createLogicalOr(\n                      cond.expression,\n                      create_report_call(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        cond.expected,\n                        input,\n                      ),\n                    ),\n                  )\n                : [\n                    ts.factory.createLogicalOr(\n                      entry.conditions\n                        .map((set) =>\n                          set\n                            .map((s) => s.expression)\n                            .reduce((a, b) =>\n                              ts.factory.createLogicalAnd(a, b),\n                            ),\n                        )\n                        .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n                      create_report_call(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        entry.expected,\n                        input,\n                      ),\n                    ),\n                  ]),\n          ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n        combiner: combine(equals)(project)(importer),\n        joiner: joiner(equals)(project)(importer),\n        success: ts.factory.createTrue(),\n        addition: () => importer.declare(modulo),\n      })(importer)(type, name);\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n        ts.factory.createTypeReferenceNode(\n          `typia.IValidation<${\n            name ?? TypeFactory.getFullName(project.checker)(type)\n          }>`,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            StatementFactory.constant(\n              \"errors\",\n              ts.factory.createAsExpression(\n                ts.factory.createArrayLiteralExpression([]),\n                ts.factory.createArrayTypeNode(TypeFactory.keyword(\"any\")),\n              ),\n            ),\n            StatementFactory.constant(\"__is\", is),\n            ts.factory.createIfStatement(\n              ts.factory.createStrictEquality(\n                ts.factory.createFalse(),\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"__is\"),\n                  undefined,\n                  [ts.factory.createIdentifier(\"input\")],\n                ),\n              ),\n              ts.factory.createBlock([\n                StatementFactory.constant(\n                  \"$report\",\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(\n                      ts.factory.createParenthesizedExpression(\n                        ts.factory.createAsExpression(\n                          modulo,\n                          TypeFactory.keyword(\"any\"),\n                        ),\n                      ),\n                    )(\"report\"),\n                    [],\n                    [ts.factory.createIdentifier(\"errors\")],\n                  ),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(validate, undefined, [\n                    ts.factory.createIdentifier(\"input\"),\n                    ts.factory.createStringLiteral(\"$input\"),\n                    ts.factory.createTrue(),\n                  ]),\n                ),\n              ]),\n            ),\n            StatementFactory.constant(\n              \"success\",\n              ts.factory.createStrictEquality(\n                ExpressionFactory.number(0),\n                ts.factory.createIdentifier(\"errors.length\"),\n              ),\n            ),\n            ts.factory.createReturnStatement(\n              ts.factory.createAsExpression(\n                create_output(),\n                TypeFactory.keyword(\"any\"),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n}\n\nconst combine =\n  (equals: boolean) =>\n  (project: IProject) =>\n  (importer: FunctionImporter): CheckerProgrammer.IConfig.Combiner =>\n  (explore: CheckerProgrammer.IExplore) => {\n    if (explore.tracable === false)\n      return IsProgrammer.configure({\n        object: validate_object(equals)(project)(importer),\n        numeric: true,\n      })(project)(importer).combiner(explore);\n\n    const path: string = explore.postfix\n      ? `_path + ${explore.postfix}`\n      : \"_path\";\n    return (logic) => (input, binaries, expected) =>\n      logic === \"and\"\n        ? binaries\n            .map((binary) =>\n              binary.combined\n                ? binary.expression\n                : ts.factory.createLogicalOr(\n                    binary.expression,\n                    create_report_call(\n                      explore.source === \"top\"\n                        ? ts.factory.createTrue()\n                        : ts.factory.createIdentifier(\"_exceptionable\"),\n                    )(ts.factory.createIdentifier(path), expected, input),\n                  ),\n            )\n            .reduce(ts.factory.createLogicalAnd)\n        : ts.factory.createLogicalOr(\n            binaries\n              .map((binary) => binary.expression)\n              .reduce(ts.factory.createLogicalOr),\n            create_report_call(\n              explore.source === \"top\"\n                ? ts.factory.createTrue()\n                : ts.factory.createIdentifier(\"_exceptionable\"),\n            )(ts.factory.createIdentifier(path), expected, input),\n          );\n  };\n\nconst validate_object =\n  (equals: boolean) => (project: IProject) => (importer: FunctionImporter) =>\n    check_object({\n      equals,\n      undefined: true,\n      assert: false,\n      reduce: ts.factory.createLogicalAnd,\n      positive: ts.factory.createTrue(),\n      superfluous: (value) =>\n        create_report_call()(\n          ts.factory.createAdd(\n            ts.factory.createIdentifier(\"_path\"),\n            ts.factory.createCallExpression(importer.use(\"join\"), undefined, [\n              ts.factory.createIdentifier(\"key\"),\n            ]),\n          ),\n          \"undefined\",\n          value,\n        ),\n      halt: (expr) =>\n        ts.factory.createLogicalOr(\n          ts.factory.createStrictEquality(\n            ts.factory.createFalse(),\n            ts.factory.createIdentifier(\"_exceptionable\"),\n          ),\n          expr,\n        ),\n    })(project)(importer);\n\nconst joiner =\n  (equals: boolean) =>\n  (project: IProject) =>\n  (importer: FunctionImporter): CheckerProgrammer.IConfig.IJoiner => ({\n    object: validate_object(equals)(project)(importer),\n    array: (input, arrow) =>\n      check_everything(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"map\"),\n          undefined,\n          [arrow],\n        ),\n      ),\n    failure: (value, expected, explore) =>\n      create_report_call(\n        explore?.from === \"top\"\n          ? ts.factory.createTrue()\n          : ts.factory.createIdentifier(\"_exceptionable\"),\n      )(\n        ts.factory.createIdentifier(\n          explore?.postfix ? `_path + ${explore.postfix}` : \"_path\",\n        ),\n        expected,\n        value,\n      ),\n    tuple: (binaries) =>\n      check_everything(ts.factory.createArrayLiteralExpression(binaries, true)),\n  });\n\nconst create_output = () =>\n  ts.factory.createObjectLiteralExpression(\n    [\n      ts.factory.createShorthandPropertyAssignment(\"success\"),\n      ts.factory.createShorthandPropertyAssignment(\"errors\"),\n      ts.factory.createPropertyAssignment(\n        \"data\",\n        ts.factory.createConditionalExpression(\n          ts.factory.createIdentifier(\"success\"),\n          undefined,\n          ts.factory.createIdentifier(\"input\"),\n          undefined,\n          ts.factory.createIdentifier(\"undefined\"),\n        ),\n      ),\n    ],\n    true,\n  );\n\nconst create_report_call =\n  (exceptionable?: ts.Expression) =>\n  (\n    path: ts.Expression,\n    expected: string,\n    value: ts.Expression,\n  ): ts.Expression =>\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"$report\"),\n      undefined,\n      [\n        exceptionable ?? ts.factory.createIdentifier(\"_exceptionable\"),\n        ts.factory.createObjectLiteralExpression(\n          [\n            ts.factory.createPropertyAssignment(\"path\", path),\n            ts.factory.createPropertyAssignment(\n              \"expected\",\n              ts.factory.createStringLiteral(expected),\n            ),\n            ts.factory.createPropertyAssignment(\"value\", value),\n          ],\n          true,\n        ),\n      ],\n    );\n"],"mappings":"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","names":["ts","ValidateProgrammer","write","project","modulo","equals","type","name","importer","FunctionImporter","getText","is","IsProgrammer","TypeFactory","getFullName","checker","validate","CheckerProgrammer","prefix","path","trace","numeric","OptionPredicator","options","atomist","explore","entry","input","expression","conditions","length","map","cond","ts","factory","createLogicalOr","create_report_call","from","createTrue","createIdentifier","postfix","expected","set","s","reduce","a","b","createLogicalAnd","x","y","combiner","combine","joiner","success","addition","declare","createArrowFunction","undefined","IdentifierFactory","parameter","keyword","createTypeReferenceNode","createBlock","StatementFactory","constant","createAsExpression","createArrayLiteralExpression","createArrayTypeNode","createIfStatement","createStrictEquality","createFalse","createCallExpression","access","createParenthesizedExpression","createExpressionStatement","createStringLiteral","ExpressionFactory","number","createReturnStatement","create_output","tracable","configure","object","validate_object","logic","binaries","binary","combined","source","check_object","assert","positive","superfluous","value","createAdd","use","halt","expr","array","arrow","check_everything","failure","tuple","createObjectLiteralExpression","createShorthandPropertyAssignment","createPropertyAssignment","createConditionalExpression","exceptionable"]}