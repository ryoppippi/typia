{"version":3,"sources":["../src/factories/LiteralFactory.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"./ExpressionFactory\";\nimport { IdentifierFactory } from \"./IdentifierFactory\";\n\nexport namespace LiteralFactory {\n  export const generate = (input: any): ts.Expression => {\n    if (input === null) return ts.factory.createNull();\n    else if (ts.isIdentifier(input)) return input;\n    else if (input instanceof Array) return generate_array(input);\n    else if (typeof input === \"object\") return generate_object(input);\n    else if (typeof input === \"string\") return generate_string(input);\n    else if (typeof input === \"boolean\") return generate_value(input);\n    else if (typeof input === \"number\") return generate_value(input);\n    else if (typeof input === \"bigint\") return generate_bigint(input);\n    // unreachable code\n    else if (typeof input === \"function\")\n      return ts.factory.createIdentifier(\"undefined\");\n    else\n      throw new TypeError(\"Error on LiteralFactory.generate(): unknown type.\");\n  };\n\n  const generate_object = (obj: object): ts.ObjectLiteralExpression =>\n    ts.factory.createObjectLiteralExpression(\n      Object.entries(obj)\n        .filter((tuple) => tuple[1] !== undefined)\n        .map(([key, value]) =>\n          ts.factory.createPropertyAssignment(\n            IdentifierFactory.identifier(key),\n            generate(value),\n          ),\n        ),\n      true,\n    );\n\n  const generate_array = (array: any[]): ts.ArrayLiteralExpression =>\n    ts.factory.createArrayLiteralExpression(array.map(generate), true);\n\n  const generate_value = (value: number | boolean | bigint): ts.Expression =>\n    ts.factory.createIdentifier(value.toString());\n\n  const generate_bigint = (value: bigint): ts.Expression =>\n    ExpressionFactory.bigint(value);\n\n  const generate_string = (value: string): ts.StringLiteral =>\n    ts.factory.createStringLiteral(value);\n}\n"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAKEC,iBAAAA;kBACFC,WAAW,CAACC,UAAAA;AACvB,QAAIA,UAAU,KAAM,QAAOC,GAAGC,QAAQC,WAAU;aACvCF,GAAGG,aAAaJ,KAAAA,EAAQ,QAAOA;aAC/BA,iBAAiBK,MAAO,QAAOC,eAAeN,KAAAA;aAC9C,OAAOA,UAAU,SAAU,QAAOO,gBAAgBP,KAAAA;aAClD,OAAOA,UAAU,SAAU,QAAOQ,gBAAgBR,KAAAA;aAClD,OAAOA,UAAU,UAAW,QAAOS,eAAeT,KAAAA;aAClD,OAAOA,UAAU,SAAU,QAAOS,eAAeT,KAAAA;aACjD,OAAOA,UAAU,SAAU,QAAOU,gBAAgBV,KAAAA;aAElD,OAAOA,UAAU,WACxB,QAAOC,GAAGC,QAAQS,iBAAiB,WAAA;QAEnC,OAAM,IAAIC,UAAU,mDAAA;EACxB;AAEA,QAAML,kBAAkB,wBAACM,QACvBZ,GAAGC,QAAQY,8BACTC,OAAOC,QAAQH,GAAAA,EACZI,OAAO,CAACC,UAAUA,MAAM,CAAA,MAAOC,MAAAA,EAC/BC,IAAI,CAAC,CAACC,KAAKC,KAAAA,MACVrB,GAAGC,QAAQqB,yBACTC,kBAAkBC,WAAWJ,GAAAA,GAC7BtB,gBAAAA,SAASuB,KAAAA,CAAAA,CAAAA,GAGf,IAAA,GAVoB;AAaxB,QAAMhB,iBAAiB,wBAACoB,UACtBzB,GAAGC,QAAQyB,6BAA6BD,MAAMN,IAAGtB,gBAACC,QAAAA,GAAW,IAAA,GADxC;AAGvB,QAAMU,iBAAiB,wBAACa,UACtBrB,GAAGC,QAAQS,iBAAiBW,MAAMM,SAAQ,CAAA,GADrB;AAGvB,QAAMlB,kBAAkB,wBAACY,UACvBO,kBAAkBC,OAAOR,KAAAA,GADH;AAGxB,QAAMd,kBAAkB,wBAACc,UACvBrB,GAAGC,QAAQ6B,oBAAoBT,KAAAA,GADT;AAE1B,GAzCiBxB,mBAAAA,iBAAAA,CAAAA,EAAAA;","names":["ts","LiteralFactory","generate","input","ts","factory","createNull","isIdentifier","Array","generate_array","generate_object","generate_string","generate_value","generate_bigint","createIdentifier","TypeError","obj","createObjectLiteralExpression","Object","entries","filter","tuple","undefined","map","key","value","createPropertyAssignment","IdentifierFactory","identifier","array","createArrayLiteralExpression","toString","ExpressionFactory","bigint","createStringLiteral"]}