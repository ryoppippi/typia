{"version":3,"sources":["../src/schemas/metadata/Metadata.ts","../src/schemas/metadata/MetadataEscaped.ts"],"sourcesContent":["import { ClassProperties } from \"../../typings/ClassProperties\";\n\nimport { ArrayUtil } from \"../../utils/ArrayUtil\";\n\nimport { IMetadata } from \"./IMetadata\";\nimport { IMetadataDictionary } from \"./IMetadataDictionary\";\nimport { IMetadataTypeTag } from \"./IMetadataTypeTag\";\nimport { MetadataAlias } from \"./MetadataAlias\";\nimport { MetadataArray } from \"./MetadataArray\";\nimport { MetadataAtomic } from \"./MetadataAtomic\";\nimport { MetadataConstant } from \"./MetadataConstant\";\nimport { MetadataEscaped } from \"./MetadataEscaped\";\nimport { MetadataObject } from \"./MetadataObject\";\nimport { MetadataTuple } from \"./MetadataTuple\";\n\nexport class Metadata {\n  public any: boolean;\n  public required: boolean;\n  public optional: boolean;\n  public nullable: boolean;\n  public functional: boolean;\n\n  public escaped: MetadataEscaped | null;\n  public atomics: MetadataAtomic[];\n  public constants: MetadataConstant[];\n  public templates: Metadata[][];\n\n  public rest: Metadata | null;\n  public aliases: MetadataAlias[];\n  public arrays: MetadataArray[];\n  public tuples: MetadataTuple[];\n  public objects: MetadataObject[];\n\n  public natives: string[];\n  public sets: Metadata[];\n  public maps: Metadata.Entry[];\n\n  /** @internal */ private name_?: string;\n  /** @internal */ private parent_resolved_: boolean = false;\n  /** @internal */ public union_index?: number;\n  /** @internal */ public fixed_?: number | null;\n  /** @internal */ public boolean_literal_intersected_?: boolean;\n\n  /* -----------------------------------------------------------\n    CONSTRUCTORS\n  ----------------------------------------------------------- */\n  /**\n   * @hidden\n   */\n  private constructor(props: ClassProperties<Metadata>) {\n    this.any = props.any;\n    this.required = props.required;\n    this.optional = props.optional;\n    this.nullable = props.nullable;\n    this.functional = props.functional;\n\n    this.escaped = props.escaped;\n    this.atomics = props.atomics;\n    this.constants = props.constants;\n    this.templates = props.templates;\n\n    this.rest = props.rest;\n    this.arrays = props.arrays;\n    this.tuples = props.tuples;\n    this.objects = props.objects;\n    this.aliases = props.aliases;\n\n    this.natives = props.natives;\n    this.sets = props.sets;\n    this.maps = props.maps;\n  }\n\n  /**\n   * @internal\n   */\n  public static create(props: ClassProperties<Metadata>): Metadata {\n    return new Metadata(props);\n  }\n\n  /**\n   * @internal\n   */\n  public static initialize(parentResolved: boolean = false): Metadata {\n    const meta: Metadata = Metadata.create({\n      any: false,\n      nullable: false,\n      required: true,\n      optional: false,\n      functional: false,\n\n      escaped: null,\n      constants: [],\n      atomics: [],\n      templates: [],\n      arrays: [],\n      tuples: [],\n      objects: [],\n      aliases: [],\n\n      rest: null,\n      natives: [],\n      sets: [],\n      maps: [],\n    });\n    meta.parent_resolved_ = parentResolved;\n    return meta;\n  }\n\n  public toJSON(): IMetadata {\n    return {\n      any: this.any,\n      required: this.required,\n      optional: this.optional,\n      nullable: this.nullable,\n      functional: this.functional,\n\n      atomics: this.atomics.map((a) => a.toJSON()),\n      constants: this.constants.map((c) => c.toJSON()),\n      templates: this.templates.map((tpl) => tpl.map((meta) => meta.toJSON())),\n      escaped: this.escaped ? this.escaped.toJSON() : null,\n\n      rest: this.rest ? this.rest.toJSON() : null,\n      arrays: this.arrays.map((array) => ({\n        name: array.type.name,\n        tags: array.tags.map((r) => r.slice()),\n      })),\n      tuples: this.tuples.map((tuple) => ({\n        name: tuple.type.name,\n        tags: tuple.tags.map((r) => r.slice()),\n      })),\n      objects: this.objects.map((obj) => obj.name),\n      aliases: this.aliases.map((alias) => alias.name),\n\n      natives: this.natives.slice(),\n      sets: this.sets.map((meta) => meta.toJSON()),\n      maps: this.maps.map((entry) => ({\n        key: entry.key.toJSON(),\n        value: entry.value.toJSON(),\n      })),\n    };\n  }\n\n  public static from(meta: IMetadata, dict: IMetadataDictionary): Metadata {\n    return Metadata.create({\n      any: meta.any,\n      required: meta.required,\n      optional: meta.optional,\n      nullable: meta.nullable,\n      functional: meta.functional,\n\n      constants: meta.constants.map(MetadataConstant.from),\n      atomics: meta.atomics.map(MetadataAtomic.from),\n      templates: meta.templates.map((tpl) =>\n        tpl.map((meta) => this.from(meta, dict)),\n      ),\n      escaped: meta.escaped ? MetadataEscaped.from(meta.escaped, dict) : null,\n\n      rest: meta.rest ? this.from(meta.rest, dict) : null,\n      arrays: meta.arrays.map((ref) => {\n        const type = dict.arrays.get(ref.name);\n        if (type === undefined)\n          throw new RangeError(\n            `Error on Metadata.from(): failed to find array \"${ref.name}\".`,\n          );\n        return MetadataArray.create({\n          type,\n          tags: ref.tags.map((row) => row.slice()),\n        });\n      }),\n      tuples: meta.tuples.map((t) => {\n        const type = dict.tuples.get(t.name);\n        if (type === undefined)\n          throw new RangeError(\n            `Error on Metadata.from(): failed to find tuple \"${t.name}\".`,\n          );\n        return MetadataTuple.create({\n          type,\n          tags: t.tags.map((r) => r.slice()),\n        });\n      }),\n      objects: meta.objects.map((name) => {\n        const found = dict.objects.get(name);\n        if (found === undefined)\n          throw new RangeError(\n            `Error on Metadata.from(): failed to find object \"${name}\".`,\n          );\n        return found;\n      }),\n      aliases: meta.aliases.map((alias) => {\n        const found = dict.aliases.get(alias);\n        if (found === undefined)\n          throw new RangeError(\n            `Error on Metadata.from(): failed to find alias \"${alias}\".`,\n          );\n        return found;\n      }),\n\n      natives: meta.natives.slice(),\n      sets: meta.sets.map((meta) => this.from(meta, dict)),\n      maps: meta.maps.map((entry) => ({\n        key: this.from(entry.key, dict),\n        value: this.from(entry.value, dict),\n      })),\n    });\n  }\n\n  /* -----------------------------------------------------------\n    ACCESSORS\n  ----------------------------------------------------------- */\n  public getName(): string {\n    return (this.name_ ??= getName(this));\n  }\n\n  public empty(): boolean {\n    return this.bucket() === 0 || this.size() === 0;\n  }\n\n  public size(): number {\n    return (\n      (this.any ? 1 : 0) +\n      (this.escaped ? 1 : 0) +\n      (this.functional ? 1 : 0) +\n      (this.rest ? this.rest.size() : 0) +\n      this.templates.length +\n      this.atomics.length +\n      this.constants.map((c) => c.values.length).reduce((x, y) => x + y, 0) +\n      this.arrays.length +\n      this.tuples.length +\n      this.natives.length +\n      this.maps.length +\n      this.sets.length +\n      this.objects.length +\n      this.aliases.length\n    );\n  }\n\n  public bucket(): number {\n    return (\n      (this.any ? 1 : 0) +\n      (this.escaped ? 1 : 0) +\n      (this.functional ? 1 : 0) +\n      (this.templates.length ? 1 : 0) +\n      (this.atomics.length ? 1 : 0) +\n      (this.constants.length ? 1 : 0) +\n      (this.rest ? this.rest.size() : 0) +\n      (this.arrays.length ? 1 : 0) +\n      (this.tuples.length ? 1 : 0) +\n      (this.natives.length ? 1 : 0) +\n      (this.sets.length ? 1 : 0) +\n      (this.maps.length ? 1 : 0) +\n      (this.objects.length ? 1 : 0) +\n      (this.aliases.length ? 1 : 0)\n    );\n  }\n\n  public isConstant(): boolean {\n    return this.bucket() === (this.constants.length ? 1 : 0);\n  }\n\n  public isRequired(): boolean {\n    return this.required === true && this.optional === false;\n  }\n\n  /**\n   * @internal\n   */\n  public isUnionBucket(): boolean {\n    const size: number = this.bucket();\n    const emended: number =\n      !!this.atomics.length && !!this.constants.length ? size - 1 : size;\n    return emended > 1;\n  }\n\n  /**\n   * @internal\n   */\n  public getSoleLiteral(): string | null {\n    if (\n      this.size() === 1 &&\n      this.constants.length === 1 &&\n      this.constants[0]!.type === \"string\" &&\n      this.constants[0]!.values.length === 1\n    )\n      return this.constants[0]!.values[0]!.value as string;\n    else return null;\n  }\n\n  public isSoleLiteral(): boolean {\n    return this.getSoleLiteral() !== null;\n  }\n\n  /**\n   * @internal\n   */\n  public isParentResolved(): boolean {\n    return this.parent_resolved_;\n  }\n}\nexport namespace Metadata {\n  export const intersects = (x: Metadata, y: Metadata): boolean => {\n    // CHECK ANY & OPTIONAL\n    if (x.any || y.any) return true;\n    if (x.isRequired() === false && false === y.isRequired()) return true;\n    if (x.nullable === true && true === y.nullable) return true;\n    if (x.functional === true && y.functional === true) return true;\n\n    //----\n    // INSTANCES\n    //----\n    // ARRAYS\n    if (x.arrays.length && y.arrays.length) return true;\n    if (x.tuples.length && y.tuples.length) return true;\n    if (x.objects.length && y.objects.length) return true;\n    if (x.aliases.length && y.aliases.length) return true;\n\n    // NATIVES\n    if (x.natives.length && y.natives.length)\n      if (x.natives.some((xn) => y.natives.some((yn) => xn === yn)))\n        return true;\n\n    // ESCAPED\n    if (x.escaped && y.escaped)\n      return (\n        intersects(x.escaped.original, y.escaped.original) ||\n        intersects(x.escaped.returns, y.escaped.returns)\n      );\n\n    //----\n    // VALUES\n    //----\n    // ATOMICS\n    for (const atomic of x.atomics) {\n      if (y.atomics.some((ya) => atomic.type === ya.type)) return true;\n      if (y.constants.some((yc) => atomic.type === yc.type)) return true;\n    }\n\n    // CONSTANTS\n    for (const constant of x.constants) {\n      const atomic: MetadataAtomic | undefined = y.atomics.find(\n        (elem) => elem.type === constant.type,\n      );\n      if (atomic !== undefined) return true;\n\n      const opposite: MetadataConstant | undefined = y.constants.find(\n        (elem) => elem.type === constant.type,\n      );\n      if (opposite === undefined) continue;\n\n      const values: Set<any> = new Set([\n        ...constant.values.map((e) => e.value),\n        ...opposite.values.map((e) => e.value),\n      ]);\n      if (values.size !== constant.values.length + opposite.values.length)\n        return true;\n    }\n\n    // TEMPLATES\n    if (!!x.templates.length && y.atomics.some((ya) => ya.type === \"string\"))\n      return true;\n    else if (\n      !!y.templates.length &&\n      x.atomics.some((xa) => xa.type === \"string\")\n    )\n      return true;\n    return false;\n  };\n\n  export const covers = (\n    x: Metadata,\n    y: Metadata,\n    level: number = 0,\n    escaped: boolean = false,\n  ): boolean => {\n    // CHECK ANY\n    if (x === y) return false;\n    else if (x.any) return true;\n    else if (y.any) return false;\n\n    if (escaped === false) {\n      if (x.escaped === null && y.escaped !== null) return false;\n      else if (\n        x.escaped !== null &&\n        y.escaped !== null &&\n        (!covers(x.escaped.original, y.escaped.original, level, true) ||\n          !covers(x.escaped.returns, y.escaped.returns, level, true))\n      )\n        return false;\n    }\n\n    //----\n    // INSTANCES\n    //----\n    if (level === 0) {\n      // ARRAYS\n      for (const ya of y.arrays)\n        if (\n          !x.arrays.some((xa) =>\n            covers(xa.type.value, ya.type.value, level + 1),\n          )\n        ) {\n          return false;\n        }\n\n      // TUPLES\n      for (const yt of y.tuples)\n        if (\n          yt.type.elements.length !== 0 &&\n          x.tuples.some(\n            (xt) =>\n              xt.type.elements.length >= yt.type.elements.length &&\n              xt.type.elements\n                .slice(yt.type.elements.length)\n                .every((xv, i) => covers(xv, yt.type.elements[i]!, level + 1)),\n          ) === false\n        )\n          return false;\n    }\n\n    // OBJECTS\n    for (const yo of y.objects)\n      if (x.objects.some((xo) => MetadataObject.covers(xo, yo)) === false)\n        return false;\n\n    // ALIASES\n    for (const yd of y.aliases)\n      if (x.aliases.some((xd) => xd.name === yd.name) === false) return false;\n\n    // NATIVES\n    for (const yn of y.natives)\n      if (x.natives.some((xn) => xn === yn) === false) return false;\n\n    // SETS\n    for (const ys of y.sets)\n      if (x.sets.some((xs) => covers(xs, ys)) === false) return false;\n\n    //----\n    // VALUES\n    //----\n    // ATOMICS\n    if (\n      y.atomics.some(\n        (ya) => x.atomics.some((xa) => xa.type === ya.type) === false,\n      )\n    )\n      return false;\n\n    // CONSTANTS\n    for (const yc of y.constants) {\n      if (x.atomics.some((atom) => yc.type === atom.type)) continue;\n      const xc: MetadataConstant | undefined = x.constants.find(\n        (elem) => elem.type === yc.type,\n      );\n      if (xc === undefined) return false;\n      else if (\n        (yc.values.map((e) => e.value) as number[]).some(\n          (yv) => xc.values.includes(yv as never) === false,\n        )\n      )\n        return false;\n    }\n\n    // FUNCTIONAL\n    if (x.functional === false && y.functional) return false;\n\n    // SUCCESS\n    return true;\n  };\n\n  /**\n   * @internal\n   */\n  export const merge = (x: Metadata, y: Metadata): Metadata => {\n    const output: Metadata = Metadata.create({\n      any: x.any || y.any,\n      nullable: x.nullable || y.nullable,\n      required: x.required && y.required,\n      optional: x.optional || y.optional,\n      functional: x.functional || y.functional,\n\n      escaped:\n        x.escaped !== null && y.escaped !== null\n          ? MetadataEscaped.create({\n              original: merge(x.escaped.original, y.escaped.original),\n              returns: merge(x.escaped.returns, y.escaped.returns),\n            })\n          : x.escaped ?? y.escaped,\n      atomics: mergeTaggedTypes({\n        container: x.atomics,\n        equals: (x, y) => x.type === y.type,\n        getter: (x) => x.tags,\n      })(y.atomics),\n      constants: [...x.constants],\n      templates: x.templates.slice(),\n\n      rest:\n        x.rest !== null && y.rest !== null\n          ? merge(x.rest, y.rest)\n          : x.rest ?? y.rest,\n      // arrays: x.arrays.slice(),\n      arrays: mergeTaggedTypes({\n        container: x.arrays,\n        equals: (x, y) => x.type.name === y.type.name,\n        getter: (x) => x.tags,\n      })(y.arrays),\n      tuples: mergeTaggedTypes({\n        container: x.tuples,\n        equals: (x, y) => x.type.name === y.type.name,\n        getter: (x) => x.tags,\n      })(y.tuples),\n      objects: x.objects.slice(),\n      aliases: x.aliases.slice(),\n\n      natives: [...new Set([...x.natives, ...y.natives])],\n      sets: x.sets.slice(),\n      maps: x.maps.slice(),\n    });\n    for (const constant of y.constants) {\n      const target: MetadataConstant = ArrayUtil.take(\n        output.constants,\n        (elem) => elem.type === constant.type,\n        () =>\n          MetadataConstant.create({\n            type: constant.type,\n            values: [],\n          }),\n      );\n      for (const value of constant.values)\n        ArrayUtil.add(target.values, value, (a, b) => a.value === b.value);\n    }\n    for (const obj of y.objects)\n      ArrayUtil.set(output.objects, obj, (elem) => elem.name);\n    for (const alias of y.aliases)\n      ArrayUtil.set(output.aliases, alias, (elem) => elem.name);\n\n    return output;\n  };\n}\n\nconst getName = (metadata: Metadata): string => {\n  if (metadata.any === true) return \"any\";\n\n  const elements: string[] = [];\n\n  // OPTIONAL\n  if (metadata.nullable === true) elements.push(\"null\");\n  if (metadata.isRequired() === false) elements.push(\"undefined\");\n\n  // ATOMIC\n  for (const atom of metadata.atomics) {\n    elements.push(atom.getName());\n  }\n  for (const constant of metadata.constants)\n    for (const value of constant.values) elements.push(value.getName());\n  for (const template of metadata.templates)\n    elements.push(\n      \"`\" +\n        template\n          .map((child) =>\n            child.isConstant() && child.size() === 1\n              ? child.constants[0]!.values[0]!\n              : `$\\{${child.getName()}\\}`,\n          )\n          .join(\"\")\n          .split(\"`\")\n          .join(\"\\\\`\") +\n        \"`\",\n    );\n\n  // NATIVES\n  for (const native of metadata.natives) elements.push(native);\n  for (const set of metadata.sets) elements.push(`Set<${set.getName()}>`);\n  for (const map of metadata.maps)\n    elements.push(`Map<${map.key.getName()}, ${map.value.getName()}>`);\n\n  // INSTANCES\n  if (metadata.rest !== null) elements.push(`...${metadata.rest.getName()}`);\n  for (const tuple of metadata.tuples) elements.push(tuple.type.name);\n  for (const array of metadata.arrays) elements.push(array.getName());\n  for (const object of metadata.objects) elements.push(object.name);\n  for (const alias of metadata.aliases) elements.push(alias.name);\n  if (metadata.escaped !== null) elements.push(metadata.escaped.getName());\n\n  // RETURNS\n  if (elements.length === 0) return \"unknown\";\n  else if (elements.length === 1) return elements[0]!;\n\n  elements.sort();\n  return `(${elements.join(\" | \")})`;\n};\nexport namespace Metadata {\n  export interface Entry {\n    key: Metadata;\n    value: Metadata;\n  }\n}\n\nconst mergeTaggedTypes =\n  <T>(props: {\n    container: T[];\n    equals: (x: T, y: T) => boolean;\n    getter: (x: T) => IMetadataTypeTag[][];\n  }) =>\n  (opposite: T[]) => {\n    const output: T[] = [...props.container];\n    for (const elem of opposite) {\n      const equal = props.container.find((x) => props.equals(x, elem));\n      if (equal === undefined) {\n        output.push(elem);\n        continue;\n      }\n\n      const matrix: string[][] = props\n        .getter(equal)\n        .map((tags) => tags.map((t) => t.name))\n        .sort();\n      for (const tags of props.getter(elem)) {\n        const names: string[] = tags.map((t) => t.name).sort();\n        if (\n          matrix.some(\n            (m) =>\n              m.length === names.length && m.every((s, i) => s === names[i]),\n          )\n        )\n          continue;\n        props.getter(equal).push(tags);\n      }\n    }\n    return output;\n  };\n","import { ClassProperties } from \"../../typings/ClassProperties\";\n\nimport { IMetadataDictionary } from \"./IMetadataDictionary\";\nimport { IMetadataEscaped } from \"./IMetadataEscaped\";\nimport { Metadata } from \"./Metadata\";\n\nexport class MetadataEscaped {\n  public readonly original: Metadata;\n  public readonly returns: Metadata;\n\n  /**\n   * @hidden\n   */\n  private constructor(props: ClassProperties<MetadataEscaped>) {\n    this.original = props.original;\n    this.returns = props.returns;\n  }\n\n  /**\n   * @internal\n   */\n  public static from(\n    props: IMetadataEscaped,\n    dict: IMetadataDictionary,\n  ): MetadataEscaped {\n    return MetadataEscaped.create({\n      original: Metadata.from(props.original, dict),\n      returns: Metadata.from(props.returns, dict),\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public static create(\n    props: ClassProperties<MetadataEscaped>,\n  ): MetadataEscaped {\n    return new MetadataEscaped(props);\n  }\n\n  public getName(): string {\n    return this.returns.getName();\n  }\n\n  public toJSON(): IMetadataEscaped {\n    return {\n      original: this.original.toJSON(),\n      returns: this.returns.toJSON(),\n    };\n  }\n}\n"],"mappings":"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","names":["Metadata","any","required","optional","nullable","functional","escaped","atomics","constants","templates","rest","aliases","arrays","tuples","objects","natives","sets","maps","name_","parent_resolved_","union_index","fixed_","boolean_literal_intersected_","props","create","initialize","parentResolved","meta","toJSON","map","a","c","tpl","array","name","type","tags","r","slice","tuple","obj","alias","entry","key","value","from","dict","MetadataConstant","MetadataAtomic","MetadataEscaped","ref","get","undefined","RangeError","MetadataArray","row","t","MetadataTuple","found","getName","empty","bucket","size","length","values","reduce","x","y","isConstant","isRequired","isUnionBucket","emended","getSoleLiteral","isSoleLiteral","isParentResolved","intersects","some","xn","yn","original","returns","atomic","ya","yc","constant","find","elem","opposite","Set","e","xa","covers","level","yt","elements","xt","every","xv","i","yo","xo","MetadataObject","yd","xd","ys","xs","atom","xc","yv","includes","merge","output","mergeTaggedTypes","container","equals","getter","target","ArrayUtil","take","add","b","set","metadata","push","template","child","join","split","native","object","sort","equal","matrix","names","m","s","MetadataEscaped","original","returns","props","from","dict","create","Metadata","getName","toJSON"]}