{"version":3,"sources":["../src/programmers/functional/FunctionalAssertParametersProgrammer.ts","../src/programmers/functional/FunctionalAssertFunctionProgrammer.ts","../src/programmers/functional/FunctionalAssertReturnProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertFunctionProgrammer } from \"./FunctionalAssertFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalAssertParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = FunctionalAssertFunctionProgrammer.errorFactoryWrapper(\n        modulo,\n      )(declaration.parameters)(init);\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock(\n          [\n            wrapper.variable,\n            ...argumentExpressions(project)(modulo)(equals)(\n              declaration.parameters,\n              wrapper.name,\n            ).map(ts.factory.createExpressionStatement),\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                expression,\n                undefined,\n                declaration.parameters.map((p) =>\n                  ts.factory.createIdentifier(p.name.getText()),\n                ),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const argumentExpressions =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      parameters: readonly ts.ParameterDeclaration[],\n      wrapper: string,\n    ): ts.CallExpression[] =>\n      parameters.map((p, i) =>\n        ts.factory.createCallExpression(\n          AssertProgrammer.write(project)(modulo)(equals)(\n            p.type\n              ? project.checker.getTypeFromTypeNode(p.type)\n              : project.checker.getTypeFromTypeNode(TypeFactory.keyword(\"any\")),\n            undefined,\n            FunctionalAssertFunctionProgrammer.hookPath({\n              wrapper,\n              replacer: `$input.parameters[${i}]`,\n            }),\n          ),\n          undefined,\n          [ts.factory.createIdentifier(p.name.getText())],\n        ),\n      );\n}\n","import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertParametersProgrammer } from \"./FunctionalAssertParametersProgrammer\";\nimport { FunctionAssertReturnProgrammer } from \"./FunctionalAssertReturnProgrammer\";\n\nexport namespace FunctionalAssertFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = errorFactoryWrapper(modulo)(declaration.parameters)(init);\n      const { async, returns } = FunctionAssertReturnProgrammer.returnStatement(\n        project,\n      )(modulo)(equals)(expression, declaration, wrapper.name);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock([\n          wrapper.variable,\n          ...FunctionalAssertParametersProgrammer.argumentExpressions(project)(\n            modulo,\n          )(equals)(declaration.parameters, wrapper.name).map(\n            ts.factory.createExpressionStatement,\n          ),\n          returns,\n        ]),\n      );\n    };\n\n  export const errorFactoryWrapper =\n    (modulo: ts.LeftHandSideExpression) =>\n    (paramters: readonly ts.ParameterDeclaration[]) =>\n    (\n      init: ts.Expression | undefined,\n    ): {\n      name: string;\n      variable: ts.VariableStatement;\n    } => {\n      const name: string = StringUtil.escapeDuplicate(\n        paramters.map((p) => p.name.getText()),\n      )(\"errorFactoryWrapper\");\n      const variable: ts.VariableStatement = ts.factory.createVariableStatement(\n        undefined,\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              name,\n              undefined,\n              AssertProgrammer.Guardian.type(),\n              init ??\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createAsExpression(\n                    modulo,\n                    TypeFactory.keyword(\"any\"),\n                  ),\n                  \"errorFactory\",\n                ),\n            ),\n          ],\n          ts.NodeFlags.Const,\n        ),\n      );\n      return { name, variable };\n    };\n\n  export const hookPath = (props: {\n    wrapper: string;\n    replacer: string;\n  }): ts.ArrowFunction =>\n    ts.factory.createArrowFunction(\n      undefined,\n      undefined,\n      [IdentifierFactory.parameter(\"p\")],\n      undefined,\n      undefined,\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(props.wrapper),\n        undefined,\n        [\n          ts.factory.createObjectLiteralExpression([\n            ts.factory.createSpreadAssignment(ts.factory.createIdentifier(\"p\")),\n            ts.factory.createPropertyAssignment(\n              \"path\",\n              ts.factory.createConditionalExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(\"p\"),\n                  \"path\",\n                ),\n                undefined,\n                ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(\"p\"),\n                      \"path\",\n                    ),\n                    \"replace\",\n                  ),\n                  undefined,\n                  [\n                    ts.factory.createStringLiteral(\"$input\"),\n                    ts.factory.createStringLiteral(props.replacer),\n                  ],\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"undefined\"),\n              ),\n            ),\n          ]),\n        ],\n      ),\n    );\n}\n","import ts from \"typescript\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertFunctionProgrammer } from \"./FunctionalAssertFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionAssertReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = FunctionalAssertFunctionProgrammer.errorFactoryWrapper(\n        modulo,\n      )(declaration.parameters)(init);\n      const { async, returns: statement } = returnStatement(project)(modulo)(\n        equals,\n      )(expression, declaration, wrapper.name);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock([wrapper.variable, statement], true),\n      );\n    };\n\n  export const returnStatement =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      wrapper: string,\n    ): {\n      async: boolean;\n      returns: ts.ReturnStatement;\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n      return {\n        async,\n        returns: ts.factory.createReturnStatement(\n          ts.factory.createCallExpression(\n            AssertProgrammer.write(project)(modulo)(equals)(\n              type,\n              undefined,\n              FunctionalAssertFunctionProgrammer.hookPath({\n                wrapper,\n                replacer: \"$input.return\",\n              }),\n            ),\n            undefined,\n            [async ? ts.factory.createAwaitExpression(caller) : caller],\n          ),\n        ),\n      };\n    };\n}\n"],"mappings":"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","names":["ts","ts","ts","FunctionAssertReturnProgrammer","write","project","modulo","equals","expression","declaration","init","wrapper","FunctionalAssertFunctionProgrammer","errorFactoryWrapper","parameters","async","returns","statement","returnStatement","name","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","type","createBlock","variable","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","getText","createReturnStatement","AssertProgrammer","hookPath","replacer","createAwaitExpression","FunctionalAssertFunctionProgrammer","write","project","modulo","equals","expression","declaration","init","wrapper","errorFactoryWrapper","parameters","async","returns","FunctionAssertReturnProgrammer","returnStatement","name","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","type","createBlock","variable","FunctionalAssertParametersProgrammer","argumentExpressions","map","createExpressionStatement","paramters","StringUtil","escapeDuplicate","p","getText","createVariableStatement","createVariableDeclarationList","createVariableDeclaration","AssertProgrammer","Guardian","createPropertyAccessExpression","createAsExpression","TypeFactory","keyword","NodeFlags","Const","hookPath","props","IdentifierFactory","parameter","createCallExpression","createIdentifier","createObjectLiteralExpression","createSpreadAssignment","createPropertyAssignment","createConditionalExpression","createStringLiteral","replacer","FunctionalAssertParametersProgrammer","write","project","modulo","equals","expression","declaration","init","wrapper","FunctionalAssertFunctionProgrammer","errorFactoryWrapper","parameters","async","FunctionalGeneralProgrammer","getReturnType","checker","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","type","createBlock","variable","argumentExpressions","name","map","createExpressionStatement","createReturnStatement","createCallExpression","p","createIdentifier","getText","i","AssertProgrammer","getTypeFromTypeNode","TypeFactory","keyword","hookPath","replacer"]}