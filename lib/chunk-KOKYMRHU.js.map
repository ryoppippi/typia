{"version":3,"sources":["../src/module.ts"],"names":["assert","halt","assertPure","Object","assign","Namespace","assertGuard","assertGuardPure","is","isPure","validate","validatePure","assertEquals","assertEqualsPure","assertGuardEquals","assertGuardEqualsPure","equals","equalsPure","validateEquals","validateEqualsPure","random","randomPure","createAssert","createAssertPure","createAssertGuard","createAssertGuardPure","createIs","createIsPure","createValidate","createValidatePure","createAssertEquals","createAssertEqualsPure","createAssertGuardEquals","createAssertGuardEqualsPure","createEquals","createEqualsPure","createValidateEquals","createValidateEqualsPure","createRandom","createRandomPure","name","Error"],"mappings":"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","sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { AssertionGuard } from \"./AssertionGuard\";\nimport { IRandomGenerator } from \"./IRandomGenerator\";\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\nexport * as functional from \"./functional\";\nexport * as http from \"./http\";\nexport * as json from \"./json\";\nexport * as misc from \"./misc\";\nexport * as notations from \"./notations\";\nexport * as protobuf from \"./protobuf\";\nexport * as reflect from \"./reflect\";\nexport * as tags from \"./tags\";\n\nexport * from \"./schemas/metadata/IJsDocTagInfo\";\nexport * from \"./schemas/json/IJsonApplication\";\nexport * from \"./AssertionGuard\";\nexport * from \"./IRandomGenerator\";\nexport * from \"./IValidation\";\nexport * from \"./TypeGuardError\";\n\nexport * from \"./Primitive\";\nexport * from \"./Resolved\";\nexport * from \"./CamelCase\";\nexport * from \"./PascalCase\";\nexport * from \"./SnakeCase\";\n\n/* -----------------------------------------------------------\n    BASIC VALIDATORS\n----------------------------------------------------------- */\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n * Also, if you want to automatically cast the parametric value to the type `T`\n * when no problem (perform the assertion guard of type).\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assert<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise, you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assert<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assert(): never {\n  halt(\"assert\");\n}\nconst assertPure = /** @__PURE__ */ Object.assign<typeof assert, {}>(\n  assert,\n  /** @__PURE__ */ Namespace.assert(\"assert\"),\n);\nexport { assertPure as assert };\n\n/**\n * Assertion guard of a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, nothing would be returned, but the input value\n * would be automatically casted to the type `T`. This is the concept of\n * \"Assertion Guard\" of a value type.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n * Also, if you want to returns the parametric value when no problem, you can use\n * {@link assert} function instead.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertGuardEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertGuard<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): asserts input is T;\n\n/**\n * Assertion guard of a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, nothing would be returned, but the input value\n * would be automatically casted to the type `T`. This is the concept of\n * \"Assertion Guard\" of a value type.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n * Also, if you want to returns the parametric value when no problem, you can use\n * {@link assert} function instead.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertGuardEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertGuard<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): asserts input is T;\n\n/**\n * @internal\n */\nfunction assertGuard(): never {\n  halt(\"assertGuard\");\n}\nconst assertGuardPure = /** @__PURE__ */ Object.assign<typeof assertGuard, {}>(\n  assertGuard,\n  /** @__PURE__ */ Namespace.assert(\"assertGuard\"),\n);\nexport { assertGuardPure as assertGuard };\n\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it's following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction is<T>(input: T): input is T;\n\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it's following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction is<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nfunction is(): never {\n  halt(\"is\");\n}\nconst isPure = /** @__PURE__ */ Object.assign<typeof is, {}>(\n  is,\n  /** @__PURE__ */ Namespace.assert(\"is\"),\n);\nexport { isPure as is };\n\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validate<T>(input: T): IValidation<T>;\n\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validate<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nfunction validate(): never {\n  halt(\"validate\");\n}\nconst validatePure = /** @__PURE__ */ Object.assign<typeof validate, {}>(\n  validate,\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validatePure as validate };\n\n/* -----------------------------------------------------------\n    STRICT VALIDATORS\n----------------------------------------------------------- */\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEquals<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEquals<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertEquals(): never {\n  halt(\"assertEquals\");\n}\nconst assertEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof assertEquals,\n  {}\n>(assertEquals, /** @__PURE__ */ Namespace.assert(\"assertEquals\"));\nexport { assertEqualsPure as assertEquals };\n\n/**\n * Assertion guard of a type with equality.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found.\n *\n * Otherwise, the value is following the type `T` without any superfluous property,\n * nothing would be returned, but the input value would be automatically casted to\n * the type `T`. This is the concept of \"Assertion Guard\" of a value type.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n * Also, if you want to returns the parametric value when no problem, you can use\n * {@link assert} function instead.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertGuardEquals<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): asserts input is T;\n\n/**\n * Assertion guard of a type with equality.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found.\n *\n * Otherwise, the value is following the type `T` without any superfluous property,\n * nothing would be returned, but the input value would be automatically casted to\n * the type `T`. This is the concept of \"Assertion Guard\" of a value type.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n * Also, if you want to returns the parametric value when no problem, you can use\n * {@link assertEquals} function instead.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assertGuard} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertGuardEquals<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): asserts input is T;\n\n/**\n * @internal\n */\nfunction assertGuardEquals(): never {\n  halt(\"assertGuardEquals\");\n}\nconst assertGuardEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof assertGuardEquals,\n  {}\n>(assertGuardEquals, /** @__PURE__ */ Namespace.assert(\"assertGuardEquals\"));\nexport { assertGuardEqualsPure as assertGuardEquals };\n\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it's equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there's not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction equals<T>(input: T): input is T;\n\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it's equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there's not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction equals<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nfunction equals(): never {\n  halt(\"equals\");\n}\nconst equalsPure = /** @__PURE__ */ Object.assign<typeof equals, {}>(\n  equals,\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { equalsPure as equals };\n\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEquals<T>(input: T): IValidation<T>;\n\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEquals<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nfunction validateEquals(): never {\n  halt(\"validateEquals\");\n}\nconst validateEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof validateEquals,\n  {}\n>(validateEquals, /** @__PURE__ */ Namespace.validate());\nexport { validateEqualsPure as validateEquals };\n\n/* -----------------------------------------------------------\n    RANDOM\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there're some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction random(generator?: Partial<IRandomGenerator>): never;\n\n/**\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there're some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction random<T>(generator?: Partial<IRandomGenerator>): Resolved<T>;\n\n/**\n * @internal\n */\nfunction random(): never {\n  halt(\"random\");\n}\nconst randomPure = /** @__PURE__ */ Object.assign<typeof random, {}>(\n  random,\n  /** @__PURE__ */ Namespace.random(),\n);\nexport { randomPure as random };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link assert} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssert(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assert} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssert<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => T;\n\n/**\n * @internal\n */\nfunction createAssert<T>(): (input: unknown) => T {\n  halt(\"createAssert\");\n}\nconst createAssertPure = /** @__PURE__ */ Object.assign<\n  typeof createAssert,\n  {}\n>(createAssert, assertPure);\nexport { createAssertPure as createAssert };\n\n/**\n * Creates a reusable {@link assertGuard} function.\n *\n * Note that, you've to declare the variable type of the factory function caller\n * like below. If you don't declare the variable type, compilation error be thrown.\n * This is the special rule of the TypeScript compiler.\n *\n * ```typescript\n * // MUST DECLARE THE VARIABLE TYPE\n * const func: typia.AssertionGuard<number> = typia.createAssertGuard<number>();\n *\n * // IF NOT, COMPILATION ERROR BE OCCURED\n * const func = typia.createAssertGuard<number>();\n * ```\n *\n * > *Assertions require every name in the call target to be declared with an*\n * > *explicit type annotation.*\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertGuard(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertGuard} function.\n *\n * Note that, you've to declare the variable type of the factory function caller\n * like below. If you don't declare the variable type, compilation error be thrown.\n * This is the special rule of the TypeScript compiler.\n *\n * ```typescript\n * // MUST DECLARE THE VARIABLE TYPE\n * const func: typia.AssertionGuard<number> = typia.createAssertGuard<number>();\n *\n * // IF NOT, COMPILATION ERROR BE OCCURED\n * const func = typia.createAssertGuard<number>();\n * ```\n *\n * > *Assertions require every name in the call target to be declared with an*\n * > *explicit type annotation.*\n *\n * @returns Nothing until you configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertGuard<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => AssertionGuard<T>;\n\n/**\n * @internal\n */\nfunction createAssertGuard<T>(): (input: unknown) => AssertionGuard<T> {\n  halt(\"createAssertGuard\");\n}\nconst createAssertGuardPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertGuard,\n  {}\n>(createAssertGuard, assertGuardPure);\nexport { createAssertGuardPure as createAssertGuard };\n\n/**\n * Creates a reusable {@link is} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIs(): never;\n\n/**\n * Creates a reusable {@link is} function.\n *\n * @template T Type of the input value\n * @returns A reusable `is` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIs<T>(): (input: unknown) => input is T;\n\n/**\n * @internal\n */\nfunction createIs<T>(): (input: unknown) => input is T {\n  halt(\"createIs\");\n}\nconst createIsPure = /** @__PURE__ */ Object.assign<typeof createIs, {}>(\n  createIs,\n  isPure,\n);\nexport { createIsPure as createIs };\n\n/**\n * Creates a reusable {@link validate} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidate(): never;\n\n/**\n * Creates a reusable {@link validate} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validate` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidate<T>(): (input: unknown) => IValidation<T>;\n\n/**\n * @internal\n */\nfunction createValidate(): (input: unknown) => IValidation {\n  halt(\"createValidate\");\n}\nconst createValidatePure = /** @__PURE__ */ Object.assign<\n  typeof createValidate,\n  {}\n>(createValidate, validatePure);\nexport { createValidatePure as createValidate };\n\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEquals(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEquals<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => T;\n\n/**\n * @internal\n */\nfunction createAssertEquals<T>(): (input: unknown) => T {\n  halt(\"createAssertEquals\");\n}\nconst createAssertEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertEquals,\n  {}\n>(createAssertEquals, assertEqualsPure);\nexport { createAssertEqualsPure as createAssertEquals };\n\n/**\n * Creates a reusable {@link assertGuardEquals} function.\n *\n * Note that, you've to declare the variable type of the factory function caller\n * like below. If you don't declare the variable type, compilation error be thrown.\n * This is the special rule of the TypeScript compiler.\n *\n * ```typescript\n * // MUST DECLARE THE VARIABLE TYPE\n * const func: typia.AssertionGuard<number> = typia.createAssertGuardEquals<number>();\n *\n * // IF NOT, COMPILATION ERROR BE OCCURED\n * const func = typia.createAssertGuardEquals<number>();\n * ```\n *\n * > *Assertions require every name in the call target to be declared with an*\n * > *explicit type annotation.*\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertGuardEquals(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertGuardEquals} function.\n *\n * Note that, you've to declare the variable type of the factory function caller\n * like below. If you don't declare the variable type, compilation error be thrown.\n * This is the special rule of the TypeScript compiler.\n *\n * ```typescript\n * // MUST DECLARE THE VARIABLE TYPE\n * const func: typia.AssertionGuard<number> = typia.createAssertGuardEquals<number>();\n *\n * // IF NOT, COMPILATION ERROR BE OCCURED\n * const func = typia.createAssertGuardEquals<number>();\n * ```\n *\n * > *Assertions require every name in the call target to be declared with an*\n * > *explicit type annotation.*\n *\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertGuardEquals<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => AssertionGuard<T>;\n\n/**\n * @internal\n */\nfunction createAssertGuardEquals<T>(): (input: unknown) => AssertionGuard<T> {\n  halt(\"createAssertGuardEquals\");\n}\nconst createAssertGuardEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertGuardEquals,\n  {}\n>(createAssertGuardEquals, assertGuardEqualsPure);\nexport { createAssertGuardEqualsPure as createAssertGuardEquals };\n\n/**\n * Creates a reusable {@link equals} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEquals(): never;\n\n/**\n * Creates a reusable {@link equals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `equals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEquals<T>(): (input: unknown) => input is T;\n\n/**\n * @internal\n */\nfunction createEquals<T>(): (input: unknown) => input is T {\n  halt(\"createEquals\");\n}\nconst createEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof createEquals,\n  {}\n>(createEquals, equalsPure);\nexport { createEqualsPure as createEquals };\n\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEquals(): never;\n\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEquals<T>(): (input: unknown) => IValidation<T>;\n\n/**\n * @internal\n */\nfunction createValidateEquals(): (input: unknown) => IValidation {\n  halt(\"createValidateEquals\");\n}\nconst createValidateEqualsPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateEquals,\n  {}\n>(createValidateEquals, validateEqualsPure);\nexport { createValidateEqualsPure as createValidateEquals };\n\n/**\n * Creates a reusable {@link random} function.\n *\n * @danger You must configure the generic argument `T`\n * @param generator Random data generator\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createRandom(generator?: Partial<IRandomGenerator>): never;\n\n/**\n * Creates a resuable {@link random} function.\n *\n * @template T Type of the input value\n * @param generator Random data generator\n * @returns A reusable `random` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createRandom<T>(\n  generator?: Partial<IRandomGenerator>,\n): () => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createRandom(): never {\n  halt(\"createRandom\");\n}\nconst createRandomPure = /** @__PURE__ */ Object.assign<\n  typeof createRandom,\n  {}\n>(createRandom, randomPure);\nexport { createRandomPure as createRandom };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}