{"version":3,"sources":["../src/programmers/helpers/FunctionImporter.ts"],"names":["ts","FunctionImporter","used_","local_","unions_","sequence_","method","Set","Map","empty","size","use","name","add","factory","createIdentifier","useLocal","hasLocal","has","declare","modulo","includeUnions","map","StatementFactory","constant","IdentifierFactory","access","createParenthesizedExpression","createAsExpression","TypeFactory","keyword","values","key","arrow","declareUnions","increment","emplaceUnion","prefix","oldbie","get","index","accessor","tuple","set","trace","console","log"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;AAMR,IAAMC,mBAAN,MAAMA;EANb,OAMaA;;;;EACMC;EACAC;EACAC;EACTC;EAER,YAAmCC,QAAgB;SAAhBA,SAAAA;SALlBJ,QAAqB,oBAAIK,IAAAA;SACzBJ,SAAsB,oBAAII,IAAAA;SAC1BH,UAAmD,oBAAII,IAAAA;SAChEH,YAAoB;EAEwB;EAE7CI,QAAiB;AACtB,WAAO,KAAKP,MAAMQ,SAAS;EAC7B;EAEOC,IAAIC,MAA6B;AACtC,SAAKV,MAAMW,IAAID,IAAAA;AACf,WAAOZ,GAAGc,QAAQC,iBAAiB,MAAMH,IAAAA;EAC3C;EAEOI,SAASJ,MAAsB;AACpC,SAAKT,OAAOU,IAAID,IAAAA;AAChB,WAAOA;EACT;EAEOK,SAASL,MAAuB;AACrC,WAAO,KAAKT,OAAOe,IAAIN,IAAAA;EACzB;EAEAO,QACEC,QACAC,gBAAyB,MACT;AAChB,WAAO;SACF;WAAI,KAAKnB;QAAOoB,IAAI,CAACV,SACtBW,iBAAiBC,SACf,MAAMZ,MACNa,kBAAkBC,OAChB1B,GAAGc,QAAQa,8BACT3B,GAAGc,QAAQc,mBAAmBR,QAAQS,YAAYC,QAAQ,KAAA,CAAA,CAAA,CAAA,EAE5DlB,IAAAA,CAAAA,CAAAA;SAGFS,kBAAkB,OAClB;WAAI,KAAKjB,QAAQ2B,OAAM;QAAIT,IAAI,CAAC,CAACU,KAAKC,KAAAA,MACpCV,iBAAiBC,SAASQ,KAAKC,KAAAA,CAAAA,IAEjC,CAAA;;EAER;EAEOC,gBAAgC;AACrC,WAAO;SAAI,KAAK9B,QAAQ2B,OAAM;MAAIT,IAAI,CAAC,CAACU,KAAKC,KAAAA,MAC3CV,iBAAiBC,SAASQ,KAAKC,KAAAA,CAAAA;EAEnC;EAEOE,YAAoB;AACzB,WAAO,EAAE,KAAK9B;EAChB;EAEO+B,aACLC,QACAzB,MACAE,SACQ;AACR,UAAMwB,SAAS,KAAKlC,QAAQmC,IAAI3B,IAAAA;AAChC,QAAI0B,OAAQ,QAAOA,OAAO,CAAA;AAE1B,UAAME,QAAgB,KAAKpC,QAAQM;AACnC,UAAM+B,WAAmB,GAAGJ,MAAAA,IAAUG,KAAAA;AAEtC,UAAME,QAA8C;MAACD;MAAU;;AAC/D,SAAKrC,QAAQuC,IAAI/B,MAAM8B,KAAAA;AACvBA,UAAM,CAAA,IAAK5B,QAAAA;AACX,WAAO2B;EACT;EAEOG,QAAc;AACnBC,YAAQC,IAAG,GAAI,KAAK5C,KAAK;AACzB2C,YAAQC,IAAG,GAAI,KAAK3C,MAAM;EAC5B;AACF","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nexport class FunctionImporter {\n  private readonly used_: Set<string> = new Set();\n  private readonly local_: Set<string> = new Set();\n  private readonly unions_: Map<string, [string, ts.ArrowFunction]> = new Map();\n  private sequence_: number = 0;\n\n  public constructor(public readonly method: string) {}\n\n  public empty(): boolean {\n    return this.used_.size === 0;\n  }\n\n  public use(name: string): ts.Identifier {\n    this.used_.add(name);\n    return ts.factory.createIdentifier(\"$\" + name);\n  }\n\n  public useLocal(name: string): string {\n    this.local_.add(name);\n    return name;\n  }\n\n  public hasLocal(name: string): boolean {\n    return this.local_.has(name);\n  }\n\n  public declare(\n    modulo: ts.LeftHandSideExpression,\n    includeUnions: boolean = true,\n  ): ts.Statement[] {\n    return [\n      ...[...this.used_].map((name) =>\n        StatementFactory.constant(\n          \"$\" + name,\n          IdentifierFactory.access(\n            ts.factory.createParenthesizedExpression(\n              ts.factory.createAsExpression(modulo, TypeFactory.keyword(\"any\")),\n            ),\n          )(name),\n        ),\n      ),\n      ...(includeUnions === true\n        ? [...this.unions_.values()].map(([key, arrow]) =>\n            StatementFactory.constant(key, arrow),\n          )\n        : []),\n    ];\n  }\n\n  public declareUnions(): ts.Statement[] {\n    return [...this.unions_.values()].map(([key, arrow]) =>\n      StatementFactory.constant(key, arrow),\n    );\n  }\n\n  public increment(): number {\n    return ++this.sequence_;\n  }\n\n  public emplaceUnion(\n    prefix: string,\n    name: string,\n    factory: () => ts.ArrowFunction,\n  ): string {\n    const oldbie = this.unions_.get(name);\n    if (oldbie) return oldbie[0];\n\n    const index: number = this.unions_.size;\n    const accessor: string = `${prefix}p${index}`;\n\n    const tuple: [string, ReturnType<typeof factory>] = [accessor, null!];\n    this.unions_.set(name, tuple);\n    tuple[1] = factory();\n    return accessor;\n  }\n\n  public trace(): void {\n    console.log(...this.used_);\n    console.log(...this.local_);\n  }\n}\n"]}