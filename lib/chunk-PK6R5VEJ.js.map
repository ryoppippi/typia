{"version":3,"sources":["../src/factories/TypeFactory.ts"],"names":["ts","TypeFactory","isFunction","type","getFunction","node","symbol","declarations","undefined","isFunctionLike","isPropertyAssignment","isPropertyDeclaration","initializer","getReturnType","checker","name","getProperty","valueDeclaration","functor","getTypeOfSymbolAtLocation","signature","getSignaturesOfType","SignatureKind","Call","getFullName","aliasSymbol","getSymbol","typeToString","isUnionOrIntersection","joiner","isIntersection","types","map","child","join","get_name","generic","aliasTypeArguments","getTypeArguments","length","explore_name","decl","isModuleBlock","parent","getFullText","trim","getDeclarations","escapedName","toString","keyword","factory","createKeywordTypeNode","SyntaxKind","VoidKeyword","AnyKeyword","UnknownKeyword","BooleanKeyword","NumberKeyword","BigIntKeyword","StringKeyword"],"mappings":";;;;;AAAA,OAAOA,QAAQ;;UAEEC,cAAAA;eACFC,aAAa,CAACC,SACzBC,YAAYD,IAAAA,MAAU;AAExB,QAAMC,cAAc,wBAACD,SAAAA;AACnB,UAAME,OAAOF,KAAKG,QAAQC,eAAe,CAAA;AACzC,QAAIF,SAASG,OAAW,QAAO;AAE/B,WAAOR,GAAGS,eAAeJ,IAAAA,IACrBA,OACAL,GAAGU,qBAAqBL,IAAAA,KAASL,GAAGW,sBAAsBN,IAAAA,IACxDL,GAAGS,eAAeJ,KAAKO,WAAW,IAChCP,KAAKO,cACL,OACF;EACR,GAXoB;eAaPC,gBACX,CAACC,YACD,CAACX,SACD,CAACY,SAAAA;AAEC,UAAMT,SAAgCH,KAAKa,YAAYD,IAAAA;AACvD,QAAI,CAACT,OAAQ,QAAO;aACX,CAACA,OAAOW,iBAAkB,QAAO;AAG1C,UAAMC,UAAmBJ,QAAQK,0BAC/Bb,QACAA,OAAOW,gBAAgB;AAIzB,UAAMG,YAAsCN,QAAQO,oBAClDH,SACAlB,GAAGsB,cAAcC,IAAI,EACrB,CAAA;AACF,WAAOH,YAAYA,UAAUP,cAAa,IAAK;EACjD;eAEWW,cACX,CAACV,YACD,CAACX,MAAeG,WAAAA;AAEdA,eAAWH,KAAKsB,eAAetB,KAAKuB,UAAS;AAC7C,QAAIpB,WAAWE,OAAW,QAAOM,QAAQa,aAAaxB,IAAAA;AAGtD,QAAIA,KAAKsB,gBAAgBjB,UAAaL,KAAKyB,sBAAqB,GAAI;AAClE,YAAMC,SAAiB1B,KAAK2B,eAAc,IAAK,QAAQ;AACvD,aAAO3B,KAAK4B,MACTC,IAAI,CAACC,UAAUT,aAAAA,YAAYV,OAAAA,EAASmB,KAAAA,CAAAA,EACpCC,KAAKL,MAAAA;IACV;AAKA,UAAMd,OAAeoB,SAAS7B,MAAAA;AAG9B,UAAM8B,UAA8BjC,KAAKsB,cACrCtB,KAAKkC,sBAAsB,CAAA,IAC3BvB,QAAQwB,iBAAiBnC,IAAAA;AAC7B,WAAOiC,QAAQG,SACXxB,SAAS,YACPS,aAAAA,YAAYV,OAAAA,EAASsB,QAAQ,CAAA,CAAE,IAC/B,GAAGrB,IAAAA,IAAQqB,QACRJ,IAAI,CAACC,UAAUT,aAAAA,YAAYV,OAAAA,EAASmB,KAAAA,CAAAA,EACpCC,KAAK,IAAA,CAAA,MACVnB;EACN;AAEF,QAAMyB,eACJ,wBAACC,SACD,CAAC1B,SACCf,GAAG0C,cAAcD,IAAAA,IACbD,aAAaC,KAAKE,OAAOA,MAAM,EAC7B,GAAGF,KAAKE,OAAO5B,KAAK6B,YAAW,EAAGC,KAAI,CAAA,IAAM9B,IAAAA,EAAM,IAEpDA,MANN;AAQF,QAAMoB,WAAW,wBAAC7B,WAAAA;AAChB,UAAMqC,SAASrC,OAAOwC,gBAAe,IAAK,CAAA,GAAIH;AAC9C,WAAOA,SACHH,aAAaG,MAAAA,EAAQrC,OAAOyC,YAAYC,SAAQ,CAAA,IAChD;EACN,GALiB;eAOJC,UAAU,CACrB9C,SAAAA;AASA,WAAOH,GAAGkD,QAAQC,sBAChBhD,SAAS,SACLH,GAAGoD,WAAWC,cACdlD,SAAS,QACPH,GAAGoD,WAAWE,aACdnD,SAAS,YACPH,GAAGoD,WAAWG,iBACdpD,SAAS,YACPH,GAAGoD,WAAWI,iBACdrD,SAAS,WACPH,GAAGoD,WAAWK,gBACdtD,SAAS,WACPH,GAAGoD,WAAWM,gBACd1D,GAAGoD,WAAWO,aAAa;EAE7C;AACF,GAnHiB1D,gBAAAA,cAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nexport namespace TypeFactory {\n  export const isFunction = (type: ts.Type): boolean =>\n    getFunction(type) !== null;\n\n  const getFunction = (type: ts.Type) => {\n    const node = type.symbol?.declarations?.[0];\n    if (node === undefined) return null;\n\n    return ts.isFunctionLike(node)\n      ? node\n      : ts.isPropertyAssignment(node) || ts.isPropertyDeclaration(node)\n        ? ts.isFunctionLike(node.initializer)\n          ? node.initializer\n          : null\n        : null;\n  };\n\n  export const getReturnType =\n    (checker: ts.TypeChecker) =>\n    (type: ts.Type) =>\n    (name: string): ts.Type | null => {\n      // FIND TO-JSON METHOD\n      const symbol: ts.Symbol | undefined = type.getProperty(name);\n      if (!symbol) return null;\n      else if (!symbol.valueDeclaration) return null;\n\n      // GET FUNCTION DECLARATION\n      const functor: ts.Type = checker.getTypeOfSymbolAtLocation(\n        symbol,\n        symbol.valueDeclaration,\n      );\n\n      // RETURNS THE RETURN-TYPE\n      const signature: ts.Signature | undefined = checker.getSignaturesOfType(\n        functor,\n        ts.SignatureKind.Call,\n      )[0];\n      return signature ? signature.getReturnType() : null;\n    };\n\n  export const getFullName =\n    (checker: ts.TypeChecker) =>\n    (type: ts.Type, symbol?: ts.Symbol): string => {\n      // PRIMITIVE\n      symbol ??= type.aliasSymbol ?? type.getSymbol();\n      if (symbol === undefined) return checker.typeToString(type);\n\n      // UNION OR INTERSECT\n      if (type.aliasSymbol === undefined && type.isUnionOrIntersection()) {\n        const joiner: string = type.isIntersection() ? \" & \" : \" | \";\n        return type.types\n          .map((child) => getFullName(checker)(child))\n          .join(joiner);\n      }\n\n      //----\n      // SPECIALIZATION\n      //----\n      const name: string = get_name(symbol);\n\n      // CHECK GENERIC\n      const generic: readonly ts.Type[] = type.aliasSymbol\n        ? type.aliasTypeArguments || []\n        : checker.getTypeArguments(type as ts.TypeReference);\n      return generic.length\n        ? name === \"Promise\"\n          ? getFullName(checker)(generic[0]!)\n          : `${name}<${generic\n              .map((child) => getFullName(checker)(child))\n              .join(\", \")}>`\n        : name;\n    };\n\n  const explore_name =\n    (decl: ts.Node) =>\n    (name: string): string =>\n      ts.isModuleBlock(decl)\n        ? explore_name(decl.parent.parent)(\n            `${decl.parent.name.getFullText().trim()}.${name}`,\n          )\n        : name;\n\n  const get_name = (symbol: ts.Symbol): string => {\n    const parent = symbol.getDeclarations()?.[0]?.parent;\n    return parent\n      ? explore_name(parent)(symbol.escapedName.toString())\n      : \"__type\";\n  };\n\n  export const keyword = (\n    type:\n      | \"void\"\n      | \"any\"\n      | \"unknown\"\n      | \"boolean\"\n      | \"number\"\n      | \"bigint\"\n      | \"string\",\n  ) => {\n    return ts.factory.createKeywordTypeNode(\n      type === \"void\"\n        ? ts.SyntaxKind.VoidKeyword\n        : type === \"any\"\n          ? ts.SyntaxKind.AnyKeyword\n          : type === \"unknown\"\n            ? ts.SyntaxKind.UnknownKeyword\n            : type === \"boolean\"\n              ? ts.SyntaxKind.BooleanKeyword\n              : type === \"number\"\n                ? ts.SyntaxKind.NumberKeyword\n                : type === \"bigint\"\n                  ? ts.SyntaxKind.BigIntKeyword\n                  : ts.SyntaxKind.StringKeyword,\n    );\n  };\n}\n"]}