{"version":3,"sources":["../src/programmers/internal/check_dynamic_key.ts"],"names":["ts","check_dynamic_key","project","importer","input","metadata","atomics","length","some","a","type","tags","filter","row","every","t","validate","undefined","natives","factory","createTrue","conditions","nullable","push","createStrictEquality","createStringLiteral","isRequired","atom","createLogicalOr","createLogicalAnd","createCallExpression","use","atomist","check_bigint","createIdentifier","check_number","check_string","constant","constants","value","values","String","templates","check_template","native","createFalse","reduce","entry","expression","map","set","s","b","x","y"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { ICheckEntry } from \"../helpers/ICheckEntry\";\nimport { check_bigint } from \"./check_bigint\";\nimport { check_number } from \"./check_number\";\nimport { check_string } from \"./check_string\";\nimport { check_template } from \"./check_template\";\n\nexport const check_dynamic_key =\n  (project: IProject) =>\n  (importer: FunctionImporter) =>\n  (input: ts.Expression, metadata: Metadata): ts.Expression => {\n    // IF PURE STRING EXISTS, THEN SKIP VALIDATION\n    if (\n      (metadata.atomics.length !== 0 &&\n        metadata.atomics.some(\n          (a) =>\n            a.type === \"string\" &&\n            a.tags.filter((row) => row.every((t) => t.validate !== undefined))\n              .length === 0,\n        )) ||\n      (metadata.natives.length !== 0 &&\n        metadata.natives.some((type) => type === \"String\"))\n    )\n      return ts.factory.createTrue();\n\n    const conditions: ts.Expression[] = [];\n\n    // NULLISH COALESCING\n    if (metadata.nullable === true)\n      conditions.push(\n        ts.factory.createStrictEquality(\n          ts.factory.createStringLiteral(\"null\"),\n          input,\n        ),\n      );\n    if (metadata.isRequired() === false)\n      conditions.push(\n        ts.factory.createStrictEquality(\n          ts.factory.createStringLiteral(\"undefined\"),\n          input,\n        ),\n      );\n\n    // ATOMICS\n    for (const atom of metadata.atomics)\n      if (atom.type === \"boolean\")\n        conditions.push(\n          ts.factory.createLogicalOr(\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"false\"),\n              input,\n            ),\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"true\"),\n              input,\n            ),\n          ),\n        );\n      else if (atom.type === \"bigint\")\n        conditions.push(\n          ts.factory.createLogicalAnd(\n            ts.factory.createCallExpression(\n              importer.use(\"is_bigint_string\"),\n              undefined,\n              [input],\n            ),\n            atomist(\n              check_bigint(project)(atom)(\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"BigInt\"),\n                  undefined,\n                  [input],\n                ),\n              ),\n            ),\n          ),\n        );\n      else if (atom.type === \"number\")\n        conditions.push(\n          atomist(\n            check_number(project, true)(atom)(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"Number\"),\n                undefined,\n                [input],\n              ),\n            ),\n          ),\n        );\n      else conditions.push(atomist(check_string(project)(atom)(input)));\n\n    // CONSTANTS\n    for (const constant of metadata.constants)\n      for (const { value } of constant.values)\n        conditions.push(\n          ts.factory.createStrictEquality(\n            ts.factory.createStringLiteral(String(value)),\n            input,\n          ),\n        );\n\n    // TEMPLATES\n    if (!!metadata.templates.length)\n      conditions.push(atomist(check_template(metadata.templates)(input)));\n\n    // NATIVES\n    for (const native of metadata.natives)\n      if (native === \"Boolean\")\n        conditions.push(\n          ts.factory.createLogicalOr(\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"false\"),\n              input,\n            ),\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"true\"),\n              input,\n            ),\n          ),\n        );\n      else if (native === \"BigInt\")\n        conditions.push(\n          ts.factory.createCallExpression(\n            importer.use(\"is_bigint_string\"),\n            undefined,\n            [input],\n          ),\n        );\n      else if (native === \"Number\")\n        conditions.push(\n          ts.factory.createStrictEquality(\n            ts.factory.createFalse(),\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"Number.isNaN\"),\n              undefined,\n              [\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"Number\"),\n                  undefined,\n                  [input],\n                ),\n              ],\n            ),\n          ),\n        );\n\n    return conditions.length === 0\n      ? ts.factory.createTrue()\n      : conditions.length === 1\n        ? conditions[0]!\n        : conditions.reduce(ts.factory.createLogicalOr);\n  };\n\nconst atomist = (entry: ICheckEntry) =>\n  [\n    ...(entry.expression ? [entry.expression] : []),\n    ...(entry.conditions.length === 0\n      ? []\n      : [\n          entry.conditions\n            .map((set) =>\n              set\n                .map((s) => s.expression)\n                .reduce((a, b) => ts.factory.createLogicalAnd(a, b)),\n            )\n            .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n        ]),\n  ].reduce((x, y) => ts.factory.createLogicalAnd(x, y));\n"]}