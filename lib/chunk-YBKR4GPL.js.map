{"version":3,"sources":["../src/functional.ts"],"names":["functional_exports","assertFunction","halt","assertFunctionPure","Object","assign","Namespace","assert","functional","functionalAssert","assertParametersPure","assertReturn","assertReturnPure","assertEqualsFunction","assertEqualsFunctionPure","assertEqualsParameters","assertEqualsParametersPure","assertEqualsReturn","assertEqualsReturnPure","isFunction","isFunctionPure","is","isParameters","isParametersPure","isReturn","isReturnPure","equalsFunction","equalsFunctionPure","equalsParameters","equalsParametersPure","equalsReturn","equalsReturnPure","validateFunction","validateFunctionPure","validate","validateParameters","validateParametersPure","validateReturn","validateReturnPure","validateEqualsFunction","validateEqualsFunctionPure","validateEqualsParameters","validateEqualsParametersPure","validateEqualsReturn","validateEqualsReturnPure","name","Error"],"mappings":"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","sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { IValidation } from \"./IValidation\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n  FUNCTIONAL\n    - ASSERT\n    - IS\n    - VALIDATE\n==============================================================\n  ASSERT\n----------------------------------------------------------- */\n/**\n * Asserts a function.\n *\n * Asserts a function, by wrapping the function and checking its parameters and\n * return value through {@link assert} function. If some parameter or return value\n * does not match the expected type, it throws an {@link TypeGuardError} or a custom\n * error generated by the *errorFactory* parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assert} function. If the {@link TypeGuardError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`. Otherwise\n * the path would start from `$input.return`.\n *\n * - `$input.parameters[0].~`\n * - `$input.return.~`\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use {@link validateFunction}\n * instead. Otherwise, what you want is just asserting parameters or return value\n * only, you can use {@link assertParameters} or {@link assertReturn} instead.\n *\n * On the other hand, if don't want to allow any superfluous properties, utilize\n * {@link assertEqualsFunction} or {@link validateEqualsFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertFunction<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertFunction(): never {\n  halt(\"assertFunction\");\n}\nconst assertFunctionPure = /** @__PURE__ */ Object.assign<\n  typeof assertFunction,\n  {},\n  {}\n>(\n  assertFunction,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertFunction\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertFunctionPure as assertFunction };\n\n/**\n * Asserts parameters.\n *\n * Asserts a function, by wrapping the function and checking its parameters through\n * {@link assert} function. If some parameter does not match the expected type, it\n * throws an {@link TypeGuardError} or a custom error generated by the *errorFactory*\n * parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assert} function. If the {@link TypeGuardError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`.\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use {@link validateParameters}\n * instead. Otherwise, what you want is not only asserting parameters, but also\n * asserting return value, you can use {@link assertFunction} instead.\n *\n * On the other hand, if don't want to allow any superfluous properties, utilize\n * {@link assertEqualsParameters} or {@link validateEqualsParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertParameters<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertParameters(): never {\n  halt(\"assertParameters\");\n}\nconst assertParametersPure = /** @__PURE__ */ Object.assign<\n  typeof assertParameters,\n  {},\n  {}\n>(\n  assertFunction,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertFunction\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertParametersPure as assertParameters };\n\n/**\n * Asserts return value.\n *\n * Asserts a function, by wrapping the function and checking its return value through\n * {@link assert} function. If the return value does not match the expected type, it\n * throws an {@link TypeGuardError} or a custom error generated by the *errorFactory*\n * parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assert} function. If the {@link TypeGuardError} occurs from\n * the return value, the path would start from `$input.return`.\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use {@link validateReturn}\n * instead. Otherwise, what you want is not only asserting return value, but also\n * asserting parameters, you can use {@link assertFunction} instead.\n *\n * On the other hand, if don't want to allow any superfluous properties, utilize\n * {@link assertEqualsReturn} or {@link validateEqualsReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertReturn<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertReturn(): never {\n  halt(\"assertReturn\");\n}\nconst assertReturnPure = /** @__PURE__ */ Object.assign<\n  typeof assertReturn,\n  {},\n  {}\n>(\n  assertReturn,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertReturn\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertReturnPure as assertReturn };\n\n/**\n * Asserts a function with strict equality.\n *\n * Asserts a function with strict equality, by wrapping the function and checking\n * its parameters and return value through {@link assertEquals} function. If some\n * parameter or return value does not match the expected type, it throws an\n * {@link TypeGuardError} or a custom error generated by the *errorFactory* parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assertEquals} function. If the {@link TypeGuardError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`. Otherwise\n * the path would start from `$input.return`.\n *\n * - `$input.parameters[0].~`\n * - `$input.return.~`\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use\n * {@link validateEqualsFunction} instead. Otherwise, what you want is just asserting\n * parameters or return value only, you can use {@link assertEqualsParameters} or\n * {@link assertEqualsReturn} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link assertFunction} or {@link validateFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEqualsFunction<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertEqualsFunction(): never {\n  halt(\"assertEqualsFunction\");\n}\nconst assertEqualsFunctionPure = /** @__PURE__ */ Object.assign<\n  typeof assertEqualsFunction,\n  {},\n  {}\n>(\n  assertEqualsFunction,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertEqualsFunction\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertEqualsFunctionPure as assertEqualsFunction };\n\n/**\n * Asserts parameters with strict equality.\n *\n * Asserts a function, by wrapping the function and checking its parameters through\n * {@link assertEquals} function. If some parameter does not match the expected type,\n * it throws an {@link TypeGuardError} or a custom error generated by the *errorFactory*\n * parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assertEquals} function. If the {@link TypeGuardError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`.\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use\n * {@link validateEqualsParameters} instead. Otherwise, what you want is not only\n * asserting parameters, but also asserting return value, you can use\n * {@link assertEqualsFunction} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link assertParameters} or {@link validateParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEqualsParameters<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertEqualsParameters(): never {\n  halt(\"assertEqualsParameters\");\n}\nconst assertEqualsParametersPure = /** @__PURE__ */ Object.assign<\n  typeof assertEqualsParameters,\n  {},\n  {}\n>(\n  assertEqualsParameters,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertEqualsParameters\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertEqualsParametersPure as assertEqualsParameters };\n\n/**\n * Asserts return value with strict equality.\n *\n * Asserts a function, by wrapping the function and checking its return value through\n * {@link assertEquals} function. If the return value does not match the expected type,\n * it throws an {@link TypeGuardError} or a custom error generated by the *errorFactory*\n * parameter.\n *\n * For reference, {@link TypeGuardError.path} would be a little bit different with\n * individual {@link assertEquals} function. If the {@link TypeGuardError} occurs from\n * the return value, the path would start from `$input.return`.\n *\n * By the way, if what you want is not just finding the 1st type error through\n * assertion, but also finding every type errors, then use {@link validateEqualsReturn}\n * instead. Otherwise, what you want is not only asserting return value, but also\n * asserting parameters, you can use {@link assertEqualsFunction} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link assertReturn} or {@link validateReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to assert\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns The wrapper function with type assertions\n * @throws A {@link TypeGuardError} or a custom error generated by *errorFactory*\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEqualsReturn<T extends (...args: any[]) => any>(\n  func: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertEqualsReturn(): never {\n  halt(\"assertEqualsReturn\");\n}\nconst assertEqualsReturnPure = /** @__PURE__ */ Object.assign<\n  typeof assertEqualsReturn,\n  {},\n  {}\n>(\n  assertEqualsReturn,\n  /** @__PURE__ */ Namespace.assert(\"functional.assertEqualsReturn\"),\n  /** @__PURE__ */ Namespace.functional.functionalAssert(),\n);\nexport { assertEqualsReturnPure as assertEqualsReturn };\n\n/* -----------------------------------------------------------\n  IS\n----------------------------------------------------------- */\n/**\n * Tests a function.\n *\n * Tests a function, by wrapping the function and checking its parameters and\n * return value through {@link is} function. If some parameter or return value\n * does not match the expected type, it returns `null`. Otherwise there's no\n * type error, it returns the result of the function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertFunction} or\n * {@link validateFunction} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties,\n * utilize {@link equalsFunction}, {@link assertEqualsFunction} or\n * {@link validateEqualsFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isFunction<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction isFunction(): never {\n  halt(\"isFunction\");\n}\nconst isFunctionPure = /** @__PURE__ */ Object.assign<typeof isFunction, {}>(\n  isFunction,\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isFunctionPure as isFunction };\n\n/**\n * Tests parameters.\n *\n * Tests a function, by wrapping the function and checking its parameters through\n * {@link is} function. If some parameter does not match the expected type, it\n * returns `null`. Otherwise there's no type error, it returns the result of the\n * function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertParameters} or\n * {@link validateParameters} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties,\n * utilize {@link equalsParameters}, {@link assertEqualsParameters} or\n * {@link validateEqualsParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isParameters<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction isParameters(): never {\n  halt(\"isParameters\");\n}\nconst isParametersPure = /** @__PURE__ */ Object.assign<\n  typeof isParameters,\n  {}\n>(isParameters, /** @__PURE__ */ Namespace.is());\nexport { isParametersPure as isParameters };\n\n/**\n * Tests return value.\n *\n * Tests a function, by wrapping the function and checking its return value through\n * {@link is} function. If the return value does not match the expected type, it\n * returns `null`. Otherwise there's no type error, it returns the result of the\n * function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertReturn} or\n * {@link validateReturn} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties,\n * utilize {@link equalsReturn}, {@link assertEqualsReturn} or\n * {@link validateEqualsReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isReturn<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction isReturn(): never {\n  halt(\"isReturn\");\n}\nconst isReturnPure = /** @__PURE__ */ Object.assign<typeof isReturn, {}>(\n  isReturn,\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isReturnPure as isReturn };\n\n/**\n * Tests a function with strict equality.\n *\n * Tests a function with strict equality, by wrapping the function and checking its\n * parameters and return value through {@link isEquals} function. If some parameter\n * or return value does not match the expected type, it returns `null`. Otherwise\n * there's no type error, it returns the result of the function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertEqualsFunction} or\n * {@link validateEqualsFunction} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link isFunction}, {@link assertFunction} or {@link validateFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction equalsFunction<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction equalsFunction(): never {\n  halt(\"equalsFunction\");\n}\nconst equalsFunctionPure = /** @__PURE__ */ Object.assign<\n  typeof equalsFunction,\n  {}\n>(equalsFunction, /** @__PURE__ */ Namespace.is());\nexport { equalsFunctionPure as equalsFunction };\n\n/**\n * Tests parameters with strict equality.\n *\n * Tests a function, by wrapping the function and checking its parameters through\n * {@link isEquals} function. If some parameter does not match the expected type,\n * it returns `null`. Otherwise there's no type error, it returns the result of the\n * function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertEqualsParameters} or\n * {@link validateEqualsParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction equalsParameters<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction equalsParameters(): never {\n  halt(\"equalsParameters\");\n}\nconst equalsParametersPure = /** @__PURE__ */ Object.assign<\n  typeof equalsParameters,\n  {}\n>(equalsParameters, /** @__PURE__ */ Namespace.is());\nexport { equalsParametersPure as equalsParameters };\n\n/**\n * Tests return value with strict equality.\n *\n * Tests a function, by wrapping the function and checking its return value through\n * {@link isEquals} function. If the return value does not match the expected type,\n * it returns `null`. Otherwise there's no type error, it returns the result of the\n * function.\n *\n * By the way, if you want is not just testing type checking, but also finding\n * detailed type error reason(s), then use {@link assertEqualsReturn} or\n * {@link validateEqualsReturn} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link isReturn}, {@link assertReturn} or {@link validateReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to test\n * @returns The wrapper function with type tests\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction equalsReturn<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<R | null>\n    : (...args: Arguments) => Output | null\n  : never;\n\n/**\n * @internal\n */\nfunction equalsReturn(): never {\n  halt(\"equalsReturn\");\n}\nconst equalsReturnPure = /** @__PURE__ */ Object.assign<\n  typeof equalsReturn,\n  {}\n>(equalsReturn, /** @__PURE__ */ Namespace.is());\nexport { equalsReturnPure as equalsReturn };\n\n/* -----------------------------------------------------------\n  VALIDATE\n----------------------------------------------------------- */\n/**\n * Validates a function.\n *\n * Validates a function, by wrapping the function and checking its parameters and\n * return value through {@link validate} function. If some parameter or return value\n * does not match the expected type, it returns {@link IValidation.IError} typed\n * object. Otherwise there's no type error, it returns {@link IValidation.ISuccess}\n * typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validate} function. If the {@link IValidation.IError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`. Otherwise\n * the path would start from `$input.return`.\n *\n * - `$input.parameters[0].~`\n * - `$input.return.~`\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertFunction} instead. Otherwise, what you\n * want is just validating parameters or return value only, you can use\n * {@link validateParameters} or {@link validateReturn} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties, utilize\n * {@link validateEqualsFunction} or {@link assertEqualsFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateFunction<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateFunction(): never {\n  halt(\"validateFunction\");\n}\nconst validateFunctionPure = /** @__PURE__ */ Object.assign<\n  typeof validateFunction,\n  {}\n>(validateFunction, /** @__PURE__ */ Namespace.validate());\nexport { validateFunctionPure as validateFunction };\n\n/**\n * Validates parameters.\n *\n * Validates a function, by wrapping the function and checking its parameters through\n * {@link validate} function. If some parameter does not match the expected type, it\n * returns {@link IValidation.IError} typed object. Otherwise there's no type error,\n * it returns {@link IValidation.ISuccess} typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validate} function. If the {@link IValidation.IError} occurs from\n * some parameter, the path would start from `$input.parameters[number]`.\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertParameters} instead. Otherwise, what you\n * want is not only validating parameters, but also validating return value, you can\n * use {@link validateFunction} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties, utilize\n * {@link validateEqualsParameters} or {@link assertEqualsParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateParameters<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateParameters(): never {\n  halt(\"validateReturn\");\n}\nconst validateParametersPure = /** @__PURE__ */ Object.assign<\n  typeof validateParameters,\n  {}\n>(validateParameters, /** @__PURE__ */ Namespace.validate());\nexport { validateParametersPure as validateParameters };\n\n/**\n * Validates return value.\n *\n * Validates a function, by wrapping the function and checking its return value through\n * {@link validate} function. If the return value does not match the expected type, it\n * returns {@link IValidation.IError} typed object. Otherwise there's no type error,\n * it returns {@link IValidation.ISuccess} typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validate} function. If the {@link IValidation.IError} occurs from\n * the return value, the path would start from `$input.return`.\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertReturn} instead. Otherwise, what you want\n * is not only validating return value, but also validating parameters, you can use\n * {@link validateFunction} instead.\n *\n * On the other hand, if you don't want to allow any superfluous properties, utilize\n * {@link validateEqualsReturn} or {@link assertEqualsReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateReturn<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateReturn(): never {\n  halt(\"validateReturn\");\n}\nconst validateReturnPure = /** @__PURE__ */ Object.assign<\n  typeof validateReturn,\n  {}\n>(validateReturn, /** @__PURE__ */ Namespace.validate());\nexport { validateReturnPure as validateReturn };\n\n/**\n * Validates a function with strict equality.\n *\n * Validates a function with strict equality, by wrapping the function and checking\n * its parameters and return value through {@link validateEquals} function. If some\n * parameter or return value does not match the expected type, it returns\n * {@link IValidation.IError} typed object. Otherwise there's no type error, it\n * returns {@link IValidation.ISuccess} typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validateEquals} function. If the {@link IValidation.IError} occurs\n * from some parameter, the path would start from `$input.parameters[number]`. Otherwise\n * the path would start from `$input.return`.\n *\n * - `$input.parameters[0].~`\n * - `$input.return.~`\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertEqualsFunction} instead. Otherwise, what\n * you want is just validating parameters or return value only, you can use\n * {@link validateEqualsParameters} or {@link validateEqualsReturn} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link validateFunction} or {@link assertFunction} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEqualsFunction<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateEqualsFunction(): never {\n  halt(\"validateEqualsFunction\");\n}\nconst validateEqualsFunctionPure = /** @__PURE__ */ Object.assign<\n  typeof validateEqualsFunction,\n  {}\n>(validateEqualsFunction, /** @__PURE__ */ Namespace.validate());\nexport { validateEqualsFunctionPure as validateEqualsFunction };\n\n/**\n * Validates parameters with strict equality.\n *\n * Validates a function, by wrapping the function and checking its parameters through\n * {@link validateEquals} function. If some parameter does not match the expected type,\n * it returns {@link IValidation.IError} typed object. Otherwise there's no type error,\n * it returns {@link IValidation.ISuccess} typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validateEquals} function. If the {@link IValidation.IError} occurs\n * from some parameter, the path would start from `$input.parameters[number]`.\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertEqualsParameters} instead. Otherwise,\n * what you want is not only validating parameters, but also validating return value,\n * you can use {@link validateEqualsFunction} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link validateParameters} or {@link assertParameters} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEqualsParameters<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateEqualsParameters(): never {\n  halt(\"validateEqualsParameters\");\n}\nconst validateEqualsParametersPure = /** @__PURE__ */ Object.assign<\n  typeof validateEqualsParameters,\n  {}\n>(validateEqualsParameters, /** @__PURE__ */ Namespace.validate());\nexport { validateEqualsParametersPure as validateEqualsParameters };\n\n/**\n * Validates return value with strict equality.\n *\n * Validates a function, by wrapping the function and checking its return value through\n * {@link validateEquals} function. If the return value does not match the expected type,\n * it returns {@link IValidation.IError} typed object. Otherwise there's no type error,\n * it returns {@link IValidation.ISuccess} typed object instead.\n *\n * For reference, {@link IValidation.IError.path} would be a little bit different with\n * individual {@link validateEquals} function. If the {@link IValidation.IError} occurs\n * from the return value, the path would start from `$input.return`.\n *\n * By the way, if what you want is not finding every type errors, but just finding\n * the 1st type error, then use {@link assertEqualsReturn} instead. Otherwise, what you\n * want is not only validating return value, but also validating parameters, you can use\n * {@link validateEqualsFunction} instead.\n *\n * On the other hand, if you want to allow any superfluous properties, utilize\n * {@link validateReturn} or {@link assertReturn} instead.\n *\n * @template T Target function type\n * @param func Target function to validate\n * @returns The wrapper function with type validations\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEqualsReturn<T extends (...args: any[]) => any>(\n  func: T,\n): T extends (...args: infer Arguments) => infer Output\n  ? Output extends Promise<infer R>\n    ? (...args: Arguments) => Promise<IValidation<R>>\n    : (...args: Arguments) => IValidation<Output>\n  : never;\n\n/**\n * @internal\n */\nfunction validateEqualsReturn(): never {\n  halt(\"validateEqualsReturn\");\n}\nconst validateEqualsReturnPure = /** @__PURE__ */ Object.assign<\n  typeof validateEqualsReturn,\n  {}\n>(validateEqualsReturn, /** @__PURE__ */ Namespace.validate());\nexport { validateEqualsReturnPure as validateEqualsReturn };\n\n/* -----------------------------------------------------------\n  HALTER\n----------------------------------------------------------- */\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.functional.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}