{"version":3,"sources":["../src/functional/Namespace/index.ts"],"names":["assert","method","is","join","$join","every","$every","guard","$guard","predicate","matched","exceptionable","closure","TypeGuardError","validate","report","$report","res","success","errorList","errors","error","length","last","path","substring","push","random","generator","RandomGenerator","pick"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAmBO,IAAMA,SAAS,wBAACC,YAAoB;EACzC,GAAGC,GAAAA;EACHC,MAAMC;EACNC,OAAOC;EACPC,OAAOC,OAAO,SAASP,MAAAA,EAAQ;EAC/BQ,WAAW,wBACTC,SACAC,eACAC,YAAAA;AAEA,QAAIF,YAAY,SAASC,kBAAkB,KACzC,OAAM,IAAIE,eAAe;MACvB,GAAGD,QAAAA;MACHX,QAAQ,SAASA,MAAAA;IACnB,CAAA;AACF,WAAOS;EACT,GAXW;AAYb,IAjBsB;AAmBf,IAAMI,WAAW,8BAAO;EAC7B,GAAGZ,GAAAA;EACHC,MAAMC;EACNW,QAAQC;EACRP,WACE,wBAACQ,QACD,CACEP,SACAC,eACAC,YAAAA;AAGA,QAAIF,YAAY,SAASC,kBAAkB,KACxC,EAAA,MAAA;AACCM,UAAIC,YAAY;AAChB,YAAMC,YAAaF,IAA6BG;AAGhD,YAAMC,QAAQT,QAAAA;AACd,UAAIO,UAAUG,QAAQ;AACpB,cAAMC,OAAOJ,UAAUA,UAAUG,SAAS,CAAA,EAAIE;AAC9C,YACED,KAAKD,UAAUD,MAAMG,KAAKF,UAC1BC,KAAKE,UAAU,GAAGJ,MAAMG,KAAKF,MAAM,MAAMD,MAAMG,KAE/C;MACJ;AACAL,gBAAUO,KAAKL,KAAAA;AACf;IACF,GAAA;AACF,WAAOX;EACT,GA1BA;AA2BJ,IAhCwB;AAkCjB,IAAMiB,SAAS,8BAAO;EAC3BC,WAAWC;EACXC,MAAMD,wBAAgBC;AACxB,IAHsB","sourcesContent":["import { RandomGenerator } from \"../../utils/RandomGenerator\";\n\nimport { $every } from \"../$every\";\nimport { $guard } from \"../$guard\";\nimport { $join } from \"../$join\";\nimport { $report } from \"../$report\";\nimport { IValidation } from \"../../IValidation\";\nimport { TypeGuardError } from \"../../TypeGuardError\";\nimport { is } from \"../is\";\n\nexport * as functional from \"./functional\";\nexport * as json from \"./json\";\nexport * as http from \"./http\";\nexport * as notations from \"./notations\";\nexport * as misc from \"./misc\";\nexport * as protobuf from \"./protobuf\";\n\nexport { is };\n\nexport const assert = (method: string) => ({\n  ...is(),\n  join: $join,\n  every: $every,\n  guard: $guard(`typia.${method}`),\n  predicate: (\n    matched: boolean,\n    exceptionable: boolean,\n    closure: () => Omit<TypeGuardError.IProps, \"method\">,\n  ): boolean => {\n    if (matched === false && exceptionable === true)\n      throw new TypeGuardError({\n        ...closure(),\n        method: `typia.${method}`,\n      });\n    return matched;\n  },\n});\n\nexport const validate = () => ({\n  ...is(),\n  join: $join,\n  report: $report,\n  predicate:\n    (res: IValidation) =>\n    (\n      matched: boolean,\n      exceptionable: boolean,\n      closure: () => IValidation.IError,\n    ) => {\n      // CHECK FAILURE\n      if (matched === false && exceptionable === true)\n        (() => {\n          res.success &&= false;\n          const errorList = (res as IValidation.IFailure).errors;\n\n          // TRACE ERROR\n          const error = closure();\n          if (errorList.length) {\n            const last = errorList[errorList.length - 1]!.path;\n            if (\n              last.length >= error.path.length &&\n              last.substring(0, error.path.length) === error.path\n            )\n              return;\n          }\n          errorList.push(error);\n          return;\n        })();\n      return matched;\n    },\n});\n\nexport const random = () => ({\n  generator: RandomGenerator,\n  pick: RandomGenerator.pick,\n});\n"]}