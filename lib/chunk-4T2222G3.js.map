{"version":3,"sources":["../src/programmers/protobuf/ProtobufEncodeProgrammer.ts"],"names":["ts","ProtobufEncodeProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","meta","ProtobufFactory","metadata","checker","context","callEncoder","writer","factory","StatementFactory","constant","createCallExpression","createIdentifier","undefined","block","write_encoder","createNewExpression","use","createReturnStatement","IdentifierFactory","access","WRITER","createArrowFunction","parameter","createTypeReferenceNode","TypeFactory","getFullName","createBlock","declare","functors","objects","filter","obj","ProtobufUtil","isStaticObject","map","PREFIX","index","write_object_function","source","from","tracable","postfix","main","decode","keyword","declareUnions","IsProgrammer","write_function_statements","statements","input","explore","body","properties","p","key","getSoleLiteral","value","size","createExpressionStatement","flat","wrapper","isRequired","nullable","createIfStatement","createLogicalAnd","createStrictInequality","createNull","unions","numbers","getNumbers","bigints","getBigints","atom","getAtomics","push","is","createStrictEquality","createStringLiteral","createTypeOfExpression","decode_bool","decode_number","some","n","decode_bigint","decode_bytes","natives","length","ExpressionFactory","isInstanceOf","arrays","isArray","decode_array","maps","decode_map","isObject","checkNull","checkArray","explore_objects","iterate","getName","expected","u","i","create_throw_error","reverse","reduce","a","b","expression","thenStatement","each","decode_tag","ProtobufWire","LEN","createForOfStatement","entry","decode_object","object","top","isSoleLiteral","MetadataProperty","create","Metadata","initialize","atomics","MetadataAtomic","tags","useLocal","expr","array","wire","get_standalone_wire","forLoop","createVariableDeclarationList","createVariableDeclaration","NodeFlags","Const","number","VARIANT","exp","candidates","NumericRangeFactory","get_numeric_wire","bigint","method","v","I32","I64","level","targets","indexes","get","t","join","specList","UnionPredicator","Map","condition","decode_union_object","o","e","selfCall","remained","find","s","spec","property","accessor","pred","neighbour","createObjectLiteralExpression","createPropertyAssignment"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { NumericRangeFactory } from \"../../factories/NumericRangeFactory\";\nimport { ProtobufFactory } from \"../../factories/ProtobufFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ProtobufAtomic } from \"../../typings/ProtobufAtomic\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { ProtobufUtil } from \"../helpers/ProtobufUtil\";\nimport { ProtobufWire } from \"../helpers/ProtobufWire\";\nimport { UnionPredicator } from \"../helpers/UnionPredicator\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\n\nexport namespace ProtobufEncodeProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      const importer = new FunctionImporter(modulo.getText());\n      const collection = new MetadataCollection();\n      const meta: Metadata = ProtobufFactory.metadata(modulo.getText())(\n        project.checker,\n        project.context,\n      )(collection)(type);\n\n      const callEncoder = (writer: string) => (factory: ts.NewExpression) =>\n        StatementFactory.constant(\n          writer,\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"encoder\"),\n            undefined,\n            [factory],\n          ),\n        );\n\n      const block: ts.Statement[] = [\n        StatementFactory.constant(\n          \"encoder\",\n          write_encoder(project)(importer)(collection)(meta),\n        ),\n        callEncoder(\"sizer\")(\n          ts.factory.createNewExpression(importer.use(\"Sizer\"), undefined, []),\n        ),\n        callEncoder(\"writer\")(\n          ts.factory.createNewExpression(importer.use(\"Writer\"), undefined, [\n            ts.factory.createIdentifier(\"sizer\"),\n          ]),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"buffer\"),\n            undefined,\n            undefined,\n          ),\n        ),\n      ];\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ),\n        ],\n        ts.factory.createTypeReferenceNode(\"Uint8Array\"),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo, false), ...block],\n          true,\n        ),\n      );\n    };\n\n  const write_encoder =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection) =>\n    (meta: Metadata): ts.ArrowFunction => {\n      const functors = collection\n        .objects()\n        .filter((obj) => ProtobufUtil.isStaticObject(obj))\n        .map((obj) =>\n          StatementFactory.constant(\n            `${PREFIX}o${obj.index}`,\n            write_object_function(project)(importer)(\n              ts.factory.createIdentifier(\"input\"),\n              obj,\n              {\n                source: \"function\",\n                from: \"object\",\n                tracable: false,\n                postfix: \"\",\n              },\n            ),\n          ),\n        );\n      const main = decode(project)(importer)(null)(\n        ts.factory.createIdentifier(\"input\"),\n        meta,\n        {\n          source: \"top\",\n          from: \"top\",\n          tracable: false,\n          postfix: \"\",\n        },\n      );\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"writer\")],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...importer.declareUnions(),\n            ...functors,\n            ...IsProgrammer.write_function_statements(project)(importer)(\n              collection,\n            ),\n            ...main.statements,\n            ts.factory.createReturnStatement(\n              ts.factory.createIdentifier(\"writer\"),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const write_object_function =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      obj: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.ArrowFunction => {\n      let index: number = 1;\n      const body: ts.Statement[] = obj.properties\n        .map((p) => {\n          const block = decode(project)(importer)(index)(\n            IdentifierFactory.access(input)(p.key.getSoleLiteral()!),\n            p.value,\n            explore,\n          );\n          index += ProtobufUtil.size(p.value);\n          return [\n            ts.factory.createExpressionStatement(\n              ts.factory.createIdentifier(\n                `// property \"${p.key.getSoleLiteral()!}\"`,\n              ),\n            ),\n            ...block.statements,\n          ];\n        })\n        .flat();\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\")],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(body, true),\n      );\n    };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const wrapper: (block: ts.Block) => ts.Block =\n        meta.isRequired() && meta.nullable === false\n          ? (block) => block\n          : meta.isRequired() === false && meta.nullable === true\n            ? (block) =>\n                ts.factory.createBlock(\n                  [\n                    ts.factory.createIfStatement(\n                      ts.factory.createLogicalAnd(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createIdentifier(\"undefined\"),\n                          input,\n                        ),\n                        ts.factory.createStrictInequality(\n                          ts.factory.createNull(),\n                          input,\n                        ),\n                      ),\n                      block,\n                    ),\n                  ],\n                  true,\n                )\n            : meta.isRequired() === false\n              ? (block) =>\n                  ts.factory.createBlock(\n                    [\n                      ts.factory.createIfStatement(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createIdentifier(\"undefined\"),\n                          input,\n                        ),\n                        block,\n                      ),\n                    ],\n                    true,\n                  )\n              : (block) =>\n                  ts.factory.createBlock(\n                    [\n                      ts.factory.createIfStatement(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createNull(),\n                          input,\n                        ),\n                        block,\n                      ),\n                    ],\n                    true,\n                  );\n\n      // STARTS FROM ATOMIC TYPES\n      const unions: IUnion[] = [];\n      const numbers = ProtobufUtil.getNumbers(meta);\n      const bigints = ProtobufUtil.getBigints(meta);\n\n      for (const atom of ProtobufUtil.getAtomics(meta))\n        if (atom === \"bool\")\n          unions.push({\n            type: \"bool\",\n            is: () =>\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"boolean\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n            value: (index) => decode_bool(index)(input),\n          });\n        else if (\n          atom === \"int32\" ||\n          atom === \"uint32\" ||\n          atom === \"float\" ||\n          atom === \"double\"\n        )\n          unions.push(decode_number(numbers)(atom)(input));\n        else if (atom === \"int64\" || atom === \"uint64\")\n          if (numbers.some((n) => n === atom))\n            unions.push(decode_number(numbers)(atom)(input));\n          else unions.push(decode_bigint(bigints)(atom)(input));\n        else if (atom === \"string\")\n          unions.push({\n            type: \"string\",\n            is: () =>\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"string\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n            value: (index) => decode_bytes(\"string\")(index!)(input),\n          });\n\n      // CONSIDER BYTES\n      if (meta.natives.length)\n        unions.push({\n          type: \"bytes\",\n          is: () => ExpressionFactory.isInstanceOf(\"Uint8Array\")(input),\n          value: (index) => decode_bytes(\"bytes\")(index!)(input),\n        });\n\n      // CONSIDER ARRAYS\n      if (meta.arrays.length)\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value: (index) =>\n            decode_array(project)(importer)(index!)(input, meta.arrays[0]!, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // CONSIDER MAPS\n      if (meta.maps.length)\n        unions.push({\n          type: \"map\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: (index) =>\n            decode_map(project)(importer)(index!)(input, meta.maps[0]!, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // CONSIDER OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: false,\n            })(input),\n          value: (index) =>\n            explore_objects(project)(importer)(0)(index)(input, meta.objects, {\n              ...explore,\n              from: \"object\",\n            }),\n        });\n\n      // RETURNS\n      if (unions.length === 1) return wrapper(unions[0]!.value(index));\n      else\n        return wrapper(iterate(importer)(index)(unions)(meta.getName())(input));\n    };\n\n  const iterate =\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (unions: IUnion[]) =>\n    (expected: string) =>\n    (input: ts.Expression) =>\n      ts.factory.createBlock(\n        [\n          unions\n            .map((u, i) =>\n              ts.factory.createIfStatement(\n                u.is(),\n                u.value(index ? index + i : null),\n                i === unions.length - 1\n                  ? create_throw_error(importer)(expected)(input)\n                  : undefined,\n              ),\n            )\n            .reverse()\n            .reduce((a, b) =>\n              ts.factory.createIfStatement(b.expression, b.thenStatement, a),\n            ),\n        ],\n        true,\n      );\n\n  const decode_map =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      input: ts.Expression,\n      map: Metadata.Entry,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const each: ts.Statement[] = [\n        ts.factory.createExpressionStatement(\n          decode_tag(ProtobufWire.LEN)(index),\n        ),\n        ts.factory.createExpressionStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"fork\"),\n            undefined,\n            undefined,\n          ),\n        ),\n        ...decode(project)(importer)(1)(\n          ts.factory.createIdentifier(\"key\"),\n          map.key,\n          explore,\n        ).statements,\n        ...decode(project)(importer)(2)(\n          ts.factory.createIdentifier(\"value\"),\n          map.value,\n          explore,\n        ).statements,\n        ts.factory.createExpressionStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"ldelim\"),\n            undefined,\n            undefined,\n          ),\n        ),\n      ];\n      return ts.factory.createBlock(\n        [\n          ts.factory.createForOfStatement(\n            undefined,\n            StatementFactory.entry(\"key\")(\"value\"),\n            input,\n            ts.factory.createBlock(each),\n          ),\n        ],\n        true,\n      );\n    };\n\n  const decode_object =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      object: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const top: MetadataProperty = object.properties[0]!;\n      if (top.key.isSoleLiteral() === false)\n        return decode_map(project)(importer)(index!)(\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Object.entries\"),\n            [],\n            [input],\n          ),\n          MetadataProperty.create({\n            ...top,\n            key: (() => {\n              const key: Metadata = Metadata.initialize();\n              key.atomics.push(\n                MetadataAtomic.create({\n                  type: \"string\",\n                  tags: [],\n                }),\n              );\n              return key;\n            })(),\n          }),\n          explore,\n        );\n      return ts.factory.createBlock(\n        [\n          ts.factory.createIdentifier(\n            `//${index !== null ? ` ${index} -> ` : \"\"}${object.name}`,\n          ),\n          ...(index !== null\n            ? [\n                decode_tag(ProtobufWire.LEN)(index),\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(WRITER())(\"fork\"),\n                  undefined,\n                  undefined,\n                ),\n              ]\n            : []),\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${PREFIX}o${object.index}`),\n            ),\n            [],\n            [input],\n          ),\n          ...(index !== null\n            ? [\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(WRITER())(\"ldelim\"),\n                  undefined,\n                  undefined,\n                ),\n              ]\n            : []),\n        ].map((expr) => ts.factory.createExpressionStatement(expr)),\n        true,\n      );\n    };\n\n  const decode_array =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const wire = get_standalone_wire(array.type.value);\n      const forLoop = (index: number | null) =>\n        ts.factory.createForOfStatement(\n          undefined,\n          ts.factory.createVariableDeclarationList(\n            [ts.factory.createVariableDeclaration(\"elem\")],\n            ts.NodeFlags.Const,\n          ),\n          input,\n          decode(project)(importer)(index)(\n            ts.factory.createIdentifier(\"elem\"),\n            array.type.value,\n            explore,\n          ),\n        );\n      const length = (block: ts.Block) =>\n        ts.factory.createBlock(\n          [\n            ts.factory.createIfStatement(\n              ts.factory.createStrictInequality(\n                ExpressionFactory.number(0),\n                IdentifierFactory.access(input)(\"length\"),\n              ),\n              block,\n            ),\n          ],\n          true,\n        );\n\n      if (wire === ProtobufWire.LEN)\n        return length(ts.factory.createBlock([forLoop(index)], true));\n      return length(\n        ts.factory.createBlock(\n          [\n            ts.factory.createExpressionStatement(\n              decode_tag(ProtobufWire.LEN)(index),\n            ),\n            ts.factory.createExpressionStatement(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(WRITER())(\"fork\"),\n                undefined,\n                undefined,\n              ),\n            ),\n            forLoop(null),\n            ts.factory.createExpressionStatement(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(WRITER())(\"ldelim\"),\n                undefined,\n                undefined,\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const decode_bool = (index: number | null) => (input: ts.Expression) =>\n    ts.factory.createBlock(\n      [\n        ...(index !== null ? [decode_tag(ProtobufWire.VARIANT)(index)] : []),\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(WRITER())(\"bool\"),\n          undefined,\n          [input],\n        ),\n      ].map((exp) => ts.factory.createExpressionStatement(exp)),\n      true,\n    );\n\n  const decode_number =\n    (candidates: ProtobufAtomic.Numeric[]) =>\n    (type: ProtobufAtomic.Numeric) =>\n    (input: ts.Expression): IUnion => ({\n      type,\n      is: () =>\n        candidates.length === 1\n          ? ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"number\"),\n              ts.factory.createTypeOfExpression(input),\n            )\n          : ts.factory.createLogicalAnd(\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"number\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n              NumericRangeFactory.number(type)(input),\n            ),\n      value: (index) =>\n        ts.factory.createBlock(\n          [\n            ...(index !== null\n              ? [decode_tag(get_numeric_wire(type))(index)]\n              : []),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(WRITER())(type),\n              undefined,\n              [input],\n            ),\n          ].map((exp) => ts.factory.createExpressionStatement(exp)),\n          true,\n        ),\n    });\n\n  const decode_bigint =\n    (candidates: ProtobufAtomic.BigNumeric[]) =>\n    (type: ProtobufAtomic.BigNumeric) =>\n    (input: ts.Expression): IUnion => ({\n      type,\n      is: () =>\n        candidates.length === 1\n          ? ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"bigint\"),\n              ts.factory.createTypeOfExpression(input),\n            )\n          : ts.factory.createLogicalAnd(\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"bigint\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n              NumericRangeFactory.bigint(type)(input),\n            ),\n      value: (index) =>\n        ts.factory.createBlock(\n          [\n            ...(index !== null\n              ? [decode_tag(ProtobufWire.VARIANT)(index)]\n              : []),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(WRITER())(type),\n              undefined,\n              [input],\n            ),\n          ].map((exp) => ts.factory.createExpressionStatement(exp)),\n          true,\n        ),\n    });\n\n  const decode_bytes =\n    (method: \"bytes\" | \"string\") =>\n    (index: number) =>\n    (input: ts.Expression): ts.Block =>\n      ts.factory.createBlock(\n        [\n          decode_tag(ProtobufWire.LEN)(index),\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(method),\n            undefined,\n            [input],\n          ),\n        ].map((expr) => ts.factory.createExpressionStatement(expr)),\n        true,\n      );\n\n  const decode_tag =\n    (wire: ProtobufWire) =>\n    (index: number): ts.CallExpression =>\n      ts.factory.createCallExpression(\n        IdentifierFactory.access(WRITER())(\"uint32\"),\n        undefined,\n        [ExpressionFactory.number((index << 3) | wire)],\n      );\n\n  const get_standalone_wire = (meta: Metadata): ProtobufWire => {\n    if (\n      meta.arrays.length ||\n      meta.objects.length ||\n      meta.maps.length ||\n      meta.natives.length\n    )\n      return ProtobufWire.LEN;\n\n    const v = ProtobufUtil.getAtomics(meta)[0]!;\n    if (v === \"string\") return ProtobufWire.LEN;\n    else if (\n      v === \"bool\" ||\n      v === \"int32\" ||\n      v === \"uint32\" ||\n      v === \"int64\" ||\n      v === \"uint64\"\n    )\n      return ProtobufWire.VARIANT;\n    else if (v === \"float\") return ProtobufWire.I32;\n    return ProtobufWire.I64;\n  };\n\n  const get_numeric_wire = (type: ProtobufAtomic.Numeric) =>\n    type === \"double\"\n      ? ProtobufWire.I64\n      : type === \"float\"\n        ? ProtobufWire.I32\n        : ProtobufWire.VARIANT;\n\n  /* -----------------------------------------------------------\n        EXPLORERS\n    ----------------------------------------------------------- */\n  const explore_objects =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (level: number) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      targets: MetadataObject[],\n      explore: FeatureProgrammer.IExplore,\n      indexes?: Map<MetadataObject, number>,\n    ): ts.Block => {\n      if (targets.length === 1)\n        return decode_object(project)(importer)(\n          indexes ? indexes.get(targets[0]!)! : index,\n        )(input, targets[0]!, explore);\n\n      const expected: string = `(${targets.map((t) => t.name).join(\" | \")})`;\n\n      // POSSIBLE TO SPECIALIZE?\n      const specList = UnionPredicator.object(targets);\n      indexes ??= new Map(targets.map((t, i) => [t, index! + i]));\n\n      if (specList.length === 0) {\n        const condition: ts.Expression = decode_union_object(\n          IsProgrammer.decode_object(project)(importer),\n        )((i, o, e) =>\n          ExpressionFactory.selfCall(\n            decode_object(project)(importer)(indexes!.get(o)!)(i, o, e),\n          ),\n        )((expr) => expr)((value, expected) =>\n          create_throw_error(importer)(expected)(value),\n        )(input, targets, explore);\n        return StatementFactory.block(condition);\n      }\n      const remained: MetadataObject[] = targets.filter(\n        (t) => specList.find((s) => s.object === t) === undefined,\n      );\n\n      // DO SPECIALIZE\n      const condition: ts.IfStatement = specList\n        .filter((spec) => spec.property.key.getSoleLiteral() !== null)\n        .map((spec, i, array) => {\n          const key: string = spec.property.key.getSoleLiteral()!;\n          const accessor: ts.Expression = IdentifierFactory.access(input)(key);\n          const pred: ts.Expression = spec.neighbour\n            ? IsProgrammer.decode(project)(importer)(\n                accessor,\n                spec.property.value,\n                {\n                  ...explore,\n                  tracable: false,\n                  postfix: IdentifierFactory.postfix(key),\n                },\n              )\n            : ExpressionFactory.isRequired(accessor);\n          return ts.factory.createIfStatement(\n            pred,\n            ts.factory.createExpressionStatement(\n              ExpressionFactory.selfCall(\n                decode_object(project)(importer)(indexes!.get(spec.object)!)(\n                  input,\n                  spec.object,\n                  explore,\n                ),\n              ),\n            ),\n            i === array.length - 1\n              ? remained.length\n                ? ts.factory.createExpressionStatement(\n                    ExpressionFactory.selfCall(\n                      explore_objects(project)(importer)(level + 1)(index)(\n                        input,\n                        remained,\n                        explore,\n                        indexes!,\n                      ),\n                    ),\n                  )\n                : create_throw_error(importer)(expected)(input)\n              : undefined,\n          );\n        })\n        .reverse()\n        .reduce((a, b) =>\n          ts.factory.createIfStatement(b.expression, b.thenStatement, a),\n        );\n\n      // RETURNS WITH CONDITIONS\n      return ts.factory.createBlock([condition], true);\n    };\n\n  /* -----------------------------------------------------------\n        CONFIGURATIONS\n    ----------------------------------------------------------- */\n  const PREFIX = \"$pe\";\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n\nconst WRITER = () => ts.factory.createIdentifier(\"writer\");\n\ninterface IUnion {\n  type: string;\n  is: () => ts.Expression;\n  value: (index: number | null) => ts.Block;\n}\n"]}