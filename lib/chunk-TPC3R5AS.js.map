{"version":3,"sources":["../src/programmers/internal/decode_union_object.ts"],"names":["ts","decode_union_object","checker","decoder","success","escaper","input","targets","explore","factory","createCallExpression","createArrowFunction","undefined","iterate","map","obj","type","is","value","t","name","join","unions","expected","branches","u","condition","kind","SyntaxKind","TrueKeyword","push","length","createBlock","statements","b","createIfStatement","createReturnStatement","at"],"mappings":";;;;;AAAA,OAAOA,QAAQ;AASR,IAAMC,sBACX,wBACEC,YAMF,CACEC,YAMF,CAACC,YACD,CAACC,YACD,CACEC,OACAC,SACAC,YAEAR,GAAGS,QAAQC,qBACTV,GAAGS,QAAQE,oBACTC,QACAA,QACA,CAAA,GACAA,QACAA,QACAC,QAAQR,OAAAA,EACNC,OACAC,QAAQO,IAAI,CAACC,SAAS;EACpBC,MAAM;EACNC,IAAI,6BAAMb,QAAQF,QAAQI,OAAOS,KAAKP,OAAAA,CAAAA,GAAlC;EACJU,OAAO,6BAAMf,QAAQG,OAAOS,KAAKP,OAAAA,GAA1B;AACT,EAAA,GACA,IAAID,QAAQO,IAAI,CAACK,MAAMA,EAAEC,IAAI,EAAEC,KAAK,KAAA,CAAA,GAAS,CAAA,GAGjDT,QACAA,MAAAA,GAvCJ;AA0CF,IAAMC,UACJ,wBAACR,YACD,CAACC,OAAsBgB,QAAkBC,aAAAA;AAKvC,QAAMC,WAAsB,CAAA;AAE5B,aAAWC,KAAKH,QAAQ;AACtB,UAAMI,YAA2BD,EAAER,GAAE;AACrC,QAAIS,UAAUC,SAAS3B,GAAG4B,WAAWC,aAAa;AAChDL,eAASM,KAAK;QACZJ,WAAW;QACXR,OAAOO,EAAEP,MAAK;MAChB,CAAA;AACA;IACF;AACAM,aAASM,KAAK;MACZJ;MACAR,OAAOO,EAAEP,MAAK;IAChB,CAAA;EACF;AACA,MAAIM,SAASO,WAAW,EACtB,QAAO/B,GAAGS,QAAQuB,YAAY;IAAC3B,QAAQC,OAAOiB,QAAAA;KAAY,IAAA;WACnDC,SAASO,WAAW,KAAKP,SAAS,CAAA,EAAIE,cAAc,KAC3D,QAAOF,SAAS,CAAA,EAAIN;AAEtB,QAAMe,aAA6BT,SAASV,IAAI,CAACoB,MAC/CA,EAAER,cAAc,OACZ1B,GAAGS,QAAQ0B,kBACTD,EAAER,WACF1B,GAAGS,QAAQ2B,sBAAsBF,EAAEhB,KAAK,GACxCN,MAAAA,IAEFZ,GAAGS,QAAQ2B,sBAAsBF,EAAEhB,KAAK,CAAA;AAE9C,MAAIM,SAASa,GAAG,EAAC,EAAIX,cAAc,KACjCO,YAAWH,KAAKzB,QAAQC,OAAOiB,QAAAA,CAAAA;AACjC,SAAOvB,GAAGS,QAAQuB,YAAYC,YAAY,IAAA;AAC5C,GAvCA","sourcesContent":["import ts from \"typescript\";\n\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\n\n/**\n * @internal\n */\nexport const decode_union_object =\n  (\n    checker: (\n      input: ts.Expression,\n      obj: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ) => ts.Expression,\n  ) =>\n  (\n    decoder: (\n      input: ts.Expression,\n      obj: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ) => ts.Expression,\n  ) =>\n  (success: (exp: ts.Expression) => ts.Expression) =>\n  (escaper: (value: ts.Expression, expected: string) => ts.Statement) =>\n  (\n    input: ts.Expression,\n    targets: MetadataObject[],\n    explore: FeatureProgrammer.IExplore,\n  ): ts.CallExpression =>\n    ts.factory.createCallExpression(\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [],\n        undefined,\n        undefined,\n        iterate(escaper)(\n          input,\n          targets.map((obj) => ({\n            type: \"object\",\n            is: () => success(checker(input, obj, explore)),\n            value: () => decoder(input, obj, explore),\n          })),\n          `(${targets.map((t) => t.name).join(\" | \")})`,\n        ),\n      ),\n      undefined,\n      undefined,\n    );\n\nconst iterate =\n  (escaper: (value: ts.Expression, expected: string) => ts.Statement) =>\n  (input: ts.Expression, unions: IUnion[], expected: string) => {\n    interface IBranch {\n      condition: null | ts.Expression;\n      value: ts.Expression;\n    }\n    const branches: IBranch[] = [];\n\n    for (const u of unions) {\n      const condition: ts.Expression = u.is();\n      if (condition.kind === ts.SyntaxKind.TrueKeyword) {\n        branches.push({\n          condition: null,\n          value: u.value(),\n        });\n        break;\n      }\n      branches.push({\n        condition,\n        value: u.value(),\n      });\n    }\n    if (branches.length === 0)\n      return ts.factory.createBlock([escaper(input, expected)], true);\n    else if (branches.length === 1 && branches[0]!.condition === null)\n      return branches[0]!.value;\n\n    const statements: ts.Statement[] = branches.map((b) =>\n      b.condition !== null\n        ? ts.factory.createIfStatement(\n            b.condition,\n            ts.factory.createReturnStatement(b.value),\n            undefined,\n          )\n        : ts.factory.createReturnStatement(b.value),\n    );\n    if (branches.at(-1)!.condition !== null)\n      statements.push(escaper(input, expected));\n    return ts.factory.createBlock(statements, true);\n  };\n\ninterface IUnion {\n  type: string;\n  is: () => ts.Expression;\n  value: () => ts.Expression;\n}\n"]}