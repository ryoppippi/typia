{"version":3,"sources":["../src/programmers/internal/check_dynamic_properties.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { check_dynamic_key } from \"./check_dynamic_key\";\nimport { check_everything } from \"./check_everything\";\nimport { check_object } from \"./check_object\";\n\n/**\n * @internal\n */\nexport const check_dynamic_properties =\n  (props: check_object.IProps) =>\n  (project: IProject) =>\n  (importer: FunctionImporter) =>\n  (\n    input: ts.Expression,\n    regular: IExpressionEntry<ts.Expression>[],\n    dynamic: IExpressionEntry<ts.Expression>[],\n  ): ts.Expression => {\n    const length = IdentifierFactory.access(\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\"Object.keys\"),\n        undefined,\n        [input],\n      ),\n    )(\"length\");\n    const left: ts.Expression | null =\n      props.equals === true && dynamic.length === 0\n        ? props.undefined === true || regular.every((r) => r.meta.isRequired())\n          ? ts.factory.createStrictEquality(\n              ExpressionFactory.number(\n                regular.filter((r) => r.meta.isRequired()).length,\n              ),\n              length,\n            )\n          : ts.factory.createCallExpression(\n              importer.use(\"is_between\"),\n              [],\n              [\n                length,\n                ExpressionFactory.number(\n                  regular.filter((r) => r.meta.isRequired()).length,\n                ),\n                ExpressionFactory.number(regular.length),\n              ],\n            )\n        : null;\n    if (\n      props.undefined === false &&\n      left !== null &&\n      regular.every((r) => r.meta.isRequired())\n    )\n      return left;\n\n    const criteria = props.entries\n      ? ts.factory.createCallExpression(props.entries, undefined, [\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Object.keys\"),\n            undefined,\n            [input],\n          ),\n          check_dynamic_property(props)(project)(importer)(\n            input,\n            regular,\n            dynamic,\n          ),\n        ])\n      : ts.factory.createCallExpression(\n          IdentifierFactory.access(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"Object.keys\"),\n              undefined,\n              [input],\n            ),\n          )(props.assert ? \"every\" : \"map\"),\n          undefined,\n          [\n            check_dynamic_property(props)(project)(importer)(\n              input,\n              regular,\n              dynamic,\n            ),\n          ],\n        );\n    const right: ts.Expression = (props.halt || ((elem) => elem))(\n      props.assert ? criteria : check_everything(criteria),\n    );\n    return left\n      ? (props.undefined\n          ? ts.factory.createLogicalOr\n          : ts.factory.createLogicalAnd)(left, right)\n      : right;\n  };\n\nconst check_dynamic_property =\n  (props: check_object.IProps) =>\n  (project: IProject) =>\n  (importer: FunctionImporter) =>\n  (\n    input: ts.Expression,\n    regular: IExpressionEntry<ts.Expression>[],\n    dynamic: IExpressionEntry<ts.Expression>[],\n  ) => {\n    //----\n    // IF CONDITIONS\n    //----\n    // PREPARE ASSETS\n    const key = ts.factory.createIdentifier(\"key\");\n    const value = ts.factory.createIdentifier(\"value\");\n\n    const statements: ts.Statement[] = [];\n    const add = (exp: ts.Expression, output: ts.Expression) =>\n      statements.push(\n        ts.factory.createIfStatement(\n          exp,\n          ts.factory.createReturnStatement(output),\n        ),\n      );\n    const broken = { value: false };\n\n    // GATHER CONDITIONS\n    if (regular.length) add(is_regular_property(regular), props.positive);\n    statements.push(\n      StatementFactory.constant(\n        \"value\",\n        ts.factory.createElementAccessExpression(input, key),\n      ),\n    );\n    if (props.undefined === true)\n      add(\n        ts.factory.createStrictEquality(\n          ts.factory.createIdentifier(\"undefined\"),\n          value,\n        ),\n        props.positive,\n      );\n\n    for (const entry of dynamic) {\n      const condition: ts.Expression = check_dynamic_key(project)(importer)(\n        key,\n        entry.key,\n      );\n      if (condition.kind === ts.SyntaxKind.TrueKeyword) {\n        statements.push(ts.factory.createReturnStatement(entry.expression));\n        broken.value = true;\n        break;\n      } else add(condition, entry.expression);\n    }\n\n    //----\n    // FUNCTION BODY\n    //----\n    // CLOSURE BLOCK\n    const block: ts.Block = ts.factory.createBlock(\n      [\n        ...statements,\n        ...(broken.value\n          ? []\n          : [\n              ts.factory.createReturnStatement(\n                props.equals === true\n                  ? props.superfluous(value)\n                  : props.positive,\n              ),\n            ]),\n      ],\n      true,\n    );\n\n    // RETURNS\n    return ts.factory.createArrowFunction(\n      undefined,\n      undefined,\n      [IdentifierFactory.parameter(\"key\")],\n      undefined,\n      undefined,\n      block,\n    );\n  };\n\nconst is_regular_property = (regular: IExpressionEntry[]) =>\n  ts.factory.createCallExpression(\n    IdentifierFactory.access(\n      ts.factory.createArrayLiteralExpression(\n        regular.map((entry) =>\n          ts.factory.createStringLiteral(entry.key.getSoleLiteral()!),\n        ),\n      ),\n    )(\"some\"),\n    undefined,\n    [\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"prop\")],\n        undefined,\n        undefined,\n        ts.factory.createStrictEquality(\n          ts.factory.createIdentifier(\"key\"),\n          ts.factory.createIdentifier(\"prop\"),\n        ),\n      ),\n    ],\n  );\n"],"mappings":"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","names":["ts","check_dynamic_properties","props","project","importer","input","regular","dynamic","length","IdentifierFactory","access","ts","factory","createCallExpression","createIdentifier","undefined","left","equals","every","r","meta","isRequired","createStrictEquality","ExpressionFactory","number","filter","use","criteria","entries","check_dynamic_property","assert","right","halt","elem","check_everything","createLogicalOr","createLogicalAnd","key","value","statements","add","exp","output","push","createIfStatement","createReturnStatement","broken","is_regular_property","positive","StatementFactory","constant","createElementAccessExpression","entry","condition","check_dynamic_key","kind","SyntaxKind","TrueKeyword","expression","block","createBlock","superfluous","createArrowFunction","parameter","createArrayLiteralExpression","map","createStringLiteral","getSoleLiteral"]}