{"version":3,"sources":["../src/programmers/http/HttpFormDataProgrammer.ts"],"names":["ts","HttpFormDataProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","success","TransformerError","from","method","errors","object","data","objects","statements","decode_object","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","meta","explore","insert","msg","push","top","length","bucket","nullable","isRequired","nested","MetadataArrayType","atomics","HttpMetadataUtil","expected","templates","constants","map","c","values","reduce","a","b","natives","filter","n","size","property","tuples","isUnion","sets","maps","output","StatementFactory","createObjectLiteralExpression","properties","prop","decode_regular_property","createReturnStatement","createAsExpression","keyword","key","value","isArray","includes","arrays","elements","createPropertyAssignment","Escaper","variable","decode_array","createCallExpression","access","decode_value","onlyUndefindable","call","use","createBinaryExpression","createToken","SyntaxKind","QuestionQuestionToken","expression","createNull"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { HttpMetadataUtil } from \"../helpers/HttpMetadataUtil\";\n\nexport namespace HttpFormDataProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      // GET OBJECT TYPE\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.http.${importer.method}`)(\n          result.errors,\n        );\n\n      // DO TRANSFORM\n      const object: MetadataObject = result.data.objects[0]!;\n      const statements: ts.Statement[] = decode_object(importer)(object);\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\"FormData\"),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo), ...statements],\n          true,\n        ),\n      );\n    };\n\n  export const validate = (\n    meta: Metadata,\n    explore: MetadataFactory.IExplore,\n  ): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (explore.top === true) {\n      // TOP MUST BE ONLY OBJECT\n      if (meta.objects.length !== 1 || meta.bucket() !== 1)\n        insert(\"only one object type is allowed.\");\n      if (meta.nullable === true) insert(\"formdata parameters cannot be null.\");\n      if (meta.isRequired() === false)\n        insert(\"formdata parameters cannot be undefined.\");\n    } else if (\n      explore.nested !== null &&\n      explore.nested instanceof MetadataArrayType\n    ) {\n      //----\n      // ARRAY\n      //----\n      const atomics = HttpMetadataUtil.atomics(meta);\n      const expected: number =\n        meta.atomics.length +\n        meta.templates.length +\n        meta.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0) +\n        meta.natives.filter((n) => n === \"Blob\" || n === \"File\").length;\n      if (atomics.size > 1) insert(\"union type is not allowed in array.\");\n      if (meta.size() !== expected)\n        insert(\n          \"only atomic, constant or blob (file) types are allowed in array.\",\n        );\n    } else if (explore.object && explore.property !== null) {\n      //----\n      // COMMON\n      //----\n      // PROPERTY MUST BE SOLE\n      if (typeof explore.property === \"object\")\n        insert(\"dynamic property is not allowed.\");\n      // DO NOT ALLOW TUPLE TYPE\n      if (meta.tuples.length) insert(\"tuple type is not allowed.\");\n      // DO NOT ALLOW UNION TYPE\n      if (HttpMetadataUtil.isUnion(meta)) insert(\"union type is not allowed.\");\n      // DO NOT ALLOW NESTED OBJECT\n      if (\n        meta.objects.length ||\n        meta.sets.length ||\n        meta.maps.length ||\n        meta.natives.filter((n) => n !== \"Blob\" && n !== \"File\").length\n      )\n        insert(\"nested object type is not allowed.\");\n    }\n    return errors;\n  };\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (object: MetadataObject): ts.Statement[] => {\n      // const input: ts.Identifier = ts.factory.createIdentifier(\"input\");\n      const output: ts.Identifier = ts.factory.createIdentifier(\"output\");\n      return [\n        StatementFactory.constant(\n          \"output\",\n          ts.factory.createObjectLiteralExpression(\n            object.properties.map((prop) =>\n              decode_regular_property(importer)(prop),\n            ),\n            true,\n          ),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createAsExpression(output, TypeFactory.keyword(\"any\")),\n        ),\n      ];\n    };\n\n  const decode_regular_property =\n    (importer: FunctionImporter) =>\n    (property: MetadataProperty): ts.PropertyAssignment => {\n      const key: string = property.key.constants[0]!.values[0]!.value as string;\n      const value: Metadata = property.value;\n\n      const [type, isArray]: [Atomic.Literal | \"blob\" | \"file\", boolean] = value\n        .atomics.length\n        ? [value.atomics[0]!.type, false]\n        : value.constants.length\n          ? [value.constants[0]!.type, false]\n          : value.templates.length\n            ? [\"string\", false]\n            : value.natives.includes(\"Blob\")\n              ? [\"blob\", false]\n              : value.natives.includes(\"File\")\n                ? [\"file\", false]\n                : (() => {\n                    const meta =\n                      value.arrays[0]?.type.value ??\n                      value.tuples[0]!.type.elements[0]!;\n                    return meta.atomics.length\n                      ? [meta.atomics[0]!.type, true]\n                      : meta.templates.length\n                        ? [\"string\", true]\n                        : meta.natives.includes(\"Blob\")\n                          ? [\"blob\", true]\n                          : meta.natives.includes(\"File\")\n                            ? [\"file\", true]\n                            : [meta.constants[0]!.type, true];\n                  })();\n      return ts.factory.createPropertyAssignment(\n        Escaper.variable(key) ? key : ts.factory.createStringLiteral(key),\n        isArray\n          ? decode_array(importer)(value)(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"input.getAll\"),\n                    undefined,\n                    [ts.factory.createStringLiteral(key)],\n                  ),\n                )(\"map\"),\n                undefined,\n                [\n                  ts.factory.createArrowFunction(\n                    undefined,\n                    undefined,\n                    [IdentifierFactory.parameter(\"elem\")],\n                    undefined,\n                    undefined,\n                    decode_value(importer)(type)(false)(\n                      ts.factory.createIdentifier(\"elem\"),\n                    ),\n                  ),\n                ],\n              ),\n            )\n          : decode_value(importer)(type)(\n              value.nullable === false && value.isRequired() === false,\n            )(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"input.get\"),\n                undefined,\n                [ts.factory.createStringLiteral(key)],\n              ),\n            ),\n      );\n    };\n\n  const decode_value =\n    (importer: FunctionImporter) =>\n    (type: Atomic.Literal | \"blob\" | \"file\") =>\n    (onlyUndefindable: boolean) =>\n    (value: ts.Expression) => {\n      const call = ts.factory.createCallExpression(\n        importer.use(type),\n        undefined,\n        [value],\n      );\n      return onlyUndefindable\n        ? ts.factory.createBinaryExpression(\n            call,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n            ts.factory.createIdentifier(\"undefined\"),\n          )\n        : call;\n    };\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (value: Metadata) =>\n    (expression: ts.Expression): ts.Expression =>\n      value.nullable || value.isRequired() === false\n        ? ts.factory.createCallExpression(importer.use(\"array\"), undefined, [\n            expression,\n            value.nullable\n              ? ts.factory.createNull()\n              : ts.factory.createIdentifier(\"undefined\"),\n          ])\n        : expression;\n}\n"]}