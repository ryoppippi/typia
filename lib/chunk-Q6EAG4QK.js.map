{"version":3,"sources":["../src/programmers/helpers/PruneJoiner.ts"],"names":["ts","PruneJoiner","object","input","entries","obj","regular","filter","entry","key","isSoleLiteral","dynamic","statements","map","isBlock","expression","factory","createExpressionStatement","flat","length","push","iterate_dynamic_properties","prune_object_properties","createBlock","array","arrow","createCallExpression","IdentifierFactory","access","undefined","tuple","children","rest","entire","elem","props","createIdentifier","createArrowFunction","parameter","createArrayBindingPattern","l","createBindingElement","createIfStatement","createStrictEquality","createReturnStatement","createStringLiteral","getSoleLiteral","metadata_to_pattern"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\n\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\n\nimport { metadata_to_pattern } from \"../internal/metadata_to_pattern\";\nimport { prune_object_properties } from \"../internal/prune_object_properties\";\nimport { IExpressionEntry } from \"./IExpressionEntry\";\n\nexport namespace PruneJoiner {\n  export const object = (\n    input: ts.Expression,\n    entries: IExpressionEntry[],\n    obj: MetadataObject,\n  ): ts.ConciseBody => {\n    // PREPARE ASSETS\n    const regular = entries.filter((entry) => entry.key.isSoleLiteral());\n    const dynamic = entries.filter((entry) => !entry.key.isSoleLiteral());\n\n    const statements: ts.Statement[] = regular\n      .map((entry) =>\n        ts.isBlock(entry.expression)\n          ? [...entry.expression.statements]\n          : [ts.factory.createExpressionStatement(entry.expression)],\n      )\n      .flat();\n    if (dynamic.length)\n      statements.push(\n        ts.factory.createExpressionStatement(\n          iterate_dynamic_properties({ regular, dynamic })(input),\n        ),\n      );\n\n    statements.push(prune_object_properties(obj));\n    return ts.factory.createBlock(statements, true);\n  };\n\n  export const array = (input: ts.Expression, arrow: ts.ArrowFunction) =>\n    ts.factory.createCallExpression(\n      IdentifierFactory.access(input)(\"forEach\"),\n      undefined,\n      [arrow],\n    );\n\n  export const tuple = (\n    children: ts.ConciseBody[],\n    rest: ts.ConciseBody | null,\n  ): ts.Block => {\n    const entire: ts.ConciseBody[] = [...children];\n    if (rest !== null) entire.push(rest);\n\n    const statements: ts.Statement[] = entire\n      .map((elem) =>\n        ts.isBlock(elem)\n          ? [...elem.statements]\n          : [ts.factory.createExpressionStatement(elem)],\n      )\n      .flat();\n    return ts.factory.createBlock(statements, true);\n  };\n}\n\nconst iterate_dynamic_properties =\n  (props: { regular: IExpressionEntry[]; dynamic: IExpressionEntry[] }) =>\n  (input: ts.Expression) =>\n    ts.factory.createCallExpression(\n      IdentifierFactory.access(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"Object.entries\"),\n          undefined,\n          [input],\n        ),\n      )(\"forEach\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\n              ts.factory.createArrayBindingPattern(\n                [\"key\", \"value\"].map((l) =>\n                  ts.factory.createBindingElement(\n                    undefined,\n                    undefined,\n                    ts.factory.createIdentifier(l),\n                    undefined,\n                  ),\n                ),\n              ),\n            ),\n          ],\n          undefined,\n          undefined,\n          ts.factory.createBlock(\n            [\n              ts.factory.createIfStatement(\n                ts.factory.createStrictEquality(\n                  ts.factory.createIdentifier(\"undefined\"),\n                  ts.factory.createIdentifier(\"value\"),\n                ),\n                ts.factory.createReturnStatement(),\n              ),\n              ...props.regular.map(({ key }) =>\n                ts.factory.createIfStatement(\n                  ts.factory.createStrictEquality(\n                    ts.factory.createStringLiteral(key.getSoleLiteral()!),\n                    ts.factory.createIdentifier(\"key\"),\n                  ),\n                  ts.factory.createReturnStatement(),\n                ),\n              ),\n              ...props.dynamic.map((dynamic) =>\n                ts.factory.createIfStatement(\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\n                      `RegExp(/${metadata_to_pattern(true)(\n                        dynamic.key,\n                      )}/).test`,\n                    ),\n                    undefined,\n                    [ts.factory.createIdentifier(\"key\")],\n                  ),\n                  ts.isBlock(dynamic.expression)\n                    ? dynamic.expression\n                    : ts.factory.createBlock([\n                        ts.factory.createExpressionStatement(\n                          dynamic.expression,\n                        ),\n                      ]),\n                ),\n              ),\n            ],\n            true,\n          ),\n        ),\n      ],\n    );\n"]}