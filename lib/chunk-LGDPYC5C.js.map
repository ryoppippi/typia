{"version":3,"sources":["../src/programmers/helpers/CloneJoiner.ts"],"names":["ts","CloneJoiner","object","input","entries","length","factory","createIdentifier","regular","filter","e","key","isSoleLiteral","dynamic","literal","createObjectLiteralExpression","map","entry","str","getSoleLiteral","createPropertyAssignment","Escaper","variable","createStringLiteral","expression","output","statements","push","createIfStatement","createCallExpression","IdentifierFactory","access","createArrayLiteralExpression","r","undefined","createArrowFunction","parameter","createStrictEquality","createContinueStatement","metadata_to_pattern","createBlock","createExpressionStatement","createBinaryExpression","createElementAccessExpression","createToken","SyntaxKind","EqualsToken","StatementFactory","constant","createAsExpression","TypeFactory","keyword","createForOfStatement","createReturnStatement","tuple","children","rest","createSpreadElement","array","arrow","createPropertyAccessExpression"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nimport { metadata_to_pattern } from \"../internal/metadata_to_pattern\";\nimport { IExpressionEntry } from \"./IExpressionEntry\";\n\nexport namespace CloneJoiner {\n  export const object = (\n    input: ts.Expression,\n    entries: IExpressionEntry<ts.Expression>[],\n  ): ts.ConciseBody => {\n    if (entries.length === 0) return ts.factory.createIdentifier(\"{}\");\n\n    const regular = entries.filter((e) => e.key.isSoleLiteral());\n    const dynamic = entries.filter((e) => !e.key.isSoleLiteral());\n    const literal = ts.factory.createObjectLiteralExpression(\n      regular.map((entry) => {\n        const str: string = entry.key.getSoleLiteral()!;\n        return ts.factory.createPropertyAssignment(\n          Escaper.variable(str) ? str : ts.factory.createStringLiteral(str),\n          entry.expression,\n        );\n      }),\n      true,\n    );\n    if (dynamic.length === 0) return literal;\n\n    const key = ts.factory.createIdentifier(\"key\");\n    const output = ts.factory.createIdentifier(\"output\");\n\n    const statements: ts.Statement[] = [];\n    if (regular.length !== 0)\n      statements.push(\n        ts.factory.createIfStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(\n              ts.factory.createArrayLiteralExpression(\n                regular.map((r) =>\n                  ts.factory.createStringLiteral(r.key.getSoleLiteral()!),\n                ),\n              ),\n            )(\"some\"),\n            undefined,\n            [\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [IdentifierFactory.parameter(\"regular\")],\n                undefined,\n                undefined,\n                ts.factory.createStrictEquality(\n                  ts.factory.createIdentifier(\"regular\"),\n                  ts.factory.createIdentifier(\"key\"),\n                ),\n              ),\n            ],\n          ),\n          ts.factory.createContinueStatement(),\n        ),\n      );\n    statements.push(\n      ...dynamic.map((entry) =>\n        ts.factory.createIfStatement(\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              `RegExp(/${metadata_to_pattern(true)(entry.key)}/).test`,\n            ),\n            undefined,\n            [key],\n          ),\n          ts.factory.createBlock([\n            ts.factory.createExpressionStatement(\n              ts.factory.createBinaryExpression(\n                ts.factory.createElementAccessExpression(output, key),\n                ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                entry.expression,\n              ),\n            ),\n            ts.factory.createContinueStatement(),\n          ]),\n        ),\n      ),\n    );\n\n    return ts.factory.createBlock([\n      StatementFactory.constant(\n        \"output\",\n        ts.factory.createAsExpression(literal, TypeFactory.keyword(\"any\")),\n      ),\n      ts.factory.createForOfStatement(\n        undefined,\n        StatementFactory.entry(\"key\")(\"value\"),\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"Object.entries\"),\n          undefined,\n          [input],\n        ),\n        ts.factory.createBlock(statements),\n      ),\n      ts.factory.createReturnStatement(output),\n    ]);\n  };\n\n  export const tuple = (\n    children: ts.Expression[],\n    rest: ts.Expression | null,\n  ): ts.Expression => {\n    return ts.factory.createAsExpression(\n      ts.factory.createArrayLiteralExpression(\n        rest === null\n          ? children\n          : [...children, ts.factory.createSpreadElement(rest)],\n        true,\n      ),\n      TypeFactory.keyword(\"any\"),\n    );\n  };\n\n  export const array = (input: ts.Expression, arrow: ts.Expression) =>\n    ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(input, \"map\"),\n      undefined,\n      [arrow],\n    );\n}\n"]}