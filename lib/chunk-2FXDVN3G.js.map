{"version":3,"sources":["../src/programmers/internal/check_dynamic_properties.ts"],"names":["ts","check_dynamic_properties","props","project","importer","input","regular","dynamic","length","IdentifierFactory","access","factory","createCallExpression","createIdentifier","undefined","left","equals","every","r","meta","isRequired","createStrictEquality","ExpressionFactory","number","filter","use","criteria","entries","check_dynamic_property","assert","right","halt","elem","check_everything","createLogicalOr","createLogicalAnd","key","value","statements","add","exp","output","push","createIfStatement","createReturnStatement","broken","is_regular_property","positive","StatementFactory","constant","createElementAccessExpression","entry","condition","check_dynamic_key","kind","SyntaxKind","TrueKeyword","expression","block","createBlock","superfluous","createArrowFunction","parameter","createArrayLiteralExpression","map","createStringLiteral","getSoleLiteral"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { check_dynamic_key } from \"./check_dynamic_key\";\nimport { check_everything } from \"./check_everything\";\nimport { check_object } from \"./check_object\";\n\n/**\n * @internal\n */\nexport const check_dynamic_properties =\n  (props: check_object.IProps) =>\n  (project: IProject) =>\n  (importer: FunctionImporter) =>\n  (\n    input: ts.Expression,\n    regular: IExpressionEntry<ts.Expression>[],\n    dynamic: IExpressionEntry<ts.Expression>[],\n  ): ts.Expression => {\n    const length = IdentifierFactory.access(\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\"Object.keys\"),\n        undefined,\n        [input],\n      ),\n    )(\"length\");\n    const left: ts.Expression | null =\n      props.equals === true && dynamic.length === 0\n        ? props.undefined === true || regular.every((r) => r.meta.isRequired())\n          ? ts.factory.createStrictEquality(\n              ExpressionFactory.number(\n                regular.filter((r) => r.meta.isRequired()).length,\n              ),\n              length,\n            )\n          : ts.factory.createCallExpression(\n              importer.use(\"is_between\"),\n              [],\n              [\n                length,\n                ExpressionFactory.number(\n                  regular.filter((r) => r.meta.isRequired()).length,\n                ),\n                ExpressionFactory.number(regular.length),\n              ],\n            )\n        : null;\n    if (\n      props.undefined === false &&\n      left !== null &&\n      regular.every((r) => r.meta.isRequired())\n    )\n      return left;\n\n    const criteria = props.entries\n      ? ts.factory.createCallExpression(props.entries, undefined, [\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Object.keys\"),\n            undefined,\n            [input],\n          ),\n          check_dynamic_property(props)(project)(importer)(\n            input,\n            regular,\n            dynamic,\n          ),\n        ])\n      : ts.factory.createCallExpression(\n          IdentifierFactory.access(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"Object.keys\"),\n              undefined,\n              [input],\n            ),\n          )(props.assert ? \"every\" : \"map\"),\n          undefined,\n          [\n            check_dynamic_property(props)(project)(importer)(\n              input,\n              regular,\n              dynamic,\n            ),\n          ],\n        );\n    const right: ts.Expression = (props.halt || ((elem) => elem))(\n      props.assert ? criteria : check_everything(criteria),\n    );\n    return left\n      ? (props.undefined\n          ? ts.factory.createLogicalOr\n          : ts.factory.createLogicalAnd)(left, right)\n      : right;\n  };\n\nconst check_dynamic_property =\n  (props: check_object.IProps) =>\n  (project: IProject) =>\n  (importer: FunctionImporter) =>\n  (\n    input: ts.Expression,\n    regular: IExpressionEntry<ts.Expression>[],\n    dynamic: IExpressionEntry<ts.Expression>[],\n  ) => {\n    //----\n    // IF CONDITIONS\n    //----\n    // PREPARE ASSETS\n    const key = ts.factory.createIdentifier(\"key\");\n    const value = ts.factory.createIdentifier(\"value\");\n\n    const statements: ts.Statement[] = [];\n    const add = (exp: ts.Expression, output: ts.Expression) =>\n      statements.push(\n        ts.factory.createIfStatement(\n          exp,\n          ts.factory.createReturnStatement(output),\n        ),\n      );\n    const broken = { value: false };\n\n    // GATHER CONDITIONS\n    if (regular.length) add(is_regular_property(regular), props.positive);\n    statements.push(\n      StatementFactory.constant(\n        \"value\",\n        ts.factory.createElementAccessExpression(input, key),\n      ),\n    );\n    if (props.undefined === true)\n      add(\n        ts.factory.createStrictEquality(\n          ts.factory.createIdentifier(\"undefined\"),\n          value,\n        ),\n        props.positive,\n      );\n\n    for (const entry of dynamic) {\n      const condition: ts.Expression = check_dynamic_key(project)(importer)(\n        key,\n        entry.key,\n      );\n      if (condition.kind === ts.SyntaxKind.TrueKeyword) {\n        statements.push(ts.factory.createReturnStatement(entry.expression));\n        broken.value = true;\n        break;\n      } else add(condition, entry.expression);\n    }\n\n    //----\n    // FUNCTION BODY\n    //----\n    // CLOSURE BLOCK\n    const block: ts.Block = ts.factory.createBlock(\n      [\n        ...statements,\n        ...(broken.value\n          ? []\n          : [\n              ts.factory.createReturnStatement(\n                props.equals === true\n                  ? props.superfluous(value)\n                  : props.positive,\n              ),\n            ]),\n      ],\n      true,\n    );\n\n    // RETURNS\n    return ts.factory.createArrowFunction(\n      undefined,\n      undefined,\n      [IdentifierFactory.parameter(\"key\")],\n      undefined,\n      undefined,\n      block,\n    );\n  };\n\nconst is_regular_property = (regular: IExpressionEntry[]) =>\n  ts.factory.createCallExpression(\n    IdentifierFactory.access(\n      ts.factory.createArrayLiteralExpression(\n        regular.map((entry) =>\n          ts.factory.createStringLiteral(entry.key.getSoleLiteral()!),\n        ),\n      ),\n    )(\"some\"),\n    undefined,\n    [\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"prop\")],\n        undefined,\n        undefined,\n        ts.factory.createStrictEquality(\n          ts.factory.createIdentifier(\"key\"),\n          ts.factory.createIdentifier(\"prop\"),\n        ),\n      ),\n    ],\n  );\n"]}