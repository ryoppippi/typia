{"version":3,"sources":["../src/json.ts"],"names":["json_exports","application","halt","assertParse","assertParsePure","Object","assign","Namespace","assert","isParse","isParsePure","is","validateParse","validateParsePure","validate","stringify","stringifyPure","json","assertStringify","assertStringifyPure","isStringify","isStringifyPure","validateStringify","validateStringifyPure","createIsParse","createIsParsePure","createAssertParse","createAssertParsePure","createValidateParse","createValidateParsePure","createStringify","createStringifyPure","createAssertStringify","createAssertStringifyPure","createIsStringify","createIsStringifyPure","createValidateStringify","createValidateStringifyPure","name","Error"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAAA,gBAAA;SAAAA,eAAA;;;;;;;;;;;;;;;;;AAgEO,SAASC,cAAAA;AACdC,OAAK,aAAA;AACP;AAFgBD;AA2DhB,SAASE,cAAAA;AACPD,OAAK,aAAA;AACP;AAFSC;AAGT,IAAMC,kBAAmCC,uBAAOC,OAC9CH,aACiBI,gBAAUC,OAAO,kBAAA,CAAA;AA+CpC,SAASC,UAAAA;AACPP,OAAK,SAAA;AACP;AAFSO;AAGT,IAAMC,cAA+BL,uBAAOC,OAC1CG,SACiBF,gBAAUI,GAAE,CAAA;AAiD/B,SAASC,gBAAAA;AACPV,OAAK,eAAA;AACP;AAFSU;AAGT,IAAMC,oBAAqCR,uBAAOC,OAGhDM,eAAgCL,gBAAUO,SAAQ,CAAA;AAiCpD,SAASC,YAAAA;AACPb,OAAK,WAAA;AACP;AAFSa;AAGT,IAAMC,gBAAiCX,uBAAOC,OAC5CS,WACiBR,gBAAUU,aAAKF,UAAU,WAAA,CAAA;AA6D5C,SAASG,kBAAAA;AACPhB,OAAK,iBAAA;AACP;AAFSgB;AAGT,IAAMC,sBAAuCd,uBAAOC,OAKlDY,iBACiBX,gBAAUC,OAAO,sBAAA,GACjBD,gBAAUU,aAAKF,UAAU,iBAAA,CAAA;AAqD5C,SAASK,cAAAA;AACPlB,OAAK,aAAA;AACP;AAFSkB;AAIT,IAAMC,kBAAmChB,uBAAOC,OAK9Cc,aACiBb,gBAAUI,GAAE,GACZJ,gBAAUU,aAAKF,UAAU,aAAA,CAAA;AAuD5C,SAASO,oBAAAA;AACPpB,OAAK,mBAAA;AACP;AAFSoB;AAGT,IAAMC,wBAAyClB,uBAAOC,OAKpDgB,mBACiBf,gBAAUO,SAAQ,GAClBP,gBAAUU,aAAKF,UAAU,mBAAA,CAAA;AA+B5C,SAASS,gBAAAA;AACPtB,OAAK,eAAA;AACP;AAFSsB;AAGT,IAAMC,oBAAqCpB,uBAAOC,OAGhDkB,eAAed,WAAAA;AAiCjB,SAASgB,oBAAAA;AACPxB,OAAK,mBAAA;AACP;AAFSwB;AAGT,IAAMC,wBAAyCtB,uBAAOC,OAGpDoB,mBAAmBtB,eAAAA;AA2BrB,SAASwB,sBAAAA;AAGP1B,OAAK,qBAAA;AACP;AAJS0B;AAMT,IAAMC,0BAA2CxB,uBAAOC,OAGtDsB,qBAAqBf,iBAAAA;AA2BvB,SAASiB,kBAAAA;AACP5B,OAAK,iBAAA;AACP;AAFS4B;AAIT,IAAMC,sBAAuC1B,uBAAOC,OAGlDwB,iBAAiBd,aAAAA;AAiCnB,SAASgB,wBAAAA;AACP9B,OAAK,uBAAA;AACP;AAFS8B;AAIT,IAAMC,4BAA6C5B,uBAAOC,OAGxD0B,uBAAuBb,mBAAAA;AA2BzB,SAASe,oBAAAA;AACPhC,OAAK,mBAAA;AACP;AAFSgC;AAIT,IAAMC,wBAAyC9B,uBAAOC,OAGpD4B,mBAAmBb,eAAAA;AA2BrB,SAASe,0BAAAA;AACPlC,OAAK,yBAAA;AACP;AAFSkC;AAIT,IAAMC,8BAA+ChC,uBAAOC,OAG1D8B,yBAAyBb,qBAAAA;AAM3B,SAASrB,KAAKoC,MAAY;AACxB,QAAM,IAAIC,MACR,uBAAuBD,IAAAA,2FAA+F;AAE1H;AAJSpC","sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { IJsonApplication } from \"./schemas/json/IJsonApplication\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Primitive } from \"./Primitive\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    JSON\n      - SCHEMA\n      - PARSE\n      - STRINGIFY\n      - FACTORY FUNCTIONS\n==============================================================\n    SCHEMA\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `Types`.\n *\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and\n * components. Note that, all of the named types are stored in the\n * {@link IJsonApplication.components} property for the `$ref` referencing.\n *\n * Also, you can specify the OpenAPI version by configuring the second generic\n * argument `Version`. For reference, the default version is `\"3.1\"`, and key\n * different of `\"3.0\"` and `\"3.1\"` is whether supporting the tuple type or not.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema\n * @template Surplus Allow surplus properties starting with `x-typia-` or not\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function application(): never;\n\n/**\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and\n * components. Note that, all of the named types are stored in the\n * {@link IJsonApplication.components} property for the `$ref` referencing.\n *\n * Also, you can specify the OpenAPI version by configuring the second generic\n * argument `Version`. For reference, the default version is `\"3.1\"`, and key\n * different of `\"3.0\"` and `\"3.1\"` is whether supporting the tuple type or not.\n *\n * @template Types Tuple of target types\n * @template Version Version of OpenAPI specification. Default is 3.1\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function application<\n  Types extends unknown[],\n  Version extends \"3.0\" | \"3.1\" = \"3.1\",\n>(): IJsonApplication<Version>;\n\n/**\n * @internal\n */\nexport function application(): never {\n  halt(\"application\");\n}\n\n/* -----------------------------------------------------------\n    PARSE\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.json.assertParse()` is a combination function of `JSON.parse()` and\n * {@link assert}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the parsed value, the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertParse(\n  input: string,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.json.assertParse()` is a combination function of `JSON.parse()` and\n * {@link assert}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`,\n * it throws {@link TypeGuardError} or custom error generated by *errorFactory*.\n * Otherwise, there's no problem on the parsed value, the parsed value would be\n * returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertParse<T>(\n  input: string,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Primitive<T>;\n\n/**\n * @internal\n */\nfunction assertParse<T>(): Primitive<T> {\n  halt(\"assertParse\");\n}\nconst assertParsePure = /** @__PURE__ */ Object.assign<typeof assertParse, {}>(\n  assertParse,\n  /** @__PURE__ */ Namespace.assert(\"json.assertParse\"),\n);\nexport { assertParsePure as assertParse };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.json.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there's no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isParse(input: string): never;\n\n/**\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.json.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there's no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isParse<T>(input: string): Primitive<T> | null;\n\n/**\n * @internal\n */\nfunction isParse<T>(): Primitive<T> | null {\n  halt(\"isParse\");\n}\nconst isParsePure = /** @__PURE__ */ Object.assign<typeof isParse, {}>(\n  isParse,\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isParsePure as isParse };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.json.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateParse(input: string): never;\n\n/**\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.json.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateParse<T>(input: string): IValidation<Primitive<T>>;\n\n/**\n * @internal\n */\nfunction validateParse<T>(): IValidation<Primitive<T>> {\n  halt(\"validateParse\");\n}\nconst validateParsePure = /** @__PURE__ */ Object.assign<\n  typeof validateParse,\n  {}\n>(validateParse, /** @__PURE__ */ Namespace.validate());\nexport { validateParsePure as validateParse };\n\n/* -----------------------------------------------------------\n    STRINGIFY\n----------------------------------------------------------- */\n/**\n * 8x faster `JSON.stringify()` function.\n *\n * Converts an input value to a JSON (JavaScript Object Notation) string, about 8x\n * faster than the native `JSON.stringify()` function. The 5x faster principle is\n * because it writes an optimized JSON conversion plan, only for the type `T`.\n *\n * For reference, this `typia.json.stringify()` does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can't ensure the input value type, it would be better to call one of below\n * functions instead.\n *\n *  - {@link assertStringify}\n *  - {@link isStringify}\n *  - {@link validateStringify}\n *\n * @template T Type of the input value\n * @param input A value to be converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction stringify<T>(input: T): string;\n\n/**\n * @internal\n */\nfunction stringify(): never {\n  halt(\"stringify\");\n}\nconst stringifyPure = /** @__PURE__ */ Object.assign<typeof stringify, {}>(\n  stringify,\n  /** @__PURE__ */ Namespace.json.stringify(\"stringify\"),\n);\nexport { stringifyPure as stringify };\n\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.json.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to\n * JSON (JavaScript Object Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, JSON string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertStringify<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): string;\n\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.json.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to\n * JSON (JavaScript Object Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, JSON string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertStringify<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): unknown;\n\n/**\n * @internal\n */\nfunction assertStringify(): string {\n  halt(\"assertStringify\");\n}\nconst assertStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof assertStringify,\n  {},\n  {}\n>(\n  assertStringify,\n  /** @__PURE__ */ Namespace.assert(\"json.assertStringify\"),\n  /** @__PURE__ */ Namespace.json.stringify(\"assertStringify\"),\n);\nexport { assertStringifyPure as assertStringify };\n\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.json.stringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, JSON string\n * would be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isStringify<T>(input: T): string | null;\n\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.json.isStringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, JSON string\n * would be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isStringify<T>(input: unknown): string | null;\n\n/**\n * @internal\n */\nfunction isStringify(): string | null {\n  halt(\"isStringify\");\n}\n\nconst isStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof isStringify,\n  {},\n  {}\n>(\n  isStringify,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.json.stringify(\"isStringify\"),\n);\nexport { isStringifyPure as isStringify };\n\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.json.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the `input` value, JSON string would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON\n * conversion with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateStringify<T>(input: T): IValidation<string>;\n\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.json.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the `input` value, JSON string would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON\n * conversion with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateStringify<T>(input: unknown): IValidation<string>;\n\n/**\n * @internal\n */\nfunction validateStringify(): IValidation<string> {\n  halt(\"validateStringify\");\n}\nconst validateStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof validateStringify,\n  {},\n  {}\n>(\n  validateStringify,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.json.stringify(\"validateStringify\"),\n);\nexport { validateStringifyPure as validateStringify };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsParse(): never;\n\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `isParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsParse<T>(): (input: string) => Primitive<T> | null;\n\n/**\n * @internal\n */\nfunction createIsParse<T>(): (input: string) => Primitive<T> | null {\n  halt(\"createIsParse\");\n}\nconst createIsParsePure = /** @__PURE__ */ Object.assign<\n  typeof createIsParse,\n  {}\n>(createIsParse, isParsePure);\nexport { createIsParsePure as createIsParse };\n\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertParse(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @template T Expected type of parsed value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertParse<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: string) => Primitive<T>;\n\n/**\n * @internal\n */\nfunction createAssertParse<T>(): (input: string) => Primitive<T> {\n  halt(\"createAssertParse\");\n}\nconst createAssertParsePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertParse,\n  {}\n>(createAssertParse, assertParsePure);\nexport { createAssertParsePure as createAssertParse };\n\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateParse(): never;\n\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `validateParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateParse<T>(): (input: string) => IValidation<Primitive<T>>;\n\n/**\n * @internal\n */\nfunction createValidateParse<T>(): (\n  input: string,\n) => IValidation<Primitive<T>> {\n  halt(\"createValidateParse\");\n}\n\nconst createValidateParsePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateParse,\n  {}\n>(createValidateParse, validateParsePure);\nexport { createValidateParsePure as createValidateParse };\n\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createStringify(): never;\n\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `stringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createStringify<T>(): (input: T) => string;\n\n/**\n * @internal\n */\nfunction createStringify<T>(): (input: T) => string {\n  halt(\"createStringify\");\n}\n\nconst createStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof createStringify,\n  {}\n>(createStringify, stringifyPure);\nexport { createStringifyPure as createStringify };\n\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertStringify(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertStringify<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => string;\n\n/**\n * @internal\n */\nfunction createAssertStringify(): (input: unknown) => string {\n  halt(\"createAssertStringify\");\n}\n\nconst createAssertStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertStringify,\n  {}\n>(createAssertStringify, assertStringifyPure);\nexport { createAssertStringifyPure as createAssertStringify };\n\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsStringify(): never;\n\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsStringify<T>(): (input: unknown) => string | null;\n\n/**\n * @internal\n */\nfunction createIsStringify(): (input: unknown) => string | null {\n  halt(\"createIsStringify\");\n}\n\nconst createIsStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof createIsStringify,\n  {}\n>(createIsStringify, isStringifyPure);\nexport { createIsStringifyPure as createIsStringify };\n\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateStringify(): never;\n\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateStringify` function\n\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n\n/**\n * @internal\n */\nfunction createValidateStringify(): (input: unknown) => IValidation<string> {\n  halt(\"createValidateStringify\");\n}\n\nconst createValidateStringifyPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateStringify,\n  {}\n>(createValidateStringify, validateStringifyPure);\nexport { createValidateStringifyPure as createValidateStringify };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.json.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}