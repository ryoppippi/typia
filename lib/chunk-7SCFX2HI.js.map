{"version":3,"sources":["../src/programmers/http/HttpParameterProgrammer.ts"],"names":["ts","HttpParameterProgrammer","write","project","modulo","type","name","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","MetadataCollection","success","TransformerError","from","getText","errors","atomic","HttpMetadataUtil","atomics","data","importer","FunctionImporter","block","StatementFactory","AssertProgrammer","options","numeric","factory","createCallExpression","use","undefined","createIdentifier","createReturnStatement","createArrowFunction","IdentifierFactory","parameter","createTypeReferenceNode","TypeFactory","getFullName","createBlock","declare","meta","insert","msg","push","any","isRequired","expected","length","templates","constants","map","c","values","reduce","a","b","size"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAiBEC,0BAAAA;2BACFC,QACX,CAACC,YACD,CAACC,WACD,CAACC,MAAeC,SAAAA;AACd,UAAMC,SAASC,gBAAgBC,QAC7BN,QAAQO,SACRP,QAAQQ,OAAO,EACf;MACAC,QAAQ;MACRC,UAAU;MACVC,QAAQ;MACRC,UAAQd,yBAARc;IACF,CAAA,EAAG,IAAIC,mBAAAA,CAAAA,EAAsBX,IAAAA;AAC7B,QAAIE,OAAOU,YAAY,MACrB,OAAMC,iBAAiBC,KAAKf,OAAOgB,QAAO,CAAA,EAAIb,OAAOc,MAAM;AAE7D,UAAMC,SAAS;SAAIC,iBAAiBC,QAAQjB,OAAOkB,IAAI;MAAG,CAAA;AAC1D,UAAMC,WAA6B,IAAIC,iBAAiBvB,OAAOgB,QAAO,CAAA;AACtE,UAAMQ,QAAwB;MAC5BC,iBAAiBhB,SACf,UACAiB,iBAAiB5B,MAAM;QACrB,GAAGC;QACH4B,SAAS;UACPC,SAAS;QACX;MACF,CAAA,EAAG5B,MAAAA,EAAQ,KAAA,EAAOC,MAAMC,IAAAA,CAAAA;MAE1BuB,iBAAiBhB,SACf,SACAb,GAAGiC,QAAQC,qBAAqBR,SAASS,IAAIb,MAAAA,GAASc,QAAW;QAC/DpC,GAAGiC,QAAQI,iBAAiB,OAAA;OAC7B,CAAA;MAEHrC,GAAGiC,QAAQK,sBACTtC,GAAGiC,QAAQC,qBACTlC,GAAGiC,QAAQI,iBAAiB,QAAA,GAC5BD,QACA;QAACpC,GAAGiC,QAAQI,iBAAiB,OAAA;OAAS,CAAA;;AAK5C,WAAOrC,GAAGiC,QAAQM,oBAChBH,QACAA,QACA;MACEI,kBAAkBC,UAChB,SACAzC,GAAGiC,QAAQS,wBAAwB,QAAA,CAAA;OAGvC1C,GAAGiC,QAAQS,wBACTpC,QAAQqC,YAAYC,YAAYzC,QAAQO,OAAO,EAAEL,IAAAA,CAAAA,GAEnD+B,QACApC,GAAGiC,QAAQY,YAAY;SAAInB,SAASoB,QAAQ1C,MAAAA;SAAYwB;OAAQ,IAAA,CAAA;EAEpE;2BAEWb,WAAW,CAACgC,SAAAA;AACvB,UAAM1B,SAAmB,CAAA;AACzB,UAAM2B,SAAS,wBAACC,QAAgB5B,OAAO6B,KAAKD,GAAAA,GAA7B;AAEf,QAAIF,KAAKI,IAAKH,QAAO,uBAAA;AACrB,QAAID,KAAKK,WAAU,MAAO,MAAOJ,QAAO,gCAAA;AAExC,UAAMxB,UAAUD,iBAAiBC,QAAQuB,IAAAA;AACzC,UAAMM,WACJN,KAAKvB,QAAQ8B,SACbP,KAAKQ,UAAUD,SACfP,KAAKS,UAAUC,IAAI,CAACC,MAAMA,EAAEC,OAAOL,MAAM,EAAEM,OAAO,CAACC,GAAGC,MAAMD,IAAIC,GAAG,CAAA;AACrE,QAAIf,KAAKgB,KAAI,MAAOV,YAAY7B,QAAQuC,SAAS,EAC/Cf,QAAO,2CAAA;AACT,QAAIxB,QAAQuC,OAAO,EAAGf,QAAO,yBAAA;AAE7B,WAAO3B;EACT;AACF,GA/EiBpB,4BAAAA,0BAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { HttpMetadataUtil } from \"../helpers/HttpMetadataUtil\";\n\nexport namespace HttpParameterProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate,\n      })(new MetadataCollection())(type);\n      if (result.success === false)\n        throw TransformerError.from(modulo.getText())(result.errors);\n\n      const atomic = [...HttpMetadataUtil.atomics(result.data)][0]!;\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const block: ts.Statement[] = [\n        StatementFactory.constant(\n          \"assert\",\n          AssertProgrammer.write({\n            ...project,\n            options: {\n              numeric: true,\n            },\n          })(modulo)(false)(type, name),\n        ),\n        StatementFactory.constant(\n          \"value\",\n          ts.factory.createCallExpression(importer.use(atomic), undefined, [\n            ts.factory.createIdentifier(\"input\"),\n          ]),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"assert\"),\n            undefined,\n            [ts.factory.createIdentifier(\"value\")],\n          ),\n        ),\n      ];\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\"string\"),\n          ),\n        ],\n        ts.factory.createTypeReferenceNode(\n          name ?? TypeFactory.getFullName(project.checker)(type),\n        ),\n        undefined,\n        ts.factory.createBlock([...importer.declare(modulo), ...block], true),\n      );\n    };\n\n  export const validate = (meta: Metadata): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (meta.any) insert(\"do not allow any type\");\n    if (meta.isRequired() === false) insert(\"do not allow undefindable type\");\n\n    const atomics = HttpMetadataUtil.atomics(meta);\n    const expected: number =\n      meta.atomics.length +\n      meta.templates.length +\n      meta.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0);\n    if (meta.size() !== expected || atomics.size === 0)\n      insert(\"only atomic or constant types are allowed\");\n    if (atomics.size > 1) insert(\"do not allow union type\");\n\n    return errors;\n  };\n}\n"]}