{"version":3,"sources":["../src/factories/JsonMetadataFactory.ts"],"names":["JsonMetadataFactory","analyze","method","checker","context","type","collection","MetadataCollection","result","MetadataFactory","escape","constant","absorb","validate","success","TransformerError","from","errors","data","meta","output","atomics","some","a","constants","c","push","tuples","t","elements","e","isRequired","arrays","value","maps","length","sets","native","natives","AtomicPredicator"],"mappings":";;;;;;;;;;;;;;;UAWiBA,sBAAAA;uBACFC,UACX,CAACC,WACD,CAACC,SAAyBC,YAC1B,CAACC,SAAAA;AACC,UAAMC,aAAa,IAAIC,mBAAAA;AACvB,UAAMC,SAASC,gBAAgBR,QAC7BE,SACAC,OAAAA,EACA;MACAM,QAAQ;MACRC,UAAU;MACVC,QAAQ;MACRC,UAAQb,qBAARa;IACF,CAAA,EAAGP,UAAAA,EAAYD,IAAAA;AACf,QAAIG,OAAOM,YAAY,MACrB,OAAMC,iBAAiBC,KAAKd,MAAAA,EAAQM,OAAOS,MAAM;AACnD,WAAO;MAACX;MAAYE,OAAOU;;EAC7B;uBAEWL,WAAW,CAACM,SAAAA;AACvB,UAAMC,SAAmB,CAAA;AACzB,QACED,KAAKE,QAAQC,KAAK,CAACC,MAAMA,EAAElB,SAAS,QAAA,KACpCc,KAAKK,UAAUF,KAAK,CAACG,MAAMA,EAAEpB,SAAS,QAAA,EAEtCe,QAAOM,KAAK,oCAAA;AACd,QACEP,KAAKQ,OAAOL,KAAK,CAACM,MAChBA,EAAEvB,KAAKwB,SAASP,KAAK,CAACQ,MAAMA,EAAEC,WAAU,MAAO,KAAA,CAAA,KAEjDZ,KAAKa,OAAOV,KAAK,CAACC,MAAMA,EAAElB,KAAK4B,MAAMF,WAAU,MAAO,KAAA,EAEtDX,QAAOM,KAAK,gDAAA;AACd,QAAIP,KAAKe,KAAKC,OAAQf,QAAOM,KAAK,iCAAA;AAClC,QAAIP,KAAKiB,KAAKD,OAAQf,QAAOM,KAAK,iCAAA;AAClC,eAAWW,UAAUlB,KAAKmB,QACxB,KAAIC,iBAAiBF,OAAOA,MAAAA,MAAY,SAASA,WAAW,OAC1DjB,QAAOM,KAAK,yBAAyBW,MAAAA,QAAc;AACvD,WAAOjB;EACT;AACF,GAzCiBpB,wBAAAA,sBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\n\nimport { AtomicPredicator } from \"../programmers/helpers/AtomicPredicator\";\n\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { MetadataCollection } from \"./MetadataCollection\";\nimport { MetadataFactory } from \"./MetadataFactory\";\n\nexport namespace JsonMetadataFactory {\n  export const analyze =\n    (method: string) =>\n    (checker: ts.TypeChecker, context?: ts.TransformationContext) =>\n    (type: ts.Type): [MetadataCollection, Metadata] => {\n      const collection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        checker,\n        context,\n      )({\n        escape: true,\n        constant: true,\n        absorb: true,\n        validate,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(method)(result.errors);\n      return [collection, result.data];\n    };\n\n  export const validate = (meta: Metadata) => {\n    const output: string[] = [];\n    if (\n      meta.atomics.some((a) => a.type === \"bigint\") ||\n      meta.constants.some((c) => c.type === \"bigint\")\n    )\n      output.push(\"JSON does not support bigint type.\");\n    if (\n      meta.tuples.some((t) =>\n        t.type.elements.some((e) => e.isRequired() === false),\n      ) ||\n      meta.arrays.some((a) => a.type.value.isRequired() === false)\n    )\n      output.push(\"JSON does not support undefined type in array.\");\n    if (meta.maps.length) output.push(\"JSON does not support Map type.\");\n    if (meta.sets.length) output.push(\"JSON does not support Set type.\");\n    for (const native of meta.natives)\n      if (AtomicPredicator.native(native) === false && native !== \"Date\")\n        output.push(`JSON does not support ${native} type.`);\n    return output;\n  };\n}\n"]}