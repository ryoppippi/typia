{"version":3,"sources":["../src/programmers/internal/stringify_dynamic_properties.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { TemplateFactory } from \"../../factories/TemplateFactory\";\n\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { metadata_to_pattern } from \"./metadata_to_pattern\";\n\n/**\n * @internal\n */\nexport const stringify_dynamic_properties = (\n  dynamic: IExpressionEntry<ts.Expression>[],\n  regular: string[],\n): ts.Expression => {\n  // BASIC STATMEMENT, CHECK UNDEFINED\n  const statements: ts.Statement[] = [\n    ts.factory.createIfStatement(\n      ts.factory.createStrictEquality(\n        ts.factory.createIdentifier(\"undefined\"),\n        ts.factory.createIdentifier(\"value\"),\n      ),\n      ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n    ),\n  ];\n\n  // PREPARE RETURN FUNCTION\n  const output = () => {\n    const mapped = ts.factory.createCallExpression(\n      IdentifierFactory.access(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"Object.entries\"),\n          undefined,\n          [ts.factory.createIdentifier(\"input\")],\n        ),\n      )(\"map\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\n              ts.factory.createArrayBindingPattern([\n                ts.factory.createBindingElement(undefined, undefined, \"key\"),\n                ts.factory.createBindingElement(undefined, undefined, \"value\"),\n              ]),\n              ts.factory.createTypeReferenceNode(\"[string, any]\"),\n            ),\n          ],\n          undefined,\n          undefined,\n          ts.factory.createBlock(statements),\n        ),\n      ],\n    );\n    const filtered = ts.factory.createCallExpression(\n      IdentifierFactory.access(mapped)(\"filter\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [IdentifierFactory.parameter(\"str\")],\n          undefined,\n          undefined,\n          ts.factory.createStrictInequality(\n            ts.factory.createStringLiteral(\"\"),\n            ts.factory.createIdentifier(\"str\"),\n          ),\n        ),\n      ],\n    );\n    return ts.factory.createCallExpression(\n      IdentifierFactory.access(filtered)(\"join\"),\n      undefined,\n      [ts.factory.createStringLiteral(\",\")],\n    );\n  };\n\n  // WHEN REGULAR PROPERTY EXISTS\n  if (regular.length)\n    statements.push(\n      ts.factory.createIfStatement(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(\n            ts.factory.createArrayLiteralExpression(\n              regular.map((key) => ts.factory.createStringLiteral(key)),\n            ),\n          )(\"some\"),\n          undefined,\n          [\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [IdentifierFactory.parameter(\"regular\")],\n              undefined,\n              undefined,\n              ts.factory.createStrictEquality(\n                ts.factory.createIdentifier(\"regular\"),\n                ts.factory.createIdentifier(\"key\"),\n              ),\n            ),\n          ],\n        ),\n        ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n      ),\n    );\n\n  // ONLY STRING TYPED KEY EXISTS\n  const simple: boolean =\n    dynamic.length === 1 &&\n    dynamic[0]!.key.size() === 1 &&\n    dynamic[0]!.key.atomics[0]?.type === \"string\";\n  if (simple === true) {\n    statements.push(stringify(dynamic[0]!));\n    return output();\n  }\n\n  // COMPOSITE TEMPLATE LITERAL TYPES\n  for (const entry of dynamic) {\n    const condition: ts.IfStatement = ts.factory.createIfStatement(\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          `RegExp(/${metadata_to_pattern(true)(entry.key)}/).test`,\n        ),\n        undefined,\n        [ts.factory.createIdentifier(\"key\")],\n      ),\n      stringify(entry),\n    );\n    statements.push(condition);\n  }\n  statements.push(\n    ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n  );\n\n  return output();\n};\n\n/**\n * @internal\n */\nconst stringify = (\n  entry: IExpressionEntry<ts.Expression>,\n): ts.ReturnStatement =>\n  ts.factory.createReturnStatement(\n    TemplateFactory.generate([\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\"JSON.stringify\"),\n        [],\n        [ts.factory.createIdentifier(\"key\")],\n      ),\n      ts.factory.createStringLiteral(\":\"),\n      entry.expression,\n    ]),\n  );\n"],"mappings":"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","names":["ts","stringify_dynamic_properties","dynamic","regular","statements","ts","factory","createIfStatement","createStrictEquality","createIdentifier","createReturnStatement","createStringLiteral","output","mapped","createCallExpression","IdentifierFactory","access","undefined","createArrowFunction","parameter","createArrayBindingPattern","createBindingElement","createTypeReferenceNode","createBlock","filtered","createStrictInequality","length","push","createArrayLiteralExpression","map","key","simple","size","atomics","type","stringify","entry","condition","metadata_to_pattern","TemplateFactory","generate","expression"]}