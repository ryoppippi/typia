{"version":3,"sources":["../src/programmers/helpers/ProtobufUtil.ts"],"sourcesContent":["import { IMetadataTypeTag } from \"../../schemas/metadata/IMetadataTypeTag\";\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\n\nimport { ProtobufAtomic } from \"../../typings/ProtobufAtomic\";\n\nexport namespace ProtobufUtil {\n  export const isStaticObject = (obj: MetadataObject): boolean =>\n    obj.properties.length >= 1 &&\n    obj.properties.every((p) => p.key.isSoleLiteral());\n\n  export const size = (meta: Metadata): number =>\n    getAtomics(meta).length +\n    meta.arrays.length +\n    meta.tuples.length +\n    meta.natives.length +\n    meta.objects.length +\n    meta.maps.length;\n\n  export const isUnion = (meta: Metadata): boolean => size(meta) > 1;\n\n  export const getAtomics = (meta: Metadata): ProtobufAtomic[] => {\n    const set: Set<ProtobufAtomic> = new Set();\n    if (meta.templates.length) set.add(\"string\");\n    for (const c of meta.constants)\n      if (c.type === \"boolean\") set.add(\"bool\");\n      else if (c.type === \"bigint\") set.add(\"uint64\");\n      else if (c.type === \"number\")\n        set.add(deduce_numeric_type(c.values.map((v) => v.value) as number[]));\n      else if (c.type === \"string\") set.add(\"string\");\n    for (const atomic of meta.atomics)\n      if (atomic.type === \"boolean\") set.add(\"bool\");\n      else if (atomic.type === \"bigint\")\n        decode_bigint(atomic.tags).forEach((t) => set.add(t));\n      else if (atomic.type === \"number\")\n        decode_number(atomic.tags).forEach((t) => set.add(t));\n      else if (atomic.type === \"string\") set.add(\"string\");\n\n    return [...set].sort(compare);\n  };\n\n  export const getNumbers = (meta: Metadata) => {\n    const set: Set<ProtobufAtomic.Numeric> = new Set();\n    for (const c of meta.constants)\n      if (c.type === \"number\")\n        set.add(deduce_numeric_type(c.values.map((v) => v.value) as number[]));\n    for (const atomic of meta.atomics)\n      if (atomic.type === \"number\")\n        decode_number(atomic.tags).forEach((t) => set.add(t));\n    return [...set].sort(compare);\n  };\n\n  export const getBigints = (meta: Metadata) => {\n    const set: Set<ProtobufAtomic.BigNumeric> = new Set();\n    for (const c of meta.constants) if (c.type === \"bigint\") set.add(\"uint64\");\n    for (const atomic of meta.atomics)\n      if (atomic.type === \"bigint\")\n        decode_bigint(atomic.tags).forEach((t) => set.add(t));\n    return [...set].sort(compare);\n  };\n\n  const compare = (x: ProtobufAtomic, y: ProtobufAtomic): number =>\n    ATOMIC_ORDER.get(x)! - ATOMIC_ORDER.get(y)!;\n}\n\nconst ATOMIC_ORDER = new Map<ProtobufAtomic, number>(\n  (\n    [\n      \"bool\",\n      \"int32\",\n      \"uint32\",\n      \"int64\",\n      \"uint64\",\n      \"float\",\n      \"double\",\n      \"string\",\n    ] as const\n  ).map((str, i) => [str, i]),\n);\n\nconst deduce_numeric_type = (values: number[]): ProtobufAtomic.Numeric =>\n  values.every((v) => Math.floor(v) === v)\n    ? values.every((v) => -2147483648 <= v && v <= 2147483647)\n      ? \"int32\"\n      : \"int64\"\n    : \"double\";\n\nconst decode_bigint = (\n  typeTags: IMetadataTypeTag[][],\n): ProtobufAtomic.BigNumeric[] => {\n  if (typeTags.length === 0) return [\"int64\"];\n\n  const types: Set<ProtobufAtomic.BigNumeric> = new Set();\n  for (const row of typeTags) {\n    const value: ProtobufAtomic.BigNumeric | undefined = row.find(\n      (tag) =>\n        tag.kind === \"type\" &&\n        (tag.value === \"int64\" || tag.value === \"uint64\"),\n    )?.value;\n    types.add(value ?? \"int64\");\n  }\n  return [...types];\n};\n\nconst decode_number = (\n  typeTags: IMetadataTypeTag[][],\n): ProtobufAtomic.Numeric[] => {\n  if (typeTags.length === 0) return [\"double\"];\n\n  const types: Set<ProtobufAtomic.Numeric> = new Set();\n  for (const row of typeTags) {\n    const value: ProtobufAtomic.Numeric | undefined = row.find(\n      (tag) =>\n        tag.kind === \"type\" &&\n        (tag.value === \"int32\" ||\n          tag.value === \"uint32\" ||\n          tag.value === \"int64\" ||\n          tag.value === \"uint64\" ||\n          tag.value === \"float\" ||\n          tag.value === \"double\"),\n    )?.value;\n    types.add(value ?? \"double\");\n  }\n  return [...types];\n};\n"],"mappings":"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","names":["ProtobufUtil","isStaticObject","obj","properties","length","every","p","key","isSoleLiteral","size","meta","getAtomics","arrays","tuples","natives","objects","maps","isUnion","set","Set","templates","add","c","constants","type","deduce_numeric_type","values","map","v","value","atomic","atomics","decode_bigint","tags","forEach","t","decode_number","sort","compare","getNumbers","getBigints","x","y","ATOMIC_ORDER","get","Map","str","i","Math","floor","typeTags","types","row","find","tag","kind"]}