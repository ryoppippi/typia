{"version":3,"sources":["../src/programmers/functional/FunctionalValidateParametersProgrammer.ts","../src/programmers/functional/FunctionalValidateFunctionProgrammer.ts","../src/programmers/functional/FunctionalValidateReturnProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\nimport { FunctionalValidateFunctionProgrammer } from \"./FunctionalValidateFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalValidateParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalValidateFunctionProgrammer.getReturnTypeNode(\n          declaration,\n          async,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...writeStatements(project)(modulo)(equals)(declaration),\n            ts.factory.createReturnStatement(\n              ts.factory.createObjectLiteralExpression(\n                [\n                  ts.factory.createPropertyAssignment(\n                    \"success\",\n                    ts.factory.createTrue(),\n                  ),\n                  ts.factory.createPropertyAssignment(\n                    \"data\",\n                    async ? ts.factory.createAwaitExpression(caller) : caller,\n                  ),\n                  ts.factory.createPropertyAssignment(\n                    \"errors\",\n                    ts.factory.createArrayLiteralExpression([]),\n                  ),\n                ],\n                true,\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (declaration: ts.FunctionDeclaration): ts.Statement[] => {\n      const resultName: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"paramResults\");\n      const validationResultArray: ts.ArrayLiteralExpression =\n        ts.factory.createArrayLiteralExpression(\n          declaration.parameters.map((p) =>\n            ts.factory.createAsExpression(\n              ts.factory.createCallExpression(\n                ValidateProgrammer.write(project)(modulo)(equals)(\n                  project.checker.getTypeFromTypeNode(\n                    p.type ?? TypeFactory.keyword(\"any\"),\n                  ),\n                ),\n                undefined,\n                [ts.factory.createIdentifier(p.name.getText())],\n              ),\n              ts.factory.createImportTypeNode(\n                ts.factory.createLiteralTypeNode(\n                  ts.factory.createStringLiteral(\"typia\"),\n                ),\n                undefined,\n                ts.factory.createQualifiedName(\n                  ts.factory.createIdentifier(\"IValidation\"),\n                  ts.factory.createIdentifier(\"IFailure\"),\n                ),\n                undefined,\n                false,\n              ),\n            ),\n          ),\n          true,\n        );\n      const failures = ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          validationResultArray,\n          \"filter\",\n        ),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [IdentifierFactory.parameter(\"r\")],\n            undefined,\n            undefined,\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(\"r\"),\n                \"success\",\n              ),\n            ),\n          ),\n        ],\n      );\n      const errorMatrix = ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(resultName),\n          \"map\",\n        ),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              IdentifierFactory.parameter(\"r\"),\n              IdentifierFactory.parameter(\"i\"),\n            ],\n            undefined,\n            undefined,\n            FunctionalValidateFunctionProgrammer.hookErrors({\n              expression: ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(\"r\"),\n                \"errors\",\n              ),\n              replacer: ts.factory.createTemplateExpression(\n                ts.factory.createTemplateHead(\"$input.parameters[\"),\n                [\n                  ts.factory.createTemplateSpan(\n                    ts.factory.createIdentifier(\"i\"),\n                    ts.factory.createTemplateTail(\"]\"),\n                  ),\n                ],\n              ),\n            }),\n          ),\n        ],\n      );\n      return [\n        StatementFactory.constant(resultName, failures),\n        ts.factory.createIfStatement(\n          ts.factory.createBinaryExpression(\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(resultName),\n              \"length\",\n            ),\n            ts.SyntaxKind.GreaterThanToken,\n            ts.factory.createNumericLiteral(\"0\"),\n          ),\n          ts.factory.createReturnStatement(\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"success\",\n                  ts.factory.createFalse(),\n                ),\n                ts.factory.createPropertyAssignment(\n                  \"errors\",\n                  ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      errorMatrix,\n                      \"flat\",\n                    ),\n                    undefined,\n                    undefined,\n                  ),\n                ),\n              ],\n              true,\n            ),\n          ),\n        ),\n      ];\n    };\n}\n","import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionalValidateParametersProgrammer } from \"./FunctionalValidateParametersProgrammer\";\nimport { FunctionalValidateReturnProgrammer } from \"./FunctionalValidateReturnProgrammer\";\n\nexport namespace FunctionalValidateFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } =\n        FunctionalValidateReturnProgrammer.writeStatements(project)(modulo)(\n          equals,\n        )(expression, declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...FunctionalValidateParametersProgrammer.writeStatements(project)(\n              modulo,\n            )(equals)(declaration),\n            ...statements,\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const hookErrors = (props: {\n    expression: ts.Expression;\n    replacer: ts.Expression;\n  }): ts.CallExpression =>\n    ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(props.expression, \"map\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [IdentifierFactory.parameter(\"error\")],\n          undefined,\n          undefined,\n          ts.factory.createObjectLiteralExpression(\n            [\n              ts.factory.createSpreadAssignment(\n                ts.factory.createIdentifier(\"error\"),\n              ),\n              ts.factory.createPropertyAssignment(\n                \"path\",\n                ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(\"error\"),\n                      \"path\",\n                    ),\n                    \"replace\",\n                  ),\n                  undefined,\n                  [ts.factory.createStringLiteral(\"$input\"), props.replacer],\n                ),\n              ),\n            ],\n            true,\n          ),\n        ),\n      ],\n    );\n\n  export const getReturnTypeNode = (\n    declaration: ts.FunctionDeclaration,\n    async: boolean,\n  ): ts.TypeNode | undefined =>\n    declaration.type\n      ? async\n        ? !!(declaration.type! as ts.TypeReferenceNode).typeArguments?.[0]\n          ? ts.factory.createTypeReferenceNode(\"Promise\", [\n              ts.factory.createImportTypeNode(\n                ts.factory.createLiteralTypeNode(\n                  ts.factory.createStringLiteral(\"typia\"),\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"IValidation\"),\n                [\n                  (declaration.type! as ts.TypeReferenceNode)\n                    .typeArguments![0]!,\n                ],\n              ),\n            ])\n          : undefined\n        : ts.factory.createImportTypeNode(\n            ts.factory.createLiteralTypeNode(\n              ts.factory.createStringLiteral(\"typia\"),\n            ),\n            undefined,\n            ts.factory.createIdentifier(\"IValidation\"),\n            [declaration.type],\n          )\n      : undefined;\n}\n","import ts from \"typescript\";\n\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\nimport { FunctionalValidateFunctionProgrammer } from \"./FunctionalValidateFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalValidateReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } = writeStatements(project)(modulo)(equals)(\n        expression,\n        declaration,\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalValidateFunctionProgrammer.getReturnTypeNode(\n          declaration,\n          async,\n        ),\n        undefined,\n        ts.factory.createBlock(statements, true),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): {\n      async: boolean;\n      statements: ts.Statement[];\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n\n      const name: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"result\");\n      const statements: ts.Statement[] = [\n        StatementFactory.constant(\n          name,\n          ts.factory.createCallExpression(\n            ValidateProgrammer.write(project)(modulo)(equals)(type),\n            undefined,\n            [async ? ts.factory.createAwaitExpression(caller) : caller],\n          ),\n        ),\n        ts.factory.createIfStatement(\n          ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.ExclamationToken,\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(name),\n              ts.factory.createIdentifier(\"success\"),\n            ),\n          ),\n          ts.factory.createExpressionStatement(\n            ts.factory.createBinaryExpression(\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(name),\n                ts.factory.createIdentifier(\"errors\"),\n              ),\n              ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n              FunctionalValidateFunctionProgrammer.hookErrors({\n                expression: ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(name),\n                  ts.factory.createIdentifier(\"errors\"),\n                ),\n                replacer: ts.factory.createStringLiteral(\"$input.return\"),\n              }),\n            ),\n          ),\n        ),\n        ts.factory.createReturnStatement(ts.factory.createIdentifier(\"result\")),\n      ];\n      return {\n        async,\n        statements,\n      };\n    };\n}\n"],"mappings":"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","names":["ts","ts","ts","FunctionalValidateReturnProgrammer","write","project","modulo","equals","expression","declaration","async","statements","writeStatements","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","FunctionalValidateFunctionProgrammer","getReturnTypeNode","createBlock","type","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","name","getText","StringUtil","escapeDuplicate","StatementFactory","constant","ValidateProgrammer","createAwaitExpression","createIfStatement","createPrefixUnaryExpression","ExclamationToken","createPropertyAccessExpression","createExpressionStatement","createBinaryExpression","createToken","EqualsToken","hookErrors","replacer","createStringLiteral","createReturnStatement","FunctionalValidateFunctionProgrammer","write","project","modulo","equals","expression","declaration","async","statements","FunctionalValidateReturnProgrammer","writeStatements","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","getReturnTypeNode","createBlock","FunctionalValidateParametersProgrammer","hookErrors","props","createCallExpression","createPropertyAccessExpression","IdentifierFactory","parameter","createObjectLiteralExpression","createSpreadAssignment","createIdentifier","createPropertyAssignment","createStringLiteral","replacer","type","typeArguments","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","FunctionalValidateParametersProgrammer","write","project","modulo","equals","expression","declaration","async","FunctionalGeneralProgrammer","getReturnType","checker","caller","ts","factory","createCallExpression","undefined","parameters","map","p","createIdentifier","name","getText","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","FunctionalValidateFunctionProgrammer","getReturnTypeNode","createBlock","writeStatements","createReturnStatement","createObjectLiteralExpression","createPropertyAssignment","createTrue","createAwaitExpression","createArrayLiteralExpression","resultName","StringUtil","escapeDuplicate","validationResultArray","createAsExpression","ValidateProgrammer","getTypeFromTypeNode","type","TypeFactory","keyword","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createQualifiedName","failures","createPropertyAccessExpression","IdentifierFactory","parameter","createStrictEquality","createFalse","errorMatrix","hookErrors","replacer","createTemplateExpression","createTemplateHead","createTemplateSpan","createTemplateTail","StatementFactory","constant","createIfStatement","createBinaryExpression","GreaterThanToken","createNumericLiteral"]}