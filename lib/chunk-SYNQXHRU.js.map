{"version":3,"sources":["../src/factories/NumericRangeFactory.ts"],"names":["ts","NumericRangeFactory","number","type","input","NumberPredicator","bigint","BigIntPredicator","int32","factory","createLogicalAnd","integer","between","uint32","int64","uint64","float","double","createTrue","createLessThanEquals","createCallExpression","createIdentifier","undefined","ExpressionFactory","createStrictEquality","x","y"],"mappings":";;;;;;;;AAAA,OAAOA,QAAQ;;UAMEC,sBAAAA;uBACFC,SACX,CAACC,SACD,CAACC,UACCC,iBAAiBF,IAAAA,EAAMC,KAAAA;uBAEdE,SACX,CAACH,SACD,CAACC,UACCG,iBAAiBJ,IAAAA,EAAMC,KAAAA;AAC7B,GAViBH,wBAAAA,sBAAAA,CAAAA,EAAAA;;UAYPI,mBAAAA;oBACKG,QAAQ,CAACJ,UACpBJ,GAAGS,QAAQC,iBACTC,QAAQP,KAAAA,GACRQ,QAAQ,eAAe,YAAA,EAAcR,KAAAA,CAAAA;oBAE5BS,SAAS,CAACT,UACrBJ,GAAGS,QAAQC,iBACTC,QAAQP,KAAAA,GACRQ,QAAQ,KAAK,YAAA,EAAcR,KAAAA,CAAAA;oBAElBU,QAAQ,CAACV,UACpBJ,GAAGS,QAAQC,iBACTC,QAAQP,KAAAA,GACRQ,QAAQ,wBAAwB,qBAAA,EAAuBR,KAAAA,CAAAA;oBAE9CW,SAAS,CAACX,UACrBJ,GAAGS,QAAQC,iBACTC,QAAQP,KAAAA,GACRQ,QAAQ,KAAK,sBAAA,EAAwBR,KAAAA,CAAAA;oBAE5BY,QAAQ,CAACZ,UACpBQ,QAAQ,mBAAmB,cAAA,EAAgBR,KAAAA;oBAChCa,SAAS,MAAMjB,GAAGS,QAAQS,WAAU;AACnD,GAxBUb,qBAAAA,mBAAAA,CAAAA,EAAAA;;UA0BAE,mBAAAA;oBACKO,QAAQ,MAAMd,GAAGS,QAAQS,WAAU;oBACnCH,SAAS,CAACX,UACrBJ,GAAGS,QAAQU,qBACTnB,GAAGS,QAAQW,qBACTpB,GAAGS,QAAQY,iBAAiB,QAAA,GAC5BC,QACA;IAACC,kBAAkBrB,OAAO,CAAA;GAAG,GAE/BE,KAAAA;AAEN,GAXUG,qBAAAA,mBAAAA,CAAAA,EAAAA;AAaV,IAAMI,UAAU,wBAACP,UACfJ,GAAGS,QAAQe,qBACTxB,GAAGS,QAAQW,qBACTpB,GAAGS,QAAQY,iBAAiB,YAAA,GAC5BC,QACA;EAAClB;CAAM,GAETA,KAAAA,GAPY;AAUhB,IAAMQ,UAAU,wBAACa,GAAWC,MAAc,CAACtB,UACzCJ,GAAGS,QAAQC,iBACTV,GAAGS,QAAQU,qBAAqBnB,GAAGS,QAAQY,iBAAiBI,CAAAA,GAAIrB,KAAAA,GAChEJ,GAAGS,QAAQU,qBAAqBf,OAAOJ,GAAGS,QAAQY,iBAAiBK,CAAAA,CAAAA,CAAAA,GAHvD","sourcesContent":["import ts from \"typescript\";\n\nimport { ProtobufAtomic } from \"../typings/ProtobufAtomic\";\n\nimport { ExpressionFactory } from \"./ExpressionFactory\";\n\nexport namespace NumericRangeFactory {\n  export const number =\n    (type: ProtobufAtomic.Numeric) =>\n    (input: ts.Expression): ts.Expression =>\n      NumberPredicator[type](input);\n\n  export const bigint =\n    (type: ProtobufAtomic.BigNumeric) =>\n    (input: ts.Expression): ts.Expression =>\n      BigIntPredicator[type](input);\n}\n\nnamespace NumberPredicator {\n  export const int32 = (input: ts.Expression) =>\n    ts.factory.createLogicalAnd(\n      integer(input),\n      between(\"-2147483648\", \"2147483647\")(input),\n    );\n  export const uint32 = (input: ts.Expression) =>\n    ts.factory.createLogicalAnd(\n      integer(input),\n      between(\"0\", \"4294967295\")(input),\n    );\n  export const int64 = (input: ts.Expression) =>\n    ts.factory.createLogicalAnd(\n      integer(input),\n      between(\"-9223372036854775808\", \"9223372036854775807\")(input),\n    );\n  export const uint64 = (input: ts.Expression) =>\n    ts.factory.createLogicalAnd(\n      integer(input),\n      between(\"0\", \"18446744073709551615\")(input),\n    );\n  export const float = (input: ts.Expression) =>\n    between(\"-1.175494351e38\", \"3.4028235e38\")(input);\n  export const double = () => ts.factory.createTrue();\n}\n\nnamespace BigIntPredicator {\n  export const int64 = () => ts.factory.createTrue();\n  export const uint64 = (input: ts.Expression) =>\n    ts.factory.createLessThanEquals(\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\"BigInt\"),\n        undefined,\n        [ExpressionFactory.number(0)],\n      ),\n      input,\n    );\n}\n\nconst integer = (input: ts.Expression) =>\n  ts.factory.createStrictEquality(\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"Math.floor\"),\n      undefined,\n      [input],\n    ),\n    input,\n  );\n\nconst between = (x: string, y: string) => (input: ts.Expression) =>\n  ts.factory.createLogicalAnd(\n    ts.factory.createLessThanEquals(ts.factory.createIdentifier(x), input),\n    ts.factory.createLessThanEquals(input, ts.factory.createIdentifier(y)),\n  );\n"]}