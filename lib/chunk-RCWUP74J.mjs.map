{"version":3,"sources":["../src/factories/MetadataTypeTagFactory.ts"],"sourcesContent":["import { IMetadataTypeTag } from \"../schemas/metadata/IMetadataTypeTag\";\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../schemas/metadata/MetadataProperty\";\n\nimport { MetadataFactory } from \"./MetadataFactory\";\nimport { MetadataTypeTagSchemaFactory } from \"./MetadataTypeTagSchemaFactory\";\n\nexport namespace MetadataTypeTagFactory {\n  export const analyze =\n    (errors: MetadataFactory.IError[]) =>\n    (type: \"boolean\" | \"bigint\" | \"number\" | \"string\" | \"array\") =>\n    (\n      objects: MetadataObject[],\n      explore: MetadataFactory.IExplore,\n    ): IMetadataTypeTag[] => {\n      const messages: string[] = [];\n      const report =\n        (property: string | null) =>\n        (msg: string): false => {\n          messages.push(\n            `the property ${\n              property === null ? `[\"typia.tag\"]` : `[\"typia.tag.${property}\"]`\n            } ${msg}.`,\n          );\n          return false;\n        };\n\n      //----\n      // VALIDATION PROCESS\n      //----\n      const filtered: MetadataObject[] = objects.filter((obj) => {\n        // ONLY ONE PROPERTY\n        if (obj.properties.length !== 1) return false;\n\n        // THE TAG.TYPE PROPERTY MUST BE\n        const top: MetadataProperty = obj.properties[0]!;\n        if (\n          top.key.getSoleLiteral() !== \"typia.tag\" ||\n          top.value.size() !== 1 ||\n          top.value.objects.length !== 1\n        )\n          return false;\n        else if (top.value.optional === false)\n          return report(null)(\"must be optional object\");\n\n        // CHECK LIST OF PROPERTIES\n        const tag: MetadataObject = top.value.objects[0]!;\n        const statics: string[] = tag.properties\n          .map((p) => p.key.getSoleLiteral()!)\n          .filter((str) => str !== null);\n        if (ESSENTIAL_FIELDS.some((f) => !statics.includes(f)))\n          return report(null)(\n            `must have at least three properties - ${ESSENTIAL_FIELDS.map(\n              (str) => `'${str}'`,\n            ).join(\", \")}`,\n          );\n\n        const each: boolean[] = tag.properties.map((p) => {\n          const key: string | null = p.key.getSoleLiteral();\n          if (key === null) return true;\n          else if (FIELDS.includes(key) === false) return true;\n          return validate_property(report)(key, p.value);\n        });\n        return each.every((v) => v === true);\n      });\n      if (filtered.length === 0) return [];\n\n      //----\n      // CONSTRUCT TYPE TAGS\n      //----\n      // CREATE 1ST\n      const tagList: Array<ITypeTag | null> = filtered.map(\n        create_metadata_type_tag(report),\n      );\n\n      const output: IMetadataTypeTag[] = [];\n      for (const tag of tagList)\n        if (tag !== null)\n          output.push({\n            target: tag.target.some((str) => str === type) ? type : null!,\n            name: tag.name,\n            kind: tag.kind,\n            value: tag.value,\n            validate: tag.validate[type]!,\n            exclusive: tag.exclusive,\n            schema: tag.schema,\n          });\n      validate(report)(type)(output);\n\n      if (messages.length > 0) {\n        errors.push({\n          name: [type, ...objects.map((o) => o.name)].join(\" & \"),\n          explore,\n          messages,\n        });\n        return [];\n      }\n      return output;\n    };\n\n  export const validate =\n    (report: (property: string | null) => (msg: string) => false) =>\n    (type: \"boolean\" | \"bigint\" | \"number\" | \"string\" | \"array\") =>\n    (tagList: IMetadataTypeTag[]): boolean => {\n      let success: boolean = true;\n      for (const tag of tagList)\n        if (tag.target !== type) {\n          success &&= report(null)(`target must constains ${type} type`);\n        }\n\n      tagList.forEach((tag, i) => {\n        if (tag.exclusive === false) return;\n        else if (tag.exclusive === true) {\n          const some: boolean = tagList.some(\n            (opposite, j) => i !== j && opposite.kind === tag.kind,\n          );\n          if (some === true)\n            success &&= report(null)(`kind '${tag.kind}' can't be duplicated`);\n        } else if (Array.isArray(tag.exclusive)) {\n          const some: IMetadataTypeTag | undefined = tagList.find(\n            (opposite, j) =>\n              i !== j &&\n              opposite.kind === tag.kind &&\n              (tag.exclusive as string[]).includes(opposite.name),\n          );\n          if (some !== undefined)\n            success ??= report(null)(\n              `kind '${tag.kind}' can't be used with '${some.name}'`,\n            );\n        }\n      });\n      return success;\n    };\n\n  const validate_property =\n    (report: (property: string | null) => (msg: string) => false) =>\n    (key: string, value: Metadata): boolean => {\n      if (\n        // TARGET\n        key === \"target\" &&\n        (value.constants.length !== 1 ||\n          value.constants[0]!.values.length !== value.size() ||\n          value.constants[0]!.values.some(\n            (v) =>\n              v.value !== \"boolean\" &&\n              v.value !== \"bigint\" &&\n              v.value !== \"number\" &&\n              v.value !== \"string\" &&\n              v.value !== \"array\",\n          ))\n      )\n        return report(key)(\n          `must be one of 'boolean', 'bigint', 'number', 'string', 'array'`,\n        );\n      else if (\n        // KIND\n        key === \"kind\" &&\n        (value.size() !== 1 ||\n          value.constants.length !== 1 ||\n          value.constants[0]!.type !== \"string\" ||\n          value.constants[0]!.values.length !== 1)\n      )\n        return report(key)(\"must be a string literal type\");\n      else if (\n        // VALUE\n        key === \"value\" &&\n        (value.size() > 1 ||\n          (value.size() !== 0 &&\n            (value.constants.length !== 1 ||\n              value.constants[0]!.values.length !== 1)))\n      )\n        return report(key)(\n          \"must be a constant literal type or undefined value\",\n        );\n      else if (key === \"exclusive\")\n        return get_exclusive(report)(key)(value) !== null;\n      else if (key === \"validate\") {\n        //----\n        // VALIDATE\n        //----\n        // UNDEFINED CASE\n        if (\n          value.size() === 0 &&\n          value.isRequired() === false &&\n          value.nullable === false\n        )\n          return true;\n\n        // STRING CASE\n        if (\n          value.size() === 1 &&\n          value.constants.length === 1 &&\n          value.constants[0]!.type === \"string\" &&\n          (value.constants[0]!.values.length === 1) === true\n        )\n          return true;\n\n        // RECORD<TARGET, STRING>\n        const target: string[] | undefined = value.objects[0]?.properties\n          .map((p) => p.key.getSoleLiteral()!)\n          .filter((str) => str !== null) as string[] | undefined;\n        if (target === undefined)\n          return report(\"target\")(\n            `must be one of 'boolean', 'bigint', 'number', 'string', 'array'`,\n          );\n        const variadic: boolean =\n          value.size() === 1 &&\n          value.objects.length === 1 &&\n          value.objects[0]!.properties.every(\n            (vp) =>\n              vp.value.size() === 1 &&\n              vp.value.isRequired() &&\n              vp.value.nullable === false &&\n              vp.value.constants.length === 1 &&\n              vp.value.constants[0]!.type === \"string\" &&\n              vp.value.constants[0]!.values.length === 1 &&\n              target.includes(vp.key.getSoleLiteral()!),\n          );\n        if (variadic === false)\n          return report(key)(\n            `must be a string literal type or Record<Target, string> type.`,\n          );\n      }\n      return true;\n    };\n\n  const create_metadata_type_tag =\n    (report: (property: string | null) => (msg: string) => false) =>\n    (obj: MetadataObject): ITypeTag | null => {\n      const find = (key: string): MetadataProperty | undefined =>\n        obj.properties[0]?.value.objects[0]?.properties.find(\n          (p) => p.key.getSoleLiteral() === key,\n        );\n\n      const target = find(\"target\")!.value.constants[0]!.values.map(\n        (v) => v.value,\n      ) as ITypeTag[\"target\"];\n      const kind: string = find(\"kind\")!.value.constants[0]!.values[0]!\n        .value as string;\n      const value: boolean | bigint | number | string | undefined =\n        find(\"value\")?.value.constants[0]?.values[0]!.value;\n      const exclusive: string[] | boolean | null = get_exclusive(report)(\n        \"exclusive\",\n      )(find(\"exclusive\")?.value);\n      if (exclusive === null) return null;\n\n      const validate: Record<string, string> = (() => {\n        const validate = find(\"validate\")?.value;\n        if (!validate || validate.size() === 0) return {};\n        else if (validate.constants.length)\n          return Object.fromEntries(\n            target.map((t) => [\n              t,\n              validate.constants[0]!.values[0]!.value as string,\n            ]),\n          );\n        return Object.fromEntries(\n          validate.objects[0]!.properties.map((p) => [\n            p.key.getSoleLiteral()!,\n            p.value.constants[0]!.values[0]!.value as string,\n          ]),\n        );\n      })();\n      const schema: object | undefined = (() => {\n        const p: Metadata | undefined = find(\"schema\")?.value;\n        if (p === undefined) return undefined;\n        else if (p.size() === 0 && p.isRequired() === false) return undefined;\n        else if (\n          p.size() === 1 &&\n          p.nullable === false &&\n          p.isRequired() === true &&\n          p.any === false\n        )\n          return MetadataTypeTagSchemaFactory.object((msg) =>\n            report(\"schema\")(msg),\n          )(p.objects[0]!);\n        report(\"schema\")(\"must be an object type\");\n        return undefined;\n      })();\n      return {\n        name: obj.name,\n        target,\n        kind,\n        value,\n        validate,\n        exclusive: exclusive ?? false,\n        schema,\n      };\n    };\n\n  const get_exclusive =\n    (report: (property: string | null) => (msg: string) => false) =>\n    (key: string) =>\n    (value: Metadata | undefined): boolean | string[] | null => {\n      if (value === undefined) return false;\n      else if (\n        value.size() === 1 &&\n        value.constants.length === 1 &&\n        value.constants[0]!.type === \"boolean\" &&\n        value.constants[0]!.values.length === 1\n      )\n        return value.constants[0]!.values[0]!.value as boolean;\n      else if (\n        value.size() === 1 &&\n        value.tuples.length === 1 &&\n        value.tuples[0]!.type.elements.every(\n          (elem) =>\n            elem.size() === 1 &&\n            elem.constants.length === 1 &&\n            elem.constants[0]!.type === \"string\" &&\n            elem.constants[0]!.values.length === 1,\n        )\n      )\n        return value.tuples[0]!.type.elements.map(\n          (elem) => elem.constants[0]!.values[0]!.value as string,\n        );\n      report(key)(\n        \"must a boolean literal type or a tuple of string literal types.\",\n      );\n      return null;\n    };\n}\n\ninterface ITypeTag {\n  name: string;\n  target: Array<\"bigint\" | \"number\" | \"string\" | \"array\">;\n  kind: string;\n  value?: undefined | boolean | bigint | number | string;\n  validate: Record<string, string>;\n  exclusive: boolean | string[];\n  schema?: undefined | any;\n}\n\nconst ESSENTIAL_FIELDS = [\"target\", \"kind\", \"value\"];\nconst FIELDS = [...ESSENTIAL_FIELDS, \"validate\", \"exclusive\"];\n"],"mappings":"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","names":["MetadataTypeTagFactory","analyze","errors","type","objects","explore","messages","report","property","msg","push","filtered","filter","obj","properties","length","top","key","getSoleLiteral","value","size","optional","tag","statics","map","p","str","ESSENTIAL_FIELDS","some","f","includes","join","each","FIELDS","validate_property","every","v","tagList","create_metadata_type_tag","output","target","name","kind","validate","exclusive","schema","o","success","forEach","i","opposite","j","Array","isArray","find","undefined","constants","values","get_exclusive","isRequired","nullable","variadic","vp","Object","fromEntries","t","any","MetadataTypeTagSchemaFactory","object","tuples","elements","elem"]}