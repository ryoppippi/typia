{"version":3,"sources":["../src/factories/TemplateFactory.ts"],"names":["ts","TemplateFactory","generate","expressions","every","exp","isStringLiteral","factory","createStringLiteral","map","str","text","join","it","value","index","gather","head","createTemplateHead","spans","elem","broken","length","push","createTemplateSpan","createTemplateTail","createTemplateMiddle","createTemplateExpression","found","findIndex","last","slice","reduce","x","y"],"mappings":";;;;;AAAA,OAAOA,QAAQ;;UAEEC,kBAAAA;mBACFC,WAAW,CAACC,gBAAAA;AACvB,QAAIA,YAAYC,MAAM,CAACC,QAAQL,GAAGM,gBAAgBD,GAAAA,CAAAA,EAChD,QAAOL,GAAGO,QAAQC,oBACfL,YAAmCM,IAAI,CAACC,QAAQA,IAAIC,IAAI,EAAEC,KAAK,EAAA,CAAA;AAGpE,UAAMC,KAAgB;MACpBC,OAAO;MACPC,OAAO;IACT;AACAC,WAAOb,WAAAA,EAAaU,EAAAA;AAEpB,UAAMI,OAAwBjB,GAAGO,QAAQW,mBAAmBL,GAAGC,KAAK;AACpE,UAAMK,QAA2B,CAAA;AAEjC,WAAO,MAAM;AACX,YAAMC,OAAsBjB,YAAYU,GAAGE,OAAK;AAChDC,aAAOb,WAAAA,EAAaU,EAAAA;AAEpB,YAAMQ,SAAkBR,GAAGE,UAAUZ,YAAYmB;AACjDH,YAAMI,KACJvB,GAAGO,QAAQiB,mBACTJ,MACAC,SACIrB,GAAGO,QAAQkB,mBAAmBZ,GAAGC,KAAK,IACtCd,GAAGO,QAAQmB,qBAAqBb,GAAGC,KAAK,CAAA,CAAA;AAGhD,UAAIO,WAAW,KAAM;IACvB;AACA,WAAOrB,GAAGO,QAAQoB,yBAAyBV,MAAME,KAAAA;EACnD;AAEA,QAAMH,SACJ,wBAACb,gBACD,CAACU,OAAAA;AACC,UAAMe,QAAgBzB,YAAY0B,UAChC,CAACT,MAAML,UAAUA,SAASF,GAAGE,SAAS,CAACf,GAAGM,gBAAgBc,IAAAA,CAAAA;AAG5D,UAAMU,OAAeF,UAAU,KAAKA,QAAQzB,YAAYmB;AACxDT,OAAGC,QAAQX,YACR4B,MAAMlB,GAAGE,OAAOe,IAAAA,EAChBrB,IAAI,CAACW,SAAUA,KAA0BT,IAAI,EAC7CqB,OAAO,CAACC,GAAGC,MAAMD,IAAIC,GAAG,EAAA;AAC3BrB,OAAGE,QAAQe;EACb,GAZA;AAkBJ,GArDiB7B,oBAAAA,kBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nexport namespace TemplateFactory {\n  export const generate = (expressions: ts.Expression[]): ts.Expression => {\n    if (expressions.every((exp) => ts.isStringLiteral(exp)))\n      return ts.factory.createStringLiteral(\n        (expressions as ts.StringLiteral[]).map((str) => str.text).join(\"\"),\n      );\n\n    const it: IIterator = {\n      value: \"\",\n      index: 0,\n    };\n    gather(expressions)(it);\n\n    const head: ts.TemplateHead = ts.factory.createTemplateHead(it.value);\n    const spans: ts.TemplateSpan[] = [];\n\n    while (true) {\n      const elem: ts.Expression = expressions[it.index++]!;\n      gather(expressions)(it);\n\n      const broken: boolean = it.index === expressions.length;\n      spans.push(\n        ts.factory.createTemplateSpan(\n          elem,\n          broken\n            ? ts.factory.createTemplateTail(it.value)\n            : ts.factory.createTemplateMiddle(it.value),\n        ),\n      );\n      if (broken === true) break;\n    }\n    return ts.factory.createTemplateExpression(head, spans);\n  };\n\n  const gather =\n    (expressions: ts.Expression[]) =>\n    (it: IIterator): void => {\n      const found: number = expressions.findIndex(\n        (elem, index) => index >= it.index && !ts.isStringLiteral(elem),\n      );\n\n      const last: number = found !== -1 ? found : expressions.length;\n      it.value = expressions\n        .slice(it.index, last)\n        .map((elem) => (elem as ts.StringLiteral).text)\n        .reduce((x, y) => x + y, \"\");\n      it.index = last;\n    };\n\n  interface IIterator {\n    value: string;\n    index: number;\n  }\n}\n"]}