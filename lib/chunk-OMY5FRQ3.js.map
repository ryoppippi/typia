{"version":3,"sources":["../src/factories/ProtobufFactory.ts"],"names":["ProtobufFactory","metadata","method","checker","context","collection","type","result","MetadataFactory","analyze","escape","constant","absorb","validate","success","TransformerError","from","errors","data","meta","explore","insert","msg","push","top","onlyObject","size","objects","length","properties","every","p","key","isSoleLiteral","isRequired","nullable","noSupport","any","functional","tuples","sets","natives","native","instead","BANNED_NATIVE_TYPES","get","undefined","atomics","numbers","ProtobufUtil","getNumbers","bigints","getBigints","some","n","b","arrays","array","value","a","constants","values","maps","o","isStaticObject","obj","filter","Escaper","variable","getSoleLiteral","isDynamicObject","isUnion","m","getAtomics","Map","map","name"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\n\nimport { ProtobufUtil } from \"../programmers/helpers/ProtobufUtil\";\n\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { ValidationPipe } from \"../typings/ValidationPipe\";\n\nimport { Escaper } from \"../utils/Escaper\";\n\nimport { MetadataCollection } from \"./MetadataCollection\";\nimport { MetadataFactory } from \"./MetadataFactory\";\n\nexport namespace ProtobufFactory {\n  export const metadata =\n    (method: string) =>\n    (checker: ts.TypeChecker, context?: ts.TransformationContext) =>\n    (collection: MetadataCollection) =>\n    (type: ts.Type): Metadata => {\n      // COMPOSE METADATA WITH INDIVIDUAL VALIDATIONS\n      const result: ValidationPipe<Metadata, MetadataFactory.IError> =\n        MetadataFactory.analyze(\n          checker,\n          context,\n        )({\n          escape: false,\n          constant: true,\n          absorb: true,\n          validate,\n        })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.protobuf.${method}`)(result.errors);\n      return result.data;\n    };\n\n  const validate = (\n    meta: Metadata,\n    explore: MetadataFactory.IExplore,\n  ): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (explore.top === true) {\n      const onlyObject: boolean =\n        meta.size() === 1 &&\n        meta.objects.length === 1 &&\n        meta.objects[0]!.properties.every((p) => p.key.isSoleLiteral()) &&\n        meta.isRequired() === true &&\n        meta.nullable === false;\n      if (onlyObject === false)\n        insert(\"target type must be a sole and static object type\");\n    }\n\n    //----\n    // NOT SUPPORTED TYPES\n    //----\n    const noSupport = (msg: string) => insert(`does not support ${msg}`);\n\n    // PROHIBIT ANY TYPE\n    if (meta.any) noSupport(\"any type\");\n    // PROHIBIT FUNCTIONAL TYPE\n    if (meta.functional) noSupport(\"functional type\");\n    // PROHIBIT TUPLE TYPE\n    if (meta.tuples.length) noSupport(\"tuple type\");\n    // PROHIBIT SET TYPE\n    if (meta.sets.length) noSupport(\"Set type\");\n    // NATIVE TYPE, BUT NOT Uint8Array\n    if (meta.natives.length)\n      for (const native of meta.natives) {\n        if (native === \"Uint8Array\") continue;\n\n        const instead = BANNED_NATIVE_TYPES.get(native);\n        if (instead === undefined) noSupport(`${native} type`);\n        else noSupport(`${native} type. Use ${instead} type instead.`);\n      }\n    //----\n    // ATOMIC CASES\n    //----\n    if (meta.atomics.length) {\n      const numbers = ProtobufUtil.getNumbers(meta);\n      const bigints = ProtobufUtil.getBigints(meta);\n\n      for (const type of [\"int64\", \"uint64\"])\n        if (numbers.some((n) => n === type) && bigints.some((b) => b === type))\n          insert(\n            `tags.Type<\"${type}\"> cannot be used in both number and bigint types. Recommend to remove from number type`,\n          );\n    }\n    //----\n    // ARRRAY CASES\n    //----\n    // DO NOT ALLOW MULTI-DIMENTIONAL ARRAY\n    if (\n      meta.arrays.length &&\n      meta.arrays.some((array) => !!array.type.value.arrays.length)\n    )\n      noSupport(\"over two dimenstional array type\");\n    // CHILD OF ARRAY TYPE MUST BE REQUIRED\n    if (\n      meta.arrays.length &&\n      meta.arrays.some(\n        (array) =>\n          array.type.value.isRequired() === false ||\n          array.type.value.nullable === true,\n      )\n    )\n      noSupport(\"optional type in array\");\n    // UNION IN ARRAY\n    if (\n      meta.arrays.length &&\n      meta.arrays.some(\n        (a) =>\n          a.type.value.size() > 1 &&\n          a.type.value.constants.length !== 1 &&\n          a.type.value.constants[0]?.values.length !== a.type.value.size(),\n      )\n    )\n      noSupport(\"union type in array\");\n    // DO DYNAMIC OBJECT IN ARRAY\n    if (\n      meta.arrays.length &&\n      meta.arrays.some(\n        (a) =>\n          a.type.value.maps.length ||\n          (a.type.value.objects.length &&\n            a.type.value.objects.some(\n              (o) => ProtobufUtil.isStaticObject(o) === false,\n            )),\n      )\n    )\n      noSupport(\"dynamic object in array\");\n    // UNION WITH ARRAY\n    if (meta.size() > 1 && meta.arrays.length)\n      noSupport(\"union type with array type\");\n    //----\n    // OBJECT CASES\n    //----\n    // EMPTY PROPERTY\n    if (\n      meta.objects.length &&\n      meta.objects.some((obj) => obj.properties.length === 0)\n    )\n      noSupport(\"empty object type\");\n    // MULTIPLE DYNAMIC KEY TYPED PROPERTIES\n    if (\n      meta.objects.length &&\n      meta.objects.some(\n        (obj) =>\n          obj.properties.filter((p) => !p.key.isSoleLiteral()).length > 1,\n      )\n    )\n      noSupport(\n        \"object type with multiple dynamic key typed properties. Keep only one.\",\n      );\n    // STATIC AND DYNAMIC PROPERTIES ARE COMPATIBLE\n    if (\n      meta.objects.length &&\n      meta.objects.some(\n        (obj) =>\n          obj.properties.some((p) => p.key.isSoleLiteral()) &&\n          obj.properties.some((p) => !p.key.isSoleLiteral()),\n      )\n    )\n      noSupport(\n        \"object type with mixed static and dynamic key typed properties. Keep statics or dynamic only.\",\n      );\n    // STATIC PROPERTY, BUT INVALID KEY NAME\n    if (\n      meta.objects.length &&\n      meta.objects.some((obj) =>\n        obj.properties.some(\n          (p) =>\n            p.key.isSoleLiteral() === true &&\n            Escaper.variable(p.key.getSoleLiteral()!) === false,\n        ),\n      )\n    )\n      noSupport(`object type with invalid static key name.`);\n    // DYNAMIC OBJECT, BUT PROPERTY VALUE TYPE IS ARRAY\n    if (\n      meta.objects.length &&\n      isDynamicObject(meta.objects[0]!) &&\n      meta.objects[0]!.properties.some((p) => !!p.value.arrays.length)\n    )\n      noSupport(\"dynamic object with array value type\");\n    // UNION WITH DYNAMIC OBJECT\n    if (\n      meta.size() > 1 &&\n      meta.objects.length &&\n      isDynamicObject(meta.objects[0]!)\n    )\n      noSupport(\"union type with dynamic object type\");\n    // UNION IN DYNAMIC PROPERTY VALUE\n    if (\n      meta.objects.length &&\n      meta.objects.some(\n        (obj) =>\n          isDynamicObject(obj) &&\n          obj.properties.some((p) => ProtobufUtil.isUnion(p.value)),\n      )\n    )\n      noSupport(\"union type in dynamic property\");\n    //----\n    // MAP CASES\n    //----\n    // KEY TYPE IS UNION\n    if (meta.maps.length && meta.maps.some((m) => ProtobufUtil.isUnion(m.key)))\n      noSupport(\"union key typed map\");\n    // KEY TYPE IS NOT ATOMIC\n    if (\n      meta.maps.length &&\n      meta.maps.some((m) => ProtobufUtil.getAtomics(m.key).length !== 1)\n    )\n      noSupport(\"non-atomic key typed map\");\n    // MAP TYPE, BUT PROPERTY KEY TYPE IS OPTIONAL\n    if (\n      meta.maps.length &&\n      meta.maps.some((m) => m.key.isRequired() === false || m.key.nullable)\n    )\n      noSupport(\"optional key typed map\");\n    // MAP TYPE, BUT VALUE TYPE IS ARRAY\n    if (meta.maps.length && meta.maps.some((m) => !!m.value.arrays.length))\n      noSupport(\"map type with array value type\");\n    // UNION WITH MAP\n    if (meta.size() > 1 && meta.maps.length)\n      noSupport(\"union type with map type\");\n    // UNION IN MAP\n    if (\n      meta.maps.length &&\n      meta.maps.some((m) => ProtobufUtil.isUnion(m.value))\n    )\n      noSupport(\"union type in map value type\");\n    return errors;\n  };\n}\n\nconst isDynamicObject = (obj: MetadataObject): boolean =>\n  obj.properties[0]!.key.isSoleLiteral() === false;\n\nconst BANNED_NATIVE_TYPES: Map<string, string | null> = new Map([\n  [\"Date\", \"string\"],\n  [\"Boolean\", \"boolean\"],\n  [\"BigInt\", \"bigint\"],\n  [\"Number\", \"number\"],\n  [\"String\", \"string\"],\n  ...[\n    \"Buffer\",\n    \"Uint8ClampedArray\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigUint64Array\",\n    \"Int8Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"BigInt64Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"DataView\",\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n  ].map((name) => [name, \"Uint8Array\"] as const),\n  [\"WeakSet\", \"Array\"],\n  [\"WeakMap\", \"Map\"],\n]);\n"]}