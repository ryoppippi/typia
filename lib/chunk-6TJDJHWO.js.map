{"version":3,"sources":["../src/factories/MetadataFactory.ts"],"names":["ts","MetadataFactory","analyze","checker","context","options","collection","type","errors","meta","explore_metadata","top","object","property","nested","escaped","aliased","iterate_metadata_collection","iterate_metadata_sort","validate","push","length","success","data","soleLiteral","value","Metadata","initialize","constants","MetadataConstant","from","values","tags","undefined","functor","visitor","objects","Set","arrays","tuples","aliases","validateMeta","explore","result","atomic","atomics","row","tag","filter","t","predicate","ExpressionFactory","transpile","JSON","stringify","factory","createTrue","name","getName","messages","alias","validateAlias","array","validateArray","tuple","validateTuple","obj","validateObject","set","sets","map","maps","key","escape","returns","has","add","elem","elements","create","properties","isSoleLiteral","getSoleLiteral"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataAlias } from \"../schemas/metadata/MetadataAlias\";\nimport { MetadataArrayType } from \"../schemas/metadata/MetadataArrayType\";\nimport { MetadataConstant } from \"../schemas/metadata/MetadataConstant\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataTupleType } from \"../schemas/metadata/MetadataTupleType\";\nimport { explore_metadata } from \"./internal/metadata/explore_metadata\";\nimport { iterate_metadata_collection } from \"./internal/metadata/iterate_metadata_collection\";\nimport { iterate_metadata_sort } from \"./internal/metadata/iterate_metadata_sort\";\n\nimport { ValidationPipe } from \"../typings/ValidationPipe\";\n\nimport { ExpressionFactory } from \"./ExpressionFactory\";\nimport { MetadataCollection } from \"./MetadataCollection\";\n\nexport namespace MetadataFactory {\n  export type Validator = (meta: Metadata, explore: IExplore) => string[];\n\n  export interface IOptions {\n    escape: boolean;\n    constant: boolean;\n    absorb: boolean;\n    validate?: Validator;\n    onError?: (node: ts.Node | undefined, message: string) => void;\n  }\n\n  export interface IExplore {\n    top: boolean;\n    object: MetadataObject | null;\n    property: string | object | null;\n    nested: null | MetadataAlias | MetadataArrayType | MetadataTupleType;\n    escaped: boolean;\n    aliased: boolean;\n  }\n\n  export interface IError {\n    name: string;\n    explore: IExplore;\n    messages: string[];\n  }\n\n  export const analyze =\n    (checker: ts.TypeChecker, context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (collection: MetadataCollection) =>\n    (type: ts.Type | null): ValidationPipe<Metadata, IError> => {\n      const errors: IError[] = [];\n      const meta: Metadata = explore_metadata(checker)(options)(collection)(\n        errors,\n      )(type, {\n        top: true,\n        object: null,\n        property: null,\n        nested: null,\n        escaped: false,\n        aliased: false,\n      });\n      iterate_metadata_collection(errors)(collection);\n      iterate_metadata_sort(collection)(meta);\n\n      if (options.validate)\n        errors.push(...validate(context)(options)(options.validate)(meta));\n      return errors.length\n        ? {\n            success: false,\n            errors,\n          }\n        : {\n            success: true,\n            data: meta,\n          };\n    };\n\n  /**\n   * @internal\n   */\n  export const soleLiteral = (value: string): Metadata => {\n    const meta: Metadata = Metadata.initialize();\n    meta.constants.push(\n      MetadataConstant.from({\n        values: [\n          {\n            value,\n            tags: undefined,\n          },\n        ],\n        type: \"string\",\n      }),\n    );\n    return meta;\n  };\n\n  const validate =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (functor: Validator) =>\n    (meta: Metadata): IError[] => {\n      const visitor: IValidationVisitor = {\n        functor,\n        errors: [],\n        objects: new Set(),\n        arrays: new Set(),\n        tuples: new Set(),\n        aliases: new Set(),\n      };\n      validateMeta(context)(options)(visitor)(meta, {\n        object: null,\n        property: null,\n        nested: null,\n        top: true,\n        aliased: false,\n        escaped: false,\n      });\n      return visitor.errors;\n    };\n\n  const validateMeta =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (visitor: IValidationVisitor) =>\n    (meta: Metadata, explore: IExplore) => {\n      const result: string[] = [];\n      if (context !== undefined)\n        for (const atomic of meta.atomics)\n          for (const row of atomic.tags)\n            for (const tag of row.filter(\n              (t) => t.validate !== undefined && t.predicate === undefined,\n            ))\n              try {\n                tag.predicate = ExpressionFactory.transpile(context)(\n                  tag.validate!,\n                );\n              } catch {\n                result.push(\n                  `Unable to transpile type tag script: ${JSON.stringify(\n                    tag.validate,\n                  )}`,\n                );\n                tag.predicate = () => ts.factory.createTrue();\n              }\n      result.push(...visitor.functor(meta, explore));\n      if (result.length)\n        visitor.errors.push({\n          name: meta.getName(),\n          explore: { ...explore },\n          messages: [...new Set(result)],\n        });\n\n      for (const alias of meta.aliases)\n        validateAlias(context)(options)(visitor)(alias, explore);\n      for (const array of meta.arrays)\n        validateArray(context)(options)(visitor)(array.type, explore);\n      for (const tuple of meta.tuples)\n        validateTuple(context)(options)(visitor)(tuple.type, explore);\n      for (const obj of meta.objects)\n        validateObject(context)(options)(visitor)(obj);\n      for (const set of meta.sets)\n        validateMeta(context)(options)(visitor)(set, explore);\n      for (const map of meta.maps) {\n        validateMeta(context)(options)(visitor)(map.key, explore);\n        validateMeta(context)(options)(visitor)(map.value, explore);\n      }\n\n      if (options.escape === true && meta.escaped !== null)\n        validateMeta(context)(options)(visitor)(meta.escaped.returns, {\n          ...explore,\n          escaped: true,\n        });\n    };\n\n  const validateAlias =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (visitor: IValidationVisitor) =>\n    (alias: MetadataAlias, explore: IExplore) => {\n      if (visitor.aliases.has(alias)) return;\n      visitor.aliases.add(alias);\n\n      validateMeta(context)(options)(visitor)(alias.value, {\n        ...explore,\n        nested: alias,\n        aliased: true,\n      });\n    };\n\n  const validateArray =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (visitor: IValidationVisitor) =>\n    (array: MetadataArrayType, explore: IExplore) => {\n      if (visitor.arrays.has(array)) return;\n      visitor.arrays.add(array);\n\n      validateMeta(context)(options)(visitor)(array.value, {\n        ...explore,\n        nested: array,\n        top: false,\n      });\n    };\n\n  const validateTuple =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (visitor: IValidationVisitor) =>\n    (tuple: MetadataTupleType, explore: IExplore) => {\n      if (visitor.tuples.has(tuple)) return;\n      visitor.tuples.add(tuple);\n\n      for (const elem of tuple.elements)\n        validateMeta(context)(options)(visitor)(elem, {\n          ...explore,\n          nested: tuple,\n          top: false,\n        });\n    };\n\n  const validateObject =\n    (context?: ts.TransformationContext) =>\n    (options: IOptions) =>\n    (visitor: IValidationVisitor) =>\n    (object: MetadataObject) => {\n      if (visitor.objects.has(object)) return;\n      visitor.objects.add(object);\n\n      if (options.validate) {\n        const explore: IExplore = {\n          object,\n          top: false,\n          property: null,\n          nested: null,\n          escaped: false,\n          aliased: false,\n        };\n        const errors: string[] = options.validate(\n          Metadata.create({\n            ...Metadata.initialize(),\n            objects: [object],\n          }),\n          explore,\n        );\n        if (errors.length)\n          visitor.errors.push({\n            name: object.name,\n            explore,\n            messages: [...new Set(errors)],\n          });\n      }\n\n      for (const property of object.properties)\n        validateMeta(context)(options)(visitor)(property.value, {\n          object,\n          property: property.key.isSoleLiteral()\n            ? property.key.getSoleLiteral()!\n            : {},\n          nested: null,\n          top: false,\n          aliased: false,\n          escaped: false,\n        });\n    };\n\n  interface IValidationVisitor {\n    functor: Validator;\n    errors: IError[];\n    objects: Set<MetadataObject>;\n    arrays: Set<MetadataArrayType>;\n    tuples: Set<MetadataTupleType>;\n    aliases: Set<MetadataAlias>;\n  }\n}\n"]}