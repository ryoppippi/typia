{"version":3,"sources":["../src/factories/LiteralFactory.ts"],"names":["ts","LiteralFactory","generate","input","factory","createNull","isIdentifier","Array","generate_array","generate_object","generate_string","generate_value","generate_bigint","createIdentifier","TypeError","obj","createObjectLiteralExpression","Object","entries","filter","tuple","undefined","map","key","value","createPropertyAssignment","IdentifierFactory","identifier","array","createArrayLiteralExpression","toString","ExpressionFactory","bigint","createStringLiteral"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAKEC,iBAAAA;kBACFC,WAAW,CAACC,UAAAA;AACvB,QAAIA,UAAU,KAAM,QAAOH,GAAGI,QAAQC,WAAU;aACvCL,GAAGM,aAAaH,KAAAA,EAAQ,QAAOA;aAC/BA,iBAAiBI,MAAO,QAAOC,eAAeL,KAAAA;aAC9C,OAAOA,UAAU,SAAU,QAAOM,gBAAgBN,KAAAA;aAClD,OAAOA,UAAU,SAAU,QAAOO,gBAAgBP,KAAAA;aAClD,OAAOA,UAAU,UAAW,QAAOQ,eAAeR,KAAAA;aAClD,OAAOA,UAAU,SAAU,QAAOQ,eAAeR,KAAAA;aACjD,OAAOA,UAAU,SAAU,QAAOS,gBAAgBT,KAAAA;aAElD,OAAOA,UAAU,WACxB,QAAOH,GAAGI,QAAQS,iBAAiB,WAAA;QAEnC,OAAM,IAAIC,UAAU,mDAAA;EACxB;AAEA,QAAML,kBAAkB,wBAACM,QACvBf,GAAGI,QAAQY,8BACTC,OAAOC,QAAQH,GAAAA,EACZI,OAAO,CAACC,UAAUA,MAAM,CAAA,MAAOC,MAAAA,EAC/BC,IAAI,CAAC,CAACC,KAAKC,KAAAA,MACVxB,GAAGI,QAAQqB,yBACTC,kBAAkBC,WAAWJ,GAAAA,GAC7BrB,gBAAAA,SAASsB,KAAAA,CAAAA,CAAAA,GAGf,IAAA,GAVoB;AAaxB,QAAMhB,iBAAiB,wBAACoB,UACtB5B,GAAGI,QAAQyB,6BAA6BD,MAAMN,IAAGrB,gBAACC,QAAAA,GAAW,IAAA,GADxC;AAGvB,QAAMS,iBAAiB,wBAACa,UACtBxB,GAAGI,QAAQS,iBAAiBW,MAAMM,SAAQ,CAAA,GADrB;AAGvB,QAAMlB,kBAAkB,wBAACY,UACvBO,kBAAkBC,OAAOR,KAAAA,GADH;AAGxB,QAAMd,kBAAkB,wBAACc,UACvBxB,GAAGI,QAAQ6B,oBAAoBT,KAAAA,GADT;AAE1B,GAzCiBvB,mBAAAA,iBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"./ExpressionFactory\";\nimport { IdentifierFactory } from \"./IdentifierFactory\";\n\nexport namespace LiteralFactory {\n  export const generate = (input: any): ts.Expression => {\n    if (input === null) return ts.factory.createNull();\n    else if (ts.isIdentifier(input)) return input;\n    else if (input instanceof Array) return generate_array(input);\n    else if (typeof input === \"object\") return generate_object(input);\n    else if (typeof input === \"string\") return generate_string(input);\n    else if (typeof input === \"boolean\") return generate_value(input);\n    else if (typeof input === \"number\") return generate_value(input);\n    else if (typeof input === \"bigint\") return generate_bigint(input);\n    // unreachable code\n    else if (typeof input === \"function\")\n      return ts.factory.createIdentifier(\"undefined\");\n    else\n      throw new TypeError(\"Error on LiteralFactory.generate(): unknown type.\");\n  };\n\n  const generate_object = (obj: object): ts.ObjectLiteralExpression =>\n    ts.factory.createObjectLiteralExpression(\n      Object.entries(obj)\n        .filter((tuple) => tuple[1] !== undefined)\n        .map(([key, value]) =>\n          ts.factory.createPropertyAssignment(\n            IdentifierFactory.identifier(key),\n            generate(value),\n          ),\n        ),\n      true,\n    );\n\n  const generate_array = (array: any[]): ts.ArrayLiteralExpression =>\n    ts.factory.createArrayLiteralExpression(array.map(generate), true);\n\n  const generate_value = (value: number | boolean | bigint): ts.Expression =>\n    ts.factory.createIdentifier(value.toString());\n\n  const generate_bigint = (value: bigint): ts.Expression =>\n    ExpressionFactory.bigint(value);\n\n  const generate_string = (value: string): ts.StringLiteral =>\n    ts.factory.createStringLiteral(value);\n}\n"]}