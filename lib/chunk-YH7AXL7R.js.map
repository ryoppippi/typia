{"version":3,"sources":["../src/transformers/ImportTransformer.ts"],"names":["path","ts","ImportTransformer","transform","from","to","context","file","transform_file","top","isDeclarationFile","get_directory_path","resolve","getSourceFile","fileName","replace","visitEachChild","node","transform_node","isImportDeclaration","isStringLiteral","moduleSpecifier","text","location","indexOf","replaced","simple","relative","split","sep","join","factory","createImportDeclaration","undefined","importClause","createStringLiteral","assertClause","splitted","pop"],"mappings":";;;;;AAAA,OAAOA,UAAU;AACjB,OAAOC,QAAQ;;UAEEC,oBAAAA;qBACFC,YACX,CAACC,SACD,CAACC,OACD,CAACC,YACD,CAACC,SACCC,eAAeJ,IAAAA,EAAMC,EAAAA,EAAIC,OAAAA,EAASC,IAAAA;AAEtC,QAAMC,iBACJ,wBAACC,QACD,CAACJ,OACD,CAACC,YACD,CAACC,SAAAA;AACC,QAAIA,KAAKG,kBAAmB,QAAOH;AAEnC,UAAMH,OAAeO,mBACnBX,KAAKY,QAAQL,KAAKM,cAAa,EAAGC,QAAQ,CAAA;AAE5CT,SAAKD,KAAKW,QAAQN,KAAKJ,EAAAA;AAEvB,WAAOJ,GAAGe,eACRT,MACA,CAACU,SAASC,eAAeT,GAAAA,EAAKL,IAAAA,EAAMC,EAAAA,EAAIY,IAAAA,GACxCX,OAAAA;EAEJ,GAhBA;AAkBF,QAAMY,iBACJ,wBAACT,QAAgB,CAACL,SAAiB,CAACC,OAAe,CAACY,SAAAA;AAClD,QACE,CAAChB,GAAGkB,oBAAoBF,IAAAA,KACxB,CAAChB,GAAGmB,gBAAgBH,KAAKI,eAAe,EAExC,QAAOJ;AAET,UAAMK,OAAeL,KAAKI,gBAAgBC;AAC1C,QAAIA,KAAK,CAAA,MAAO,IAAK,QAAOL;AAE5B,UAAMM,WAAmBvB,KAAKY,QAAQR,MAAMkB,IAAAA;AAC5C,QAAIC,SAASC,QAAQf,GAAAA,MAAS,EAAG,QAAOQ;AAExC,UAAMQ,YAAoB,MAAA;AACxB,YAAMC,SAAiB1B,KACpB2B,SAAStB,IAAIkB,QAAAA,EACbK,MAAM5B,KAAK6B,GAAG,EACdC,KAAK,GAAA;AACR,aAAOJ,OAAO,CAAA,MAAO,MAAMA,SAAS,KAAKA,MAAAA;IAC3C,GAAA;AAEA,WAAOzB,GAAG8B,QAAQC,wBAChBC,QACAhB,KAAKiB,cACLjC,GAAG8B,QAAQI,oBAAoBV,QAAAA,GAC/BR,KAAKmB,YAAY;EAErB,GA3BA;AA4BJ,GAxDiBlC,sBAAAA,oBAAAA,CAAAA,EAAAA;AA0DjB,IAAMS,qBAAqB,wBAACJ,SAAAA;AAC1B,QAAM8B,WAAqBrC,KAAKY,QAAQL,IAAAA,EAAMqB,MAAM5B,KAAK6B,GAAG;AAC5DQ,WAASC,IAAG;AACZ,SAAOtC,KAAKY,QAAQyB,SAASP,KAAK9B,KAAK6B,GAAG,CAAA;AAC5C,GAJ2B","sourcesContent":["import path from \"path\";\nimport ts from \"typescript\";\n\nexport namespace ImportTransformer {\n  export const transform =\n    (from: string) =>\n    (to: string) =>\n    (context: ts.TransformationContext) =>\n    (file: ts.SourceFile) =>\n      transform_file(from)(to)(context)(file);\n\n  const transform_file =\n    (top: string) =>\n    (to: string) =>\n    (context: ts.TransformationContext) =>\n    (file: ts.SourceFile): ts.SourceFile => {\n      if (file.isDeclarationFile) return file;\n\n      const from: string = get_directory_path(\n        path.resolve(file.getSourceFile().fileName),\n      );\n      to = from.replace(top, to);\n\n      return ts.visitEachChild(\n        file,\n        (node) => transform_node(top)(from)(to)(node),\n        context,\n      );\n    };\n\n  const transform_node =\n    (top: string) => (from: string) => (to: string) => (node: ts.Node) => {\n      if (\n        !ts.isImportDeclaration(node) ||\n        !ts.isStringLiteral(node.moduleSpecifier)\n      )\n        return node;\n\n      const text: string = node.moduleSpecifier.text;\n      if (text[0] !== \".\") return node;\n\n      const location: string = path.resolve(from, text);\n      if (location.indexOf(top) === 0) return node;\n\n      const replaced: string = (() => {\n        const simple: string = path\n          .relative(to, location)\n          .split(path.sep)\n          .join(\"/\");\n        return simple[0] === \".\" ? simple : `./${simple}`;\n      })();\n\n      return ts.factory.createImportDeclaration(\n        undefined,\n        node.importClause,\n        ts.factory.createStringLiteral(replaced),\n        node.assertClause,\n      );\n    };\n}\n\nconst get_directory_path = (file: string): string => {\n  const splitted: string[] = path.resolve(file).split(path.sep);\n  splitted.pop();\n  return path.resolve(splitted.join(path.sep));\n};\n"]}