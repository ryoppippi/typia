{"version":3,"sources":["../src/programmers/internal/prune_object_properties.ts"],"names":["ts","prune_object_properties","obj","input","factory","createIdentifier","key","condition","properties","map","prop","name","getSoleLiteral","createStrictEquality","createStringLiteral","createCallExpression","metadata_to_pattern","undefined","statements","length","push","createIfStatement","reduce","a","b","createLogicalOr","createContinueStatement","createExpressionStatement","createDeleteExpression","createElementAccessExpression","createForOfStatement","StatementFactory","constant","declarationList","createBlock"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;AAWR,IAAMC,0BAA0B,wBAACC,QAAAA;AACtC,QAAMC,QAAuBH,GAAGI,QAAQC,iBAAiB,OAAA;AACzD,QAAMC,MAAqBN,GAAGI,QAAQC,iBAAiB,KAAA;AAEvD,QAAME,YAA6BL,IAAIM,WAAWC,IAAI,CAACC,SAAAA;AACrD,UAAMC,OAAsBD,KAAKJ,IAAIM,eAAc;AACnD,QAAID,SAAS,KACX,QAAOX,GAAGI,QAAQS,qBAChBb,GAAGI,QAAQU,oBAAoBH,IAAAA,GAC/BX,GAAGI,QAAQC,iBAAiB,KAAA,CAAA;AAEhC,WAAOL,GAAGI,QAAQW,qBAChBf,GAAGI,QAAQC,iBACT,WAAWW,oBAAoB,IAAA,EAAMN,KAAKJ,GAAG,CAAA,SAAU,GAEzDW,QACA;MAACX;KAAI;EAET,CAAA;AAEA,QAAMY,aAA6B,CAAA;AACnC,MAAIX,UAAUY,OACZD,YAAWE,KACTpB,GAAGI,QAAQiB,kBACTd,UAAUe,OAAO,CAACC,GAAGC,MAAMxB,GAAGI,QAAQqB,gBAAgBF,GAAGC,CAAAA,CAAAA,GACzDxB,GAAGI,QAAQsB,wBAAuB,CAAA,CAAA;AAGxCR,aAAWE,KACTpB,GAAGI,QAAQuB,0BACT3B,GAAGI,QAAQwB,uBACT5B,GAAGI,QAAQyB,8BAA8B1B,OAAOG,GAAAA,CAAAA,CAAAA,CAAAA;AAKtD,SAAON,GAAGI,QAAQ0B,qBAChBb,QACAc,iBAAiBC,SAAS,KAAA,EAAOC,iBACjCjC,GAAGI,QAAQW,qBACTf,GAAGI,QAAQC,iBAAiB,aAAA,GAC5BY,QACA;IAACd;GAAM,GAETe,WAAWC,WAAW,IAClBD,WAAW,CAAA,IACXlB,GAAGI,QAAQ8B,YAAYhB,YAAY,IAAA,CAAA;AAE3C,GAhDuC","sourcesContent":["import ts from \"typescript\";\n\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\n\nimport { metadata_to_pattern } from \"./metadata_to_pattern\";\n\n/**\n * @internal\n */\nexport const prune_object_properties = (obj: MetadataObject) => {\n  const input: ts.Expression = ts.factory.createIdentifier(\"input\");\n  const key: ts.Expression = ts.factory.createIdentifier(\"key\");\n\n  const condition: ts.Expression[] = obj.properties.map((prop) => {\n    const name: string | null = prop.key.getSoleLiteral();\n    if (name !== null)\n      return ts.factory.createStrictEquality(\n        ts.factory.createStringLiteral(name),\n        ts.factory.createIdentifier(\"key\"),\n      );\n    return ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\n        `RegExp(/${metadata_to_pattern(true)(prop.key)}/).test`,\n      ),\n      undefined,\n      [key],\n    );\n  });\n\n  const statements: ts.Statement[] = [];\n  if (condition.length)\n    statements.push(\n      ts.factory.createIfStatement(\n        condition.reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n        ts.factory.createContinueStatement(),\n      ),\n    );\n  statements.push(\n    ts.factory.createExpressionStatement(\n      ts.factory.createDeleteExpression(\n        ts.factory.createElementAccessExpression(input, key),\n      ),\n    ),\n  );\n\n  return ts.factory.createForOfStatement(\n    undefined,\n    StatementFactory.constant(\"key\").declarationList,\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"Object.keys\"),\n      undefined,\n      [input],\n    ),\n    statements.length === 1\n      ? statements[0]!\n      : ts.factory.createBlock(statements, true),\n  );\n};\n"]}