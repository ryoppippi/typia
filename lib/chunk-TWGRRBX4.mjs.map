{"version":3,"sources":["../src/programmers/http/HttpHeadersProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { Escaper } from \"../../utils/Escaper\";\nimport { MapUtil } from \"../../utils/MapUtil\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { HttpMetadataUtil } from \"../helpers/HttpMetadataUtil\";\n\nexport namespace HttpHeadersProgrammer {\n  export const INPUT_TYPE = \"Record<string, string | string[] | undefined>\";\n\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      // GET OBJECT TYPE\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.http.${importer.method}`)(\n          result.errors,\n        );\n\n      // DO TRANSFORM\n      const object: MetadataObject = result.data.objects[0]!;\n      const statements: ts.Statement[] = decode_object(importer)(object);\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(INPUT_TYPE),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo), ...statements],\n          true,\n        ),\n      );\n    };\n\n  export const validate = (\n    meta: Metadata,\n    explore: MetadataFactory.IExplore,\n  ): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (explore.top === true) {\n      // TOP MUST BE ONLY OBJECT\n      if (meta.objects.length !== 1 || meta.bucket() !== 1)\n        insert(\"only one object type is allowed.\");\n      if (meta.nullable === true) insert(\"headers cannot be null.\");\n      if (meta.isRequired() === false) insert(\"headers cannot be null.\");\n    } else if (\n      explore.nested !== null &&\n      explore.nested instanceof MetadataArrayType\n    ) {\n      //----\n      // ARRAY\n      //----\n      const atomics = HttpMetadataUtil.atomics(meta);\n      const expected: number =\n        meta.atomics.length +\n        meta.templates.length +\n        meta.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0);\n      if (atomics.size > 1) insert(\"union type is not allowed in array.\");\n      if (meta.size() !== expected)\n        insert(\"only atomic or constant types are allowed in array.\");\n      if (meta.nullable === true)\n        insert(\"nullable type is not allowed in array.\");\n      if (meta.isRequired() === false)\n        insert(\"optional type is not allowed in array.\");\n    } else if (explore.object && explore.property !== null) {\n      //----\n      // COMMON\n      //----\n      // PROPERTY MUST BE SOLE\n      if (typeof explore.property === \"object\")\n        insert(\"dynamic property is not allowed.\");\n      // DO NOT ALLOW TUPLE TYPE\n      if (meta.tuples.length) insert(\"tuple type is not allowed.\");\n      // DO NOT ALLOW UNION TYPE\n      if (HttpMetadataUtil.isUnion(meta)) insert(\"union type is not allowed.\");\n      // DO NOT ALLOW NESTED OBJECT\n      if (\n        meta.objects.length ||\n        meta.sets.length ||\n        meta.maps.length ||\n        meta.natives.length\n      )\n        insert(\"nested object type is not allowed.\");\n      // DO NOT ALLOW NULLABLE\n      if (meta.nullable === true) insert(\"nullable type is not allowed.\");\n\n      //----\n      // SPECIAL KEY NAMES\n      //----\n      const isArray: boolean =\n        meta.arrays.length >= 1 || meta.tuples.length >= 1;\n      // SET-COOKIE MUST BE ARRAY\n      if (\n        typeof explore.property === \"string\" &&\n        explore.property.toLowerCase() === \"set-cookie\" &&\n        isArray === false\n      )\n        insert(`${explore.property} property must be array.`);\n      // MUST BE SINGULAR CASE\n      if (\n        typeof explore.property === \"string\" &&\n        SINGULAR.has(explore.property.toLowerCase()) &&\n        isArray === true\n      )\n        insert(\"property cannot be array.\");\n    } else if (explore.object && explore.property === null) {\n      const counter: Map<string, Set<string>> = new Map();\n      for (const prop of explore.object.properties) {\n        const key: string | null = prop.key.getSoleLiteral();\n        if (key === null) continue;\n\n        MapUtil.take(counter)(key.toLowerCase(), () => new Set()).add(key);\n      }\n      for (const [key, set] of counter)\n        if (set.size > 1)\n          insert(\n            `duplicated keys when converting to lowercase letters: [${[\n              ...set,\n            ].join(\", \")}] -> ${key}`,\n          );\n    }\n    return errors;\n  };\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (object: MetadataObject): ts.Statement[] => {\n      const output: ts.Identifier = ts.factory.createIdentifier(\"output\");\n      const optionals: string[] = [];\n      return [\n        StatementFactory.constant(\n          \"output\",\n          ts.factory.createObjectLiteralExpression(\n            object.properties.map((prop) => {\n              if (\n                !prop.value.isRequired() &&\n                prop.value.arrays.length + prop.value.tuples.length > 0\n              )\n                optionals.push(\n                  prop.key.constants[0]!.values[0]!.value as string,\n                );\n              return decode_regular_property(importer)(prop);\n            }),\n            true,\n          ),\n        ),\n        ...optionals.map((key) => {\n          const access = IdentifierFactory.access(output)(key);\n          return ts.factory.createIfStatement(\n            ts.factory.createStrictEquality(\n              ExpressionFactory.number(0),\n              IdentifierFactory.access(access)(\"length\"),\n            ),\n            ts.factory.createExpressionStatement(\n              ts.factory.createDeleteExpression(access),\n            ),\n          );\n        }),\n        ts.factory.createReturnStatement(\n          ts.factory.createAsExpression(output, TypeFactory.keyword(\"any\")),\n        ),\n      ];\n    };\n\n  const decode_regular_property =\n    (importer: FunctionImporter) =>\n    (property: MetadataProperty): ts.PropertyAssignment => {\n      const key: string = property.key.constants[0]!.values[0]!.value as string;\n      const value: Metadata = property.value;\n\n      const [type, isArray]: [Atomic.Literal, boolean] = value.atomics.length\n        ? [value.atomics[0]!.type, false]\n        : value.constants.length\n          ? [value.constants[0]!.type, false]\n          : value.templates.length\n            ? [\"string\", false]\n            : (() => {\n                const meta: Metadata =\n                  value.arrays[0]?.type.value ??\n                  value.tuples[0]!.type.elements[0]!;\n                return meta.atomics.length\n                  ? [meta.atomics[0]!.type, true]\n                  : meta.templates.length\n                    ? [\"string\", true]\n                    : [meta.constants[0]!.type, true];\n              })();\n      const accessor = IdentifierFactory.access(\n        ts.factory.createIdentifier(\"input\"),\n      )(key.toLowerCase());\n\n      return ts.factory.createPropertyAssignment(\n        Escaper.variable(key) ? key : ts.factory.createStringLiteral(key),\n        isArray\n          ? key === \"set-cookie\"\n            ? accessor\n            : decode_array(importer)(type)(key)(value)(accessor)\n          : decode_value(importer)(type)(accessor),\n      );\n    };\n\n  const decode_value =\n    (importer: FunctionImporter) =>\n    (type: Atomic.Literal) =>\n    (value: ts.Expression) =>\n      type === \"string\"\n        ? value\n        : ts.factory.createCallExpression(importer.use(type), undefined, [\n            value,\n          ]);\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (type: Atomic.Literal) =>\n    (key: string) =>\n    (value: Metadata) =>\n    (accessor: ts.Expression) => {\n      const split: ts.CallChain = ts.factory.createCallChain(\n        ts.factory.createPropertyAccessChain(\n          ts.factory.createCallChain(\n            ts.factory.createPropertyAccessChain(\n              accessor,\n              ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n              ts.factory.createIdentifier(\"split\"),\n            ),\n            undefined,\n            undefined,\n            [ts.factory.createStringLiteral(key === \"cookie\" ? \"; \" : \", \")],\n          ),\n          ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n          ts.factory.createIdentifier(\"map\"),\n        ),\n        undefined,\n        undefined,\n        [importer.use(type)],\n      );\n      return ts.factory.createConditionalExpression(\n        ExpressionFactory.isArray(accessor),\n        undefined,\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(accessor)(\"map\"),\n          undefined,\n          [importer.use(type)],\n        ),\n        undefined,\n        value.isRequired() === false\n          ? split\n          : ts.factory.createBinaryExpression(\n              split,\n              ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n              ts.factory.createArrayLiteralExpression([], false),\n            ),\n      );\n    };\n}\n\nconst SINGULAR: Set<string> = new Set([\n  \"age\",\n  \"authorization\",\n  \"content-length\",\n  \"content-type\",\n  \"etag\",\n  \"expires\",\n  \"from\",\n  \"host\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"last-modified\",\n  \"location\",\n  \"max-forwards\",\n  \"proxy-authorization\",\n  \"referer\",\n  \"retry-after\",\n  \"server\",\n  \"user-agent\",\n]);\n"],"mappings":"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","names":["ts","HttpHeadersProgrammer","INPUT_TYPE","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","success","TransformerError","from","method","errors","object","data","objects","statements","decode_object","ts","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","meta","explore","insert","msg","push","top","length","bucket","nullable","isRequired","nested","MetadataArrayType","atomics","HttpMetadataUtil","expected","templates","constants","map","c","values","reduce","a","b","size","property","tuples","isUnion","sets","maps","natives","isArray","arrays","toLowerCase","SINGULAR","has","counter","Map","prop","properties","key","getSoleLiteral","MapUtil","take","Set","add","set","join","output","optionals","StatementFactory","createObjectLiteralExpression","value","decode_regular_property","access","createIfStatement","createStrictEquality","ExpressionFactory","number","createExpressionStatement","createDeleteExpression","createReturnStatement","createAsExpression","keyword","elements","accessor","createPropertyAssignment","Escaper","variable","decode_array","decode_value","createCallExpression","use","split","createCallChain","createPropertyAccessChain","createToken","SyntaxKind","QuestionDotToken","createConditionalExpression","createBinaryExpression","QuestionQuestionToken","createArrayLiteralExpression"]}