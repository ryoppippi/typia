{"version":3,"sources":["../src/programmers/misc/MiscIsPruneProgrammer.ts"],"names":["ts","MiscIsPruneProgrammer","write","project","modulo","type","name","factory","createArrowFunction","undefined","IdentifierFactory","parameter","TypeFactory","keyword","createTypePredicateNode","createTypeReferenceNode","getFullName","checker","createBlock","StatementFactory","constant","IsProgrammer","MiscPruneProgrammer","options","functional","numeric","createIfStatement","createPrefixUnaryExpression","SyntaxKind","ExclamationToken","createCallExpression","createIdentifier","createReturnStatement","createFalse","createExpressionStatement","createTrue"],"mappings":";;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAWEC,wBAAAA;yBACFC,QACX,CAACC,YACD,CAACC,WACD,CAACC,MAAeC,SACdN,GAAGO,QAAQC,oBACTC,QACAA,QACA;IAACC,kBAAkBC,UAAU,SAASC,YAAYC,QAAQ,KAAA,CAAA;KAC1Db,GAAGO,QAAQO,wBACTL,QACA,SACAT,GAAGO,QAAQQ,wBACTT,QAAQM,YAAYI,YAAYb,QAAQc,OAAO,EAAEZ,IAAAA,CAAAA,CAAAA,GAGrDI,QACAT,GAAGO,QAAQW,YAAY;IACrBC,iBAAiBC,SACf,MACAC,aAAanB,MAAMC,OAAAA,EAASC,MAAAA,EAAQ,KAAA,EAAOC,MAAMC,IAAAA,CAAAA;IAEnDa,iBAAiBC,SACf,SACAE,oBAAoBpB,MAAM;MACxB,GAAGC;MACHoB,SAAS;QACP,GAAGpB,QAAQoB;QACXC,YAAY;QACZC,SAAS;MACX;IACF,CAAA,EAAGrB,MAAAA,EAAQC,MAAMC,IAAAA,CAAAA;IAEnBN,GAAGO,QAAQmB,kBACT1B,GAAGO,QAAQoB,4BACT3B,GAAG4B,WAAWC,kBACd7B,GAAGO,QAAQuB,qBACT9B,GAAGO,QAAQwB,iBAAiB,IAAA,GAC5BtB,QACA;MAACT,GAAGO,QAAQwB,iBAAiB,OAAA;KAAS,CAAA,GAG1C/B,GAAGO,QAAQyB,sBAAsBhC,GAAGO,QAAQ0B,YAAW,CAAA,CAAA;IAEzDjC,GAAGO,QAAQ2B,0BACTlC,GAAGO,QAAQuB,qBACT9B,GAAGO,QAAQwB,iBAAiB,OAAA,GAC5BtB,QACA;MAACT,GAAGO,QAAQwB,iBAAiB,OAAA;KAAS,CAAA;IAG1C/B,GAAGO,QAAQyB,sBAAsBhC,GAAGO,QAAQ4B,WAAU,CAAA;GACvD,CAAA;AAET,GAtDiBlC,0BAAAA,wBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { MiscPruneProgrammer } from \"./MiscPruneProgrammer\";\n\nexport namespace MiscIsPruneProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string) =>\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n        ts.factory.createTypePredicateNode(\n          undefined,\n          \"input\",\n          ts.factory.createTypeReferenceNode(\n            name ?? TypeFactory.getFullName(project.checker)(type),\n          ),\n        ),\n        undefined,\n        ts.factory.createBlock([\n          StatementFactory.constant(\n            \"is\",\n            IsProgrammer.write(project)(modulo)(false)(type, name),\n          ),\n          StatementFactory.constant(\n            \"prune\",\n            MiscPruneProgrammer.write({\n              ...project,\n              options: {\n                ...project.options,\n                functional: false,\n                numeric: false,\n              },\n            })(modulo)(type, name),\n          ),\n          ts.factory.createIfStatement(\n            ts.factory.createPrefixUnaryExpression(\n              ts.SyntaxKind.ExclamationToken,\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"is\"),\n                undefined,\n                [ts.factory.createIdentifier(\"input\")],\n              ),\n            ),\n            ts.factory.createReturnStatement(ts.factory.createFalse()),\n          ),\n          ts.factory.createExpressionStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"prune\"),\n              undefined,\n              [ts.factory.createIdentifier(\"input\")],\n            ),\n          ),\n          ts.factory.createReturnStatement(ts.factory.createTrue()),\n        ]),\n      );\n}\n"]}