{"version":3,"sources":["../src/notations.ts"],"sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { CamelCase } from \"./CamelCase\";\nimport { IValidation } from \"./IValidation\";\nimport { PascalCase } from \"./PascalCase\";\nimport { SnakeCase } from \"./SnakeCase\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    NOTATIONS (NAMING CONVENTIONS)\n      - CAMEL CASE\n      - PASCAL CASE\n      - SNAKE CASE\n      - FACTORY FUNCTIONS\n==============================================================\n    CAMEL CASE\n----------------------------------------------------------- */\n/**\n * Convert to camel case.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n *\n * For reference, this `typia.notations.camel()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertCamel}\n * - {@link isCamel}\n * - {@link validateCamel}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction camel<T>(input: T): CamelCase<T>;\n\n/**\n * @internal\n */\nfunction camel(): never {\n  return halt(\"camel\");\n}\nconst camelPure = /** @__PURE__ */ Object.assign<typeof camel, {}>(\n  camel,\n  /** @__PURE__ */ Namespace.notations.camel(\"camel\"),\n);\nexport { camelPure as camel };\n\n/**\n * Converts to camel case with type assertion.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertCamel<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): CamelCase<T>;\n\n/**\n * Converts to camel case with type assertion.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertCamel<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): CamelCase<T>;\n\n/**\n * @internal\n */\nfunction assertCamel(): never {\n  return halt(\"assertCamel\");\n}\nconst assertCamelPure = /** @__PURE__ */ Object.assign<\n  typeof assertCamel,\n  {},\n  {}\n>(\n  assertCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"assertCamel\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertCamel\"),\n);\nexport { assertCamelPure as assertCamel };\n\n/**\n * Converts to camel case with type checking.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isCamel<T>(input: T): CamelCase<T> | null;\n\n/**\n * Converts to camel case with type checking.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isCamel<T>(input: unknown): CamelCase<T> | null;\n\n/**\n * @internal\n */\nfunction isCamel(): never {\n  return halt(\"isCamel\");\n}\nconst isCamelPure = /** @__PURE__ */ Object.assign<typeof isCamel, {}, {}>(\n  isCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"isCamel\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isCamelPure as isCamel };\n\n/**\n * Converts to camel case with type validation.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, camel cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateCamel<T>(input: T): IValidation<CamelCase<T>>;\n\n/**\n * Converts to camel case with type validation.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, camel cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateCamel<T>(input: unknown): IValidation<CamelCase<T>>;\n\n/**\n * @internal\n */\nfunction validateCamel(): never {\n  return halt(\"validateCamel\");\n}\nconst validateCamelPure = /** @__PURE__ */ Object.assign<\n  typeof validateCamel,\n  {},\n  {}\n>(\n  validateCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"validateCamel\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateCamelPure as validateCamel };\n\n/* -----------------------------------------------------------\n    PASCAL CASE\n----------------------------------------------------------- */\n/**\n * Convert to pascal case.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n *\n * For reference, this `typia.notations.pascal()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertPascal}\n * - {@link isPascal}\n * - {@link validatePascal}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction pascal<T>(input: T): PascalCase<T>;\n\n/**\n * @internal\n */\nfunction pascal(): never {\n  return halt(\"pascal\");\n}\nconst pascalPure = /** @__PURE__ */ Object.assign<typeof pascal, {}>(\n  pascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"pascal\"),\n);\nexport { pascalPure as pascal };\n\n/**\n * Converts to pascal case with type assertion.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPascal<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): PascalCase<T>;\n\n/**\n * Converts to pascal case with type assertion.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPascal<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): PascalCase<T>;\n\n/**\n * @internal\n */\nfunction assertPascal(): never {\n  return halt(\"assertPascal\");\n}\nconst assertPascalPure = /** @__PURE__ */ Object.assign<\n  typeof assertPascal,\n  {},\n  {}\n>(\n  assertPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"assertPascal\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertPascal\"),\n);\nexport { assertPascalPure as assertPascal };\n\n/**\n * Converts to pascal case with type checking.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPascal<T>(input: T): PascalCase<T> | null;\n\n/**\n * Converts to pascal case with type checking.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPascal<T>(input: unknown): PascalCase<T> | null;\n\n/**\n * @internal\n */\nfunction isPascal(): never {\n  return halt(\"isPascal\");\n}\nconst isPascalPure = /** @__PURE__ */ Object.assign<typeof isPascal, {}, {}>(\n  isPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"isPascal\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isPascalPure as isPascal };\n\n/**\n * Converts to pascal case with type validation.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, pascal cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePascal<T>(input: T): IValidation<PascalCase<T>>;\n\n/**\n * Converts to pascal case with type validation.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, pascal cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePascal<T>(input: unknown): IValidation<PascalCase<T>>;\n\n/**\n * @internal\n */\nfunction validatePascal(): never {\n  return halt(\"validatePascal\");\n}\nconst validatePascalPure = /** @__PURE__ */ Object.assign<\n  typeof validatePascal,\n  {},\n  {}\n>(\n  validatePascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"validatePascal\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validatePascalPure as validatePascal };\n\n/* -----------------------------------------------------------\n    SNAKE CASE\n----------------------------------------------------------- */\n/**\n * Convert to snake case.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n *\n * For reference, this `typia.notations.snake()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertSnake}\n * - {@link isSnake}\n * - {@link validateSnake}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction snake<T>(input: T): SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction snake(): never {\n  return halt(\"snake\");\n}\nconst snakePure = /** @__PURE__ */ Object.assign<typeof snake, {}>(\n  snake,\n  /** @__PURE__ */ Namespace.notations.snake(\"snake\"),\n);\nexport { snakePure as snake };\n\n/**\n * Converts to snake case with type assertion.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertSnake<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): SnakeCase<T>;\n\n/**\n * Converts to snake case with type assertion.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertSnake<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction assertSnake(): never {\n  return halt(\"assertSnake\");\n}\nconst assertSnakePure = /** @__PURE__ */ Object.assign<\n  typeof assertSnake,\n  {},\n  {}\n>(\n  assertSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"assertSnake\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertSnake\"),\n);\nexport { assertSnakePure as assertSnake };\n\n/**\n * Converts to snake case with type checking.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isSnake<T>(input: T): SnakeCase<T> | null;\n\n/**\n * Converts to snake case with type checking.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isSnake<T>(input: unknown): SnakeCase<T> | null;\n\n/**\n * @internal\n */\nfunction isSnake(): never {\n  return halt(\"isSnake\");\n}\nconst isSnakePure = /** @__PURE__ */ Object.assign<typeof isSnake, {}, {}>(\n  isSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"isSnake\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isSnakePure as isSnake };\n\n/**\n * Converts to snake case with type validation.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, snake cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateSnake<T>(input: T): IValidation<SnakeCase<T>>;\n\n/**\n * Converts to snake case with type validation.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, snake cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateSnake<T>(input: unknown): IValidation<SnakeCase<T>>;\n\n/**\n * @internal\n */\nfunction validateSnake(): never {\n  return halt(\"validateSnake\");\n}\nconst validateSnakePure = /** @__PURE__ */ Object.assign<\n  typeof validateSnake,\n  {},\n  {}\n>(\n  validateSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"validateSnake\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateSnakePure as validateSnake };\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link camel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createCamel(): never;\n\n/**\n * Creates a reusable {@link camel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `camel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createCamel<T>(): (input: T) => CamelCase<T>;\n\n/**\n * @internal\n */\nfunction createCamel(): never {\n  halt(\"createCamel\");\n}\nconst createCamelPure = /** @__PURE__ */ Object.assign<typeof createCamel, {}>(\n  createCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createCamel\"),\n);\nexport { createCamelPure as createCamel };\n\n/**\n * Creates a reusable {@link assertCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertCamel(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertCamel} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertCamel<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => CamelCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertCamel(): never {\n  halt(\"createAssertCamel\");\n}\nconst createAssertCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertCamel,\n  {},\n  {}\n>(\n  createAssertCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createAssertCamel\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertCamel\"),\n);\nexport { createAssertCamelPure as createAssertCamel };\n\n/**\n * Creates a reusable {@link isCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsCamel(): never;\n\n/**\n * Creates a reusable {@link isCamel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsCamel<T>(): (input: T) => CamelCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsCamel(): never {\n  halt(\"createIsCamel\");\n}\nconst createIsCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createIsCamel,\n  {},\n  {}\n>(\n  createIsCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createIsCamel\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsCamelPure as createIsCamel };\n\n/**\n * Creates a reusable {@link validateCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateCamel(): never;\n\n/**\n * Creates a reusable {@link validateCamel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateCamel<T>(): (input: T) => IValidation<CamelCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidateCamel(): never {\n  halt(\"createValidateCamel\");\n}\nconst createValidateCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateCamel,\n  {},\n  {}\n>(\n  createValidateCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createValidateCamel\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateCamelPure as createValidateCamel };\n\n/**\n * Creates a reusable {@link pascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPascal(): never;\n\n/**\n * Creates a reusable {@link pascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `pascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPascal<T>(): (input: T) => PascalCase<T>;\n\n/**\n * @internal\n */\nfunction createPascal(): never {\n  halt(\"createPascal\");\n}\nconst createPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createPascal,\n  {}\n>(createPascal, /** @__PURE__ */ Namespace.notations.pascal(\"createPascal\"));\nexport { createPascalPure as createPascal };\n\n/**\n * Creates a reusable {@link assertPascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPascal(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertPascal} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertPascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPascal<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => PascalCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertPascal(): never {\n  halt(\"createAssertPascal\");\n}\nconst createAssertPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertPascal,\n  {},\n  {}\n>(\n  createAssertPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createAssertPascal\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertPascal\"),\n);\nexport { createAssertPascalPure as createAssertPascal };\n\n/**\n * Creates a reusable {@link isPascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPascal(): never;\n\n/**\n * Creates a reusable {@link isPascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPascal<T>(): (input: T) => PascalCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsPascal(): never {\n  halt(\"createIsPascal\");\n}\nconst createIsPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createIsPascal,\n  {},\n  {}\n>(\n  createIsPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createIsPascal\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsPascalPure as createIsPascal };\n\n/**\n * Creates a reusable {@link validatePascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePascal(): never;\n\n/**\n * Creates a reusable {@link validatePascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePascal<T>(): (input: T) => IValidation<PascalCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidatePascal(): never {\n  halt(\"createValidatePascal\");\n}\nconst createValidatePascalPure = /** @__PURE__ */ Object.assign<\n  typeof createValidatePascal,\n  {},\n  {}\n>(\n  createValidatePascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createValidatePascal\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidatePascalPure as createValidatePascal };\n\n/**\n * Creates a reusable {@link snake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createSnake(): never;\n\n/**\n * Creates a reusable {@link snake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `snake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createSnake<T>(): (input: T) => SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction createSnake(): never {\n  halt(\"createSnake\");\n}\nconst createSnakePure = /** @__PURE__ */ Object.assign<typeof createSnake, {}>(\n  createSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createSnake\"),\n);\nexport { createSnakePure as createSnake };\n\n/**\n * Creates a reusable {@link assertSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertSnake(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertSnake} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertSnake<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertSnake(): never {\n  halt(\"createAssertSnake\");\n}\nconst createAssertSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertSnake,\n  {},\n  {}\n>(\n  createAssertSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createAssertSnake\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertSnake\"),\n);\nexport { createAssertSnakePure as createAssertSnake };\n\n/**\n * Creates a reusable {@link isSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsSnake(): never;\n\n/**\n * Creates a reusable {@link isSnake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsSnake<T>(): (input: T) => SnakeCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsSnake(): never {\n  halt(\"createIsSnake\");\n}\nconst createIsSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createIsSnake,\n  {},\n  {}\n>(\n  createIsSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createIsSnake\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsSnakePure as createIsSnake };\n\n/**\n * Creates a reusable {@link validateSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateSnake(): never;\n\n/**\n * Creates a reusable {@link validateSnake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateSnake<T>(): (input: T) => IValidation<SnakeCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidateSnake(): never {\n  halt(\"createValidateSnake\");\n}\nconst createValidateSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateSnake,\n  {},\n  {}\n>(\n  createValidateSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createValidateSnake\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateSnakePure as createValidateSnake };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.notations.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"],"mappings":"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","names":["notations_exports","camel","halt","camelPure","Object","assign","Namespace","notations","assertCamel","halt","assertCamelPure","Object","assign","Namespace","notations","camel","assert","isCamel","halt","isCamelPure","Object","assign","Namespace","notations","camel","is","validateCamel","halt","validateCamelPure","Object","assign","Namespace","notations","camel","validate","pascal","halt","pascalPure","Object","assign","Namespace","notations","assertPascal","halt","assertPascalPure","Object","assign","Namespace","notations","pascal","assert","isPascal","halt","isPascalPure","Object","assign","Namespace","notations","pascal","is","validatePascal","halt","validatePascalPure","Object","assign","Namespace","notations","pascal","validate","snake","halt","snakePure","Object","assign","Namespace","notations","assertSnake","halt","assertSnakePure","Object","assign","Namespace","notations","snake","assert","isSnake","halt","isSnakePure","Object","assign","Namespace","notations","snake","is","validateSnake","halt","validateSnakePure","Object","assign","Namespace","notations","snake","validate","createCamel","halt","createCamelPure","Object","assign","Namespace","notations","camel","createAssertCamel","halt","createAssertCamelPure","Object","assign","Namespace","notations","camel","assert","createIsCamel","halt","createIsCamelPure","Object","assign","Namespace","notations","camel","is","createValidateCamel","halt","createValidateCamelPure","Object","assign","Namespace","notations","camel","validate","createPascal","halt","createPascalPure","Object","assign","Namespace","notations","pascal","createAssertPascal","halt","createAssertPascalPure","Object","assign","Namespace","notations","pascal","assert","createIsPascal","halt","createIsPascalPure","Object","assign","Namespace","notations","pascal","is","createValidatePascal","halt","createValidatePascalPure","Object","assign","Namespace","notations","pascal","validate","createSnake","halt","createSnakePure","Object","assign","Namespace","notations","snake","createAssertSnake","halt","createAssertSnakePure","Object","assign","Namespace","notations","snake","assert","createIsSnake","halt","createIsSnakePure","Object","assign","Namespace","notations","snake","is","createValidateSnake","halt","createValidateSnakePure","Object","assign","Namespace","notations","snake","validate","halt","name","Error"]}