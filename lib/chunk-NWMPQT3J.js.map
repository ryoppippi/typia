{"version":3,"sources":["../src/programmers/IsProgrammer.ts","../src/programmers/CheckerProgrammer.ts"],"names":["ts","CheckerProgrammer","write","project","config","importer","FeatureProgrammer","configure","write_object_functions","write_union_functions","numeric","write_array_functions","collection","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","types","input","output","name","createTypePredicateNode","createTypeReferenceNode","getFullName","checker","path","initializer","MetadataCollection","result","MetadataFactory","analyze","context","escape","absorb","success","TransformerError","method","errors","data","addition","decoder","decode","objector","decode_object","joiner","object","unionizer","equals","decode_union_object","obj","explore","is","expr","value","expected","createReturnStatement","failure","targets","combiner","expression","combined","join","required","full","generator","unions","meta","any","top","binaries","add","create_add","getConstantValue","createStringLiteral","ExpressionFactory","bigint","toString","checkOptional","empty","isUnionBucket","nullable","ValueFactory","NULL","isRequired","UNDEFINED","functional","OptionPredicator","options","size","TYPEOF","push","constants","AtomicPredicator","v","values","escaped","original","natives","length","check_native","createLogicalAnd","IsProgrammer","decode_to_json","decode_escaped","returns","atom","atomics","atomic","atomist","check_number","check_bigint","check_string","templates","template","check_template","native","instances","prepare","pre","body","sets","install","elem","getName","some","explore_sets","maps","key","explore_maps","isArray","conditions","decode_tuple","explore_tuples","decode_array","explore_arrays","explore_arrays_and_tuples","objects","isObject","checkNull","checkArray","properties","every","prop","isSoleLiteral","explore_objects","transformer","merger","ins","func","validated","array","createLogicalOr","createCallExpression","useLocal","index","argumentsArray","check_array_length","main","elements","rest","createElementAccessExpression","slice","at","IdentifierFactory","access","number","wrap_metadata_rest_tuple","start","arrayLength","createPropertyAccessExpression","optional","createStrictEquality","createLessThanEquals","createGreaterThanEquals","createParenthesizedExpression","parameter","UnionExplorer","set","entry","explore_array_like_union_types","array_or_tuple","front","target","MetadataTuple","arrow","parameters","e","emplaceUnion","union_index","defaultInput","exact","left","right","createStrictInequality","s","reduce","b","x","y","initial","createTrue","createFalse","binder","_input","binary","check_object","assert","positive","superfluous","modulo","disable","disable_function_importer_declare","FunctionImporter","getText","declare","_Is_simple","createAsExpression","feature_object_entries","write_function_statements","_","hasLocal","decode_functional"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\nimport { ValueFactory } from \"../factories/ValueFactory\";\n\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"./helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { disable_function_importer_declare } from \"./helpers/disable_function_importer_declare\";\nimport { check_object } from \"./internal/check_object\";\nimport { feature_object_entries } from \"./internal/feature_object_entries\";\n\nexport namespace IsProgrammer {\n  export const configure =\n    (options?: Partial<CONFIG.IOptions>) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig => ({\n      prefix: \"$i\",\n      equals: !!options?.object,\n      trace: false,\n      path: false,\n      numeric: OptionPredicator.numeric({\n        numeric: options?.numeric,\n      }),\n      atomist: () => (entry) => () =>\n        [\n          ...(entry.expression ? [entry.expression] : []),\n          ...(entry.conditions.length === 0\n            ? []\n            : [\n                entry.conditions\n                  .map((set) =>\n                    set\n                      .map((s) => s.expression)\n                      .reduce((a, b) => ts.factory.createLogicalAnd(a, b)),\n                  )\n                  .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n              ]),\n        ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n      combiner: () => (type: \"and\" | \"or\") => {\n        const initial: ts.TrueLiteral | ts.FalseLiteral =\n          type === \"and\" ? ts.factory.createTrue() : ts.factory.createFalse();\n        const binder =\n          type === \"and\"\n            ? ts.factory.createLogicalAnd\n            : ts.factory.createLogicalOr;\n        return (_input: ts.Expression, binaries: CheckerProgrammer.IBinary[]) =>\n          binaries.length\n            ? binaries\n                .map((binary) => binary.expression)\n                .reduce((x, y) => binder(x, y))\n            : initial;\n      },\n      joiner: {\n        object:\n          options?.object ||\n          check_object({\n            equals: !!options?.object,\n            undefined: OptionPredicator.undefined({\n              undefined: options?.undefined,\n            }),\n            assert: true,\n            reduce: ts.factory.createLogicalAnd,\n            positive: ts.factory.createTrue(),\n            superfluous: () => ts.factory.createFalse(),\n          })(project)(importer),\n        array: (input, arrow) =>\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"every\"),\n            undefined,\n            [arrow],\n          ),\n        failure: () => ts.factory.createFalse(),\n      },\n      success: ts.factory.createTrue(),\n    });\n\n  export namespace CONFIG {\n    export interface IOptions {\n      numeric: boolean;\n      undefined: boolean;\n      object: (\n        input: ts.Expression,\n        entries: IExpressionEntry<ts.Expression>[],\n      ) => ts.Expression;\n    }\n  }\n\n  /* -----------------------------------------------------------\n        WRITERS\n    ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression, disable?: boolean) =>\n    (equals: boolean) => {\n      const importer: FunctionImporter =\n        disable === <any>{}\n          ? disable_function_importer_declare(\n              new FunctionImporter(modulo.getText()),\n            )\n          : new FunctionImporter(modulo.getText());\n\n      // CONFIGURATION\n      const config: CheckerProgrammer.IConfig = {\n        ...configure({\n          object: check_object({\n            equals,\n            undefined: OptionPredicator.undefined(project.options),\n            assert: true,\n            reduce: ts.factory.createLogicalAnd,\n            positive: ts.factory.createTrue(),\n            superfluous: () => ts.factory.createFalse(),\n          })(project)(importer),\n          numeric: OptionPredicator.numeric(project.options),\n        })(project)(importer),\n        trace: equals,\n        addition: () => importer.declare(modulo),\n      };\n\n      config.decoder = () => (input, target, explore) => {\n        if (\n          target.size() === 1 &&\n          target.objects.length === 1 &&\n          target.isRequired() === true &&\n          target.nullable === false\n        ) {\n          // ONLY WHEN OBJECT WITH SOME ATOMIC PROPERTIES\n          const obj: MetadataObject = target.objects[0]!;\n          if (\n            obj._Is_simple(explore.from === \"top\" ? 0 : 1) &&\n            (equals === false ||\n              OptionPredicator.undefined(project.options) === false)\n          )\n            return ts.factory.createLogicalAnd(\n              ExpressionFactory.isObject({\n                checkNull: true,\n                checkArray: false,\n              })(input),\n              config.joiner.object(\n                ts.factory.createAsExpression(\n                  input,\n                  TypeFactory.keyword(\"any\"),\n                ),\n                feature_object_entries(config as any)(importer)(obj)(\n                  ts.factory.createAsExpression(\n                    input,\n                    TypeFactory.keyword(\"any\"),\n                  ),\n                  \"top\",\n                ),\n              ),\n            );\n        }\n        return CheckerProgrammer.decode(project)(config)(importer)(\n          input,\n          target,\n          explore,\n        );\n      };\n\n      // GENERATE CHECKER\n      return CheckerProgrammer.write(project)(config)(importer);\n    };\n\n  export const write_function_statements =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection) => {\n      const config = configure()(project)(importer);\n      const objects =\n        CheckerProgrammer.write_object_functions(project)(config)(importer)(\n          collection,\n        );\n      const unions =\n        CheckerProgrammer.write_union_functions(project)(config)(importer)(\n          collection,\n        );\n      const arrays =\n        CheckerProgrammer.write_array_functions(project)(config)(importer)(\n          collection,\n        );\n      const tuples =\n        CheckerProgrammer.write_tuple_functions(project)(config)(importer)(\n          collection,\n        );\n\n      return [\n        ...objects.filter((_, i) => importer.hasLocal(`${config.prefix}o${i}`)),\n        ...unions.filter((_, i) => importer.hasLocal(`${config.prefix}u${i}`)),\n        ...arrays.filter((_, i) => importer.hasLocal(`${config.prefix}a${i}`)),\n        ...tuples.filter((_, i) => importer.hasLocal(`${config.prefix}t${i}`)),\n      ];\n    };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  export const decode = (project: IProject) => (importer: FunctionImporter) =>\n    CheckerProgrammer.decode(project)(configure()(project)(importer))(importer);\n\n  export const decode_object =\n    (project: IProject) => (importer: FunctionImporter) =>\n      CheckerProgrammer.decode_object(configure()(project)(importer))(importer);\n\n  export const decode_to_json =\n    (checkNull: boolean) =>\n    (input: ts.Expression): ts.Expression =>\n      ts.factory.createLogicalAnd(\n        ExpressionFactory.isObject({\n          checkArray: false,\n          checkNull,\n        })(input),\n        ts.factory.createStrictEquality(\n          ts.factory.createStringLiteral(\"function\"),\n          ValueFactory.TYPEOF(IdentifierFactory.access(input)(\"toJSON\")),\n        ),\n      );\n\n  export const decode_functional = (input: ts.Expression) =>\n    ts.factory.createStrictEquality(\n      ts.factory.createStringLiteral(\"function\"),\n      ValueFactory.TYPEOF(input),\n    );\n}\n","import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../factories/MetadataFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\nimport { ValueFactory } from \"../factories/ValueFactory\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../schemas/metadata/MetadataArray\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../transformers/IProject\";\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { FeatureProgrammer } from \"./FeatureProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { AtomicPredicator } from \"./helpers/AtomicPredicator\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { ICheckEntry } from \"./helpers/ICheckEntry\";\nimport { IExpressionEntry } from \"./helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { UnionExplorer } from \"./helpers/UnionExplorer\";\nimport { check_array_length } from \"./internal/check_array_length\";\nimport { check_bigint } from \"./internal/check_bigint\";\nimport { check_native } from \"./internal/check_native\";\nimport { check_number } from \"./internal/check_number\";\nimport { check_string } from \"./internal/check_string\";\nimport { check_template } from \"./internal/check_template\";\nimport { decode_union_object } from \"./internal/decode_union_object\";\nimport { wrap_metadata_rest_tuple } from \"./internal/wrap_metadata_rest_tuple\";\n\nexport namespace CheckerProgrammer {\n  export interface IConfig {\n    prefix: string;\n    path: boolean;\n    trace: boolean;\n    equals: boolean;\n    numeric: boolean;\n    addition?: () => ts.Statement[];\n    decoder?: () => FeatureProgrammer.Decoder<Metadata, ts.Expression>;\n    combiner: IConfig.Combiner;\n    atomist: (\n      explore: IExplore,\n    ) => (check: ICheckEntry) => (input: ts.Expression) => ts.Expression;\n    joiner: IConfig.IJoiner;\n    success: ts.Expression;\n  }\n  export namespace IConfig {\n    export interface Combiner {\n      (explorer: IExplore): {\n        (logic: \"and\" | \"or\"): {\n          (\n            input: ts.Expression,\n            binaries: IBinary[],\n            expected: string,\n          ): ts.Expression;\n        };\n      };\n    }\n    export interface IJoiner {\n      object(input: ts.Expression, entries: IExpressionEntry[]): ts.Expression;\n      array(input: ts.Expression, arrow: ts.ArrowFunction): ts.Expression;\n      tuple?: undefined | ((exprs: ts.Expression[]) => ts.Expression);\n\n      failure(\n        value: ts.Expression,\n        expected: string,\n        explore?: undefined | FeatureProgrammer.IExplore,\n      ): ts.Expression;\n      is?(expression: ts.Expression): ts.Expression;\n      required?(exp: ts.Expression): ts.Expression;\n      full?:\n        | undefined\n        | ((\n            condition: ts.Expression,\n          ) => (\n            input: ts.Expression,\n            expected: string,\n            explore: IExplore,\n          ) => ts.Expression);\n    }\n  }\n  export type IExplore = FeatureProgrammer.IExplore;\n\n  export interface IBinary {\n    expression: ts.Expression;\n    combined: boolean;\n  }\n\n  /* -----------------------------------------------------------\n        WRITERS\n    ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write(project)(configure(project)(config)(importer))(\n        importer,\n      );\n\n  export const write_object_functions =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write_object_functions(\n        configure(project)(config)(importer),\n      )(importer);\n\n  export const write_union_functions =\n    (project: IProject) => (config: IConfig) => (importer: FunctionImporter) =>\n      FeatureProgrammer.write_union_functions(\n        configure(project)({ ...config, numeric: false })(importer),\n      );\n\n  export const write_array_functions =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  export const write_tuple_functions =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const configure =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => ({\n      types: {\n        input: () => TypeFactory.keyword(\"any\"),\n        output: (type, name) =>\n          ts.factory.createTypePredicateNode(\n            undefined,\n            \"input\",\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ),\n      },\n      trace: config.trace,\n      path: config.path,\n      prefix: config.prefix,\n      initializer: (project) => (importer) => (type) => {\n        const collection: MetadataCollection = new MetadataCollection();\n        const result = MetadataFactory.analyze(\n          project.checker,\n          project.context,\n        )({\n          escape: false,\n          constant: true,\n          absorb: true,\n        })(collection)(type);\n        if (result.success === false)\n          throw TransformerError.from(`typia.${importer.method}`)(\n            result.errors,\n          );\n        return [collection, result.data];\n      },\n      addition: config.addition,\n      decoder: () => config.decoder?.() ?? decode(project)(config)(importer),\n      objector: {\n        checker: () => config.decoder?.() ?? decode(project)(config)(importer),\n        decoder: () => decode_object(config)(importer),\n        joiner: config.joiner.object,\n        unionizer: config.equals\n          ? decode_union_object(decode_object(config)(importer))(\n              (input, obj, explore) =>\n                decode_object(config)(importer)(input, obj, {\n                  ...explore,\n                  tracable: true,\n                }),\n            )(config.joiner.is ?? ((expr) => expr))((value, expected) =>\n              ts.factory.createReturnStatement(\n                config.joiner.failure(value, expected),\n              ),\n            )\n          : (input, targets, explore) =>\n              config.combiner(explore)(\"or\")(\n                input,\n                targets.map((obj) => ({\n                  expression: decode_object(config)(importer)(\n                    input,\n                    obj,\n                    explore,\n                  ),\n                  combined: true,\n                })),\n                `(${targets.map((t) => t.name).join(\" | \")})`,\n              ),\n        failure: (value, expected) =>\n          ts.factory.createReturnStatement(\n            config.joiner.failure(value, expected),\n          ),\n        is: config.joiner.is,\n        required: config.joiner.required,\n        full: config.joiner.full,\n        type: TypeFactory.keyword(\"boolean\"),\n      },\n      generator: {\n        unions: config.numeric\n          ? () =>\n              FeatureProgrammer.write_union_functions(\n                configure(project)({ ...config, numeric: false })(importer),\n              )\n          : undefined,\n        arrays: () => write_array_functions(project)(config)(importer),\n        tuples: () => write_tuple_functions(project)(config)(importer),\n      },\n    });\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  /**\n   * @internal\n   */\n  export const decode =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: IExplore,\n    ): ts.Expression => {\n      if (meta.any) return config.success;\n\n      const top: IBinary[] = [];\n      const binaries: IBinary[] = [];\n      const add = create_add(binaries)(input);\n      const getConstantValue = (value: number | string | bigint | boolean) => {\n        if (typeof value === \"string\")\n          return ts.factory.createStringLiteral(value);\n        else if (typeof value === \"bigint\")\n          return ExpressionFactory.bigint(value);\n        return ts.factory.createIdentifier(value.toString());\n      };\n\n      //----\n      // CHECK OPTIONAL\n      //----\n      // @todo -> should be elaborated\n      const checkOptional: boolean = meta.empty() || meta.isUnionBucket();\n\n      // NULLABLE\n      if (checkOptional || meta.nullable)\n        (meta.nullable ? add : create_add(top)(input))(\n          meta.nullable,\n          ValueFactory.NULL(),\n        );\n\n      // UNDEFINDABLE\n      if (checkOptional || !meta.isRequired())\n        (meta.isRequired() ? create_add(top)(input) : add)(\n          !meta.isRequired(),\n          ValueFactory.UNDEFINED(),\n        );\n\n      // FUNCTIONAL\n      if (meta.functional === true)\n        if (OptionPredicator.functional(project.options) || meta.size() !== 1)\n          add(\n            true,\n            ts.factory.createStringLiteral(\"function\"),\n            ValueFactory.TYPEOF(input),\n          );\n        else\n          binaries.push({\n            combined: false,\n            expression: config.success,\n          });\n\n      //----\n      // VALUES\n      //----\n      // CONSTANT VALUES\n      for (const constant of meta.constants)\n        if (AtomicPredicator.constant(meta)(constant.type))\n          for (const v of constant.values) add(true, getConstantValue(v.value));\n      if (meta.escaped !== null)\n        binaries.push({\n          combined: false,\n          expression:\n            meta.escaped.original.size() === 1 &&\n            meta.escaped.original.natives.length === 1\n              ? check_native(meta.escaped.original.natives[0]!)(input)\n              : ts.factory.createLogicalAnd(\n                  decode(project)(config)(importer)(\n                    input,\n                    meta.escaped.original,\n                    explore,\n                  ),\n                  ts.factory.createLogicalAnd(\n                    IsProgrammer.decode_to_json(false)(input),\n                    decode_escaped(project)(config)(importer)(\n                      input,\n                      meta.escaped.returns,\n                      explore,\n                    ),\n                  ),\n                ),\n        });\n\n      // ATOMIC VALUES\n      for (const atom of meta.atomics)\n        if (AtomicPredicator.atomic(meta)(atom.type) === false) continue;\n        else if (atom.type === \"number\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_number(project, config.numeric)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else if (atom.type === \"bigint\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_bigint(project)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else if (atom.type === \"string\")\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_string(project)(atom)(input),\n            )(input),\n            combined: false,\n          });\n        else\n          add(\n            true,\n            ts.factory.createStringLiteral(atom.type),\n            ValueFactory.TYPEOF(input),\n          );\n\n      // TEMPLATE LITERAL VALUES\n      if (meta.templates.length)\n        if (AtomicPredicator.template(meta))\n          binaries.push({\n            expression: config.atomist(explore)(\n              check_template(meta.templates)(input),\n            )(input),\n            combined: false,\n          });\n\n      // NATIVE CLASSES\n      for (const native of meta.natives)\n        binaries.push({\n          expression: check_native(native)(input),\n          combined: false,\n        });\n\n      //----\n      // INSTANCES\n      //----\n      interface IInstance {\n        pre: ts.Expression;\n        body: ts.Expression | null;\n        expected: string;\n      }\n      const instances: IInstance[] = [];\n      const prepare =\n        (pre: ts.Expression, expected: string) =>\n        (body: ts.Expression | null) =>\n          instances.push({\n            pre,\n            expected,\n            body,\n          });\n\n      // SETS\n      if (meta.sets.length) {\n        const install = prepare(\n          check_native(\"Set\")(input),\n          meta.sets.map((elem) => `Set<${elem.getName()}>`).join(\" | \"),\n        );\n        if (meta.sets.some((elem) => elem.any)) install(null);\n        else\n          install(\n            explore_sets(project)(config)(importer)(input, meta.sets, {\n              ...explore,\n              from: \"array\",\n            }),\n          );\n      }\n\n      // MAPS\n      if (meta.maps.length) {\n        const install = prepare(\n          check_native(\"Map\")(input),\n          meta.maps\n            .map(({ key, value }) => `Map<${key}, ${value}>`)\n            .join(\" | \"),\n        );\n        if (meta.maps.some((elem) => elem.key.any && elem.value.any))\n          install(null);\n        else\n          install(\n            explore_maps(project)(config)(importer)(input, meta.maps, {\n              ...explore,\n              from: \"array\",\n            }),\n          );\n      }\n\n      // ARRAYS AND TUPLES\n      if (meta.tuples.length + meta.arrays.length > 0) {\n        const install = prepare(\n          config.atomist(explore)({\n            expected: [\n              ...meta.tuples.map((t) => t.type.name),\n              ...meta.arrays.map((a) => a.getName()),\n            ].join(\" | \"),\n            expression: ExpressionFactory.isArray(input),\n            conditions: [],\n          })(input),\n          [...meta.tuples, ...meta.arrays]\n            .map((elem) => elem.type.name)\n            .join(\" | \"),\n        );\n        if (meta.arrays.length === 0)\n          if (meta.tuples.length === 1)\n            install(\n              decode_tuple(project)(config)(importer)(input, meta.tuples[0]!, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n          // TUPLE ONLY\n          else\n            install(\n              explore_tuples(project)(config)(importer)(input, meta.tuples, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n        else if (meta.arrays.some((elem) => elem.type.value.any)) install(null);\n        else if (meta.tuples.length === 0)\n          if (meta.arrays.length === 1)\n            // ARRAY ONLY\n            install(\n              decode_array(project)(config)(importer)(input, meta.arrays[0]!, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n          else\n            install(\n              explore_arrays(project)(config)(importer)(input, meta.arrays, {\n                ...explore,\n                from: \"array\",\n              }),\n            );\n        else\n          install(\n            explore_arrays_and_tuples(project)(config)(importer)(\n              input,\n              [...meta.tuples, ...meta.arrays],\n              explore,\n            ),\n          );\n      }\n\n      // OBJECT\n      if (meta.objects.length > 0)\n        prepare(\n          ExpressionFactory.isObject({\n            checkNull: true,\n            checkArray: meta.objects.some((obj) =>\n              obj.properties.every(\n                (prop) => !prop.key.isSoleLiteral() || !prop.value.isRequired(),\n              ),\n            ),\n          })(input),\n          meta.objects.map((obj) => obj.name).join(\" | \"),\n        )(\n          explore_objects(config)(importer)(input, meta, {\n            ...explore,\n            from: \"object\",\n          }),\n        );\n\n      if (instances.length) {\n        const transformer =\n          (merger: (x: ts.Expression, y: ts.Expression) => ts.Expression) =>\n          (ins: IInstance) =>\n            ins.body\n              ? {\n                  expression: merger(ins.pre, ins.body),\n                  combined: true,\n                }\n              : {\n                  expression: ins.pre,\n                  combined: false,\n                };\n        if (instances.length === 1)\n          binaries.push(\n            transformer((pre, body) =>\n              config.combiner(explore)(\"and\")(\n                input,\n                [pre, body].map((expression) => ({\n                  expression,\n                  combined: expression !== pre,\n                })),\n                meta.getName(),\n              ),\n            )(instances[0]!),\n          );\n        else\n          binaries.push({\n            expression: config.combiner(explore)(\"or\")(\n              input,\n              instances.map(transformer(ts.factory.createLogicalAnd)),\n              meta.getName(),\n            ),\n            combined: true,\n          });\n      }\n\n      //----\n      // COMBINE CONDITIONS\n      //----\n      return top.length && binaries.length\n        ? config.combiner(explore)(\"and\")(\n            input,\n            [\n              ...top,\n              {\n                expression: config.combiner(explore)(\"or\")(\n                  input,\n                  binaries,\n                  meta.getName(),\n                ),\n                combined: true,\n              },\n            ],\n            meta.getName(),\n          )\n        : binaries.length\n          ? config.combiner(explore)(\"or\")(input, binaries, meta.getName())\n          : config.success;\n    };\n\n  export const decode_object =\n    (config: IConfig) => (importer: FunctionImporter) => {\n      const func = FeatureProgrammer.decode_object(config)(importer);\n      return (input: ts.Expression, obj: MetadataObject, explore: IExplore) => {\n        obj.validated = true;\n        return func(input, obj, explore);\n      };\n    };\n\n  const decode_array =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, array: MetadataArray, explore: IExplore) => {\n      if (array.type.recursive === false)\n        return decode_array_inline(project)(config)(importer)(\n          input,\n          array,\n          explore,\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.useLocal(`${config.prefix}a${array.type.index}`),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)({\n            ...explore,\n            source: \"function\",\n            from: \"array\",\n          })(input),\n        ),\n        config.joiner.failure(input, array.type.name, explore),\n      );\n    };\n\n  const decode_array_inline =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: IExplore,\n    ): ts.Expression => {\n      const length = check_array_length(project)(array)(input);\n      const main = FeatureProgrammer.decode_array({\n        prefix: config.prefix,\n        trace: config.trace,\n        path: config.path,\n        decoder: () => decode(project)(config)(importer),\n      })(importer)(config.joiner.array)(input, array, explore);\n      return length.expression === null && length.conditions.length === 0\n        ? main\n        : ts.factory.createLogicalAnd(\n            config.atomist(explore)(length)(input),\n            main,\n          );\n    };\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: IExplore,\n    ): ts.Expression => {\n      if (tuple.type.recursive === false)\n        return decode_tuple_inline(project)(config)(importer)(\n          input,\n          tuple.type,\n          explore,\n        );\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)({\n            ...explore,\n            source: \"function\",\n          })(input),\n        ),\n        config.joiner.failure(input, tuple.type.name, explore),\n      );\n    };\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: IExplore,\n    ): ts.Expression => {\n      const binaries: ts.Expression[] = tuple.elements\n        .filter((meta) => meta.rest === null)\n        .map((meta, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            meta,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest: ts.Expression | null =\n        tuple.elements.length && tuple.elements.at(-1)!.rest !== null\n          ? decode(project)(config)(importer)(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(input)(\"slice\"),\n                undefined,\n                [ExpressionFactory.number(tuple.elements.length - 1)],\n              ),\n              wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n              {\n                ...explore,\n                start: tuple.elements.length - 1,\n              },\n            )\n          : null;\n\n      const arrayLength = ts.factory.createPropertyAccessExpression(\n        input,\n        \"length\",\n      );\n      return config.combiner(explore)(\"and\")(\n        input,\n        [\n          ...(rest === null\n            ? tuple.elements.every((t) => t.optional === false)\n              ? [\n                  {\n                    combined: false,\n                    expression: ts.factory.createStrictEquality(\n                      arrayLength,\n                      ExpressionFactory.number(tuple.elements.length),\n                    ),\n                  },\n                ]\n              : [\n                  {\n                    combined: false,\n                    expression: ts.factory.createLogicalAnd(\n                      ts.factory.createLessThanEquals(\n                        ExpressionFactory.number(\n                          tuple.elements.filter((t) => t.optional === false)\n                            .length,\n                        ),\n                        arrayLength,\n                      ),\n                      ts.factory.createGreaterThanEquals(\n                        ExpressionFactory.number(tuple.elements.length),\n                        arrayLength,\n                      ),\n                    ),\n                  },\n                ]\n            : []),\n          ...(config.joiner.tuple\n            ? [\n                {\n                  expression: config.joiner.tuple(binaries),\n                  combined: true,\n                },\n              ]\n            : binaries.map((expression) => ({\n                expression,\n                combined: true,\n              }))),\n          ...(rest !== null\n            ? [\n                {\n                  expression: rest,\n                  combined: true,\n                },\n              ]\n            : []),\n        ],\n        `[${tuple.elements.map((t) => t.getName()).join(\", \")}]`,\n      );\n    };\n\n  const decode_escaped =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, meta: Metadata, explore: IExplore): ts.Expression =>\n      ts.factory.createCallExpression(\n        ts.factory.createParenthesizedExpression(\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n            undefined,\n            undefined,\n            decode(project)(config)(importer)(\n              ts.factory.createIdentifier(\"input\"),\n              meta,\n              explore,\n            ),\n          ),\n        ),\n        undefined,\n        [\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"toJSON\"),\n            undefined,\n            [],\n          ),\n        ],\n      );\n\n  /* -----------------------------------------------------------\n        UNION TYPE EXPLORERS\n    ----------------------------------------------------------- */\n  const explore_sets =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      sets: Metadata[],\n      explore: IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.set({\n          checker: decode(project)(config)(importer),\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        })([])(input, sets, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_maps =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      maps: Metadata.Entry[],\n      explore: IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.map({\n          checker: (input, entry, explore) => {\n            const func = decode(project)(config)(importer);\n            return ts.factory.createLogicalAnd(\n              func(\n                ts.factory.createElementAccessExpression(input, 0),\n                entry[0],\n                {\n                  ...explore,\n                  postfix: `${explore.postfix}[0]`,\n                },\n              ),\n              func(\n                ts.factory.createElementAccessExpression(input, 1),\n                entry[1],\n                {\n                  ...explore,\n                  postfix: `${explore.postfix}[1]`,\n                },\n              ),\n            );\n          },\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        })([])(input, maps, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_tuples =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuples: MetadataTuple[],\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.tuple({\n          checker: decode_tuple(project)(config)(importer),\n          decoder: decode_tuple(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, tuples, explore);\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      arrays: MetadataArray[],\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: decode(project)(config)(importer),\n          decoder: decode_array(project)(config)(importer),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, arrays, explore);\n\n  const explore_arrays_and_tuples =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: Array<MetadataArray | MetadataTuple>,\n      explore: IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array_or_tuple({\n          checker: (front, target, explore, array) =>\n            target instanceof MetadataTuple\n              ? decode_tuple(project)(config)(importer)(front, target, explore)\n              : config.atomist(explore)({\n                  expected: elements\n                    .map((elem) =>\n                      elem instanceof MetadataArray\n                        ? elem.getName()\n                        : elem.type.name,\n                    )\n                    .join(\" | \"),\n                  expression: decode(project)(config)(importer)(\n                    front,\n                    target,\n                    explore,\n                  ),\n                  conditions: [],\n                })(array),\n          decoder: (input, target, explore) =>\n            target instanceof MetadataTuple\n              ? decode_tuple(project)(config)(importer)(input, target, explore)\n              : decode_array(project)(config)(importer)(input, target, explore),\n          empty: config.success,\n          success: config.success,\n          failure: (input, expected, explore) =>\n            ts.factory.createReturnStatement(\n              config.joiner.failure(input, expected, explore),\n            ),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (input: ts.Expression, elements: T[], explore: IExplore): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createLogicalOr(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\n            importer.emplaceUnion(\n              config.prefix,\n              elements.map((e) => e.type.name).join(\" | \"),\n              () =>\n                arrow(\n                  FeatureProgrammer.parameterDeclarations(config)(\n                    TypeFactory.keyword(\"any\"),\n                  )(ts.factory.createIdentifier(\"input\")),\n                )({\n                  ...explore,\n                  postfix: \"\",\n                })(ts.factory.createIdentifier(\"input\")),\n            ),\n          ),\n          undefined,\n          FeatureProgrammer.argumentsArray(config)(explore)(input),\n        ),\n        config.joiner.failure(\n          input,\n          elements.map((e) => e.type.name).join(\" | \"),\n          explore,\n        ),\n      );\n    };\n\n  const explore_objects =\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, meta: Metadata, explore: IExplore) =>\n      meta.objects.length === 1\n        ? decode_object(config)(importer)(input, meta.objects[0]!, explore)\n        : ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}u${meta.union_index!}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)(explore)(input),\n          );\n}\n\nconst create_add =\n  (binaries: CheckerProgrammer.IBinary[]) =>\n  (defaultInput: ts.Expression) =>\n  (\n    exact: boolean,\n    left: ts.Expression,\n    right: ts.Expression = defaultInput,\n  ) => {\n    const factory = exact\n      ? ts.factory.createStrictEquality\n      : ts.factory.createStrictInequality;\n    binaries.push({\n      expression: factory(left, right),\n      combined: false,\n    });\n  };\n"]}