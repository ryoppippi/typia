{"version":3,"sources":["../src/programmers/helpers/NotationJoiner.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nimport { metadata_to_pattern } from \"../internal/metadata_to_pattern\";\nimport { IExpressionEntry } from \"./IExpressionEntry\";\n\nexport namespace NotationJoiner {\n  export const object =\n    (rename: (str: string) => string) =>\n    (\n      input: ts.Expression,\n      entries: IExpressionEntry<ts.Expression>[],\n    ): ts.ConciseBody => {\n      if (entries.length === 0) return ts.factory.createIdentifier(\"{}\");\n\n      const regular = entries.filter((e) => e.key.isSoleLiteral());\n      const dynamic = entries.filter((e) => !e.key.isSoleLiteral());\n      const literal = ts.factory.createObjectLiteralExpression(\n        regular.map((entry) => {\n          const str: string = rename(entry.key.getSoleLiteral()!);\n          return ts.factory.createPropertyAssignment(\n            Escaper.variable(str) ? str : ts.factory.createStringLiteral(str),\n            entry.expression,\n          );\n        }),\n        true,\n      );\n      if (dynamic.length === 0) return literal;\n\n      const key = ts.factory.createIdentifier(\"key\");\n      const output = ts.factory.createIdentifier(\"output\");\n\n      const statements: ts.Statement[] = [];\n      if (regular.length !== 0)\n        statements.push(\n          ts.factory.createIfStatement(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(\n                ts.factory.createArrayLiteralExpression(\n                  regular.map((r) =>\n                    ts.factory.createStringLiteral(r.key.getSoleLiteral()!),\n                  ),\n                ),\n              )(\"some\"),\n              undefined,\n              [\n                ts.factory.createArrowFunction(\n                  undefined,\n                  undefined,\n                  [IdentifierFactory.parameter(\"regular\")],\n                  undefined,\n                  undefined,\n                  ts.factory.createStrictEquality(\n                    ts.factory.createIdentifier(\"regular\"),\n                    ts.factory.createIdentifier(\"key\"),\n                  ),\n                ),\n              ],\n            ),\n            ts.factory.createContinueStatement(),\n          ),\n        );\n      statements.push(\n        ...dynamic.map((entry) =>\n          ts.factory.createIfStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\n                `RegExp(/${metadata_to_pattern(true)(entry.key)}/).test`,\n              ),\n              undefined,\n              [key],\n            ),\n            ts.factory.createBlock([\n              ts.factory.createExpressionStatement(\n                ts.factory.createBinaryExpression(\n                  ts.factory.createElementAccessExpression(output, key),\n                  ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                  entry.expression,\n                ),\n              ),\n              ts.factory.createContinueStatement(),\n            ]),\n          ),\n        ),\n      );\n\n      return ts.factory.createBlock([\n        StatementFactory.constant(\n          \"output\",\n          ts.factory.createAsExpression(literal, TypeFactory.keyword(\"any\")),\n        ),\n        ts.factory.createForOfStatement(\n          undefined,\n          StatementFactory.entry(\"key\")(\"value\"),\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Object.entries\"),\n            undefined,\n            [input],\n          ),\n          ts.factory.createBlock(statements),\n        ),\n        ts.factory.createReturnStatement(output),\n      ]);\n    };\n\n  export const tuple = (\n    children: ts.Expression[],\n    rest: ts.Expression | null,\n  ): ts.Expression => {\n    return ts.factory.createAsExpression(\n      ts.factory.createArrayLiteralExpression(\n        rest === null\n          ? children\n          : [...children, ts.factory.createSpreadElement(rest)],\n        true,\n      ),\n      TypeFactory.keyword(\"any\"),\n    );\n  };\n\n  export const array = (input: ts.Expression, arrow: ts.Expression) =>\n    ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(input, \"map\"),\n      undefined,\n      [arrow],\n    );\n}\n"],"mappings":"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","names":["ts","NotationJoiner","object","rename","input","entries","length","ts","factory","createIdentifier","regular","filter","e","key","isSoleLiteral","dynamic","literal","createObjectLiteralExpression","map","entry","str","getSoleLiteral","createPropertyAssignment","Escaper","variable","createStringLiteral","expression","output","statements","push","createIfStatement","createCallExpression","IdentifierFactory","access","createArrayLiteralExpression","r","undefined","createArrowFunction","parameter","createStrictEquality","createContinueStatement","metadata_to_pattern","createBlock","createExpressionStatement","createBinaryExpression","createElementAccessExpression","createToken","SyntaxKind","EqualsToken","StatementFactory","constant","createAsExpression","TypeFactory","keyword","createForOfStatement","createReturnStatement","tuple","children","rest","createSpreadElement","array","arrow","createPropertyAccessExpression"]}