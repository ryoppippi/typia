{"version":3,"sources":["../src/factories/internal/metadata/iterate_metadata_atomic.ts"],"names":["ts","same","type","flag","getFlags","iterate_metadata_atomic","meta","filter","check","info","atomic","literal","ArrayUtil","add","atomics","MetadataAtomic","create","name","tags","x","y","ATOMICS","some","TypeFlags","BooleanLike","BooleanLiteral","NumberLike","NumberLiteral","BigInt","BigIntLiteral","StringLike","StringLiteral"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;AAOf,IAAMC,OAAO,wBAACC,SAAAA;AACZ,MAAIA,SAAS,KAAM,QAAO,MAAM;AAChC,SAAO,CAACC,UAAwBD,KAAKE,SAAQ,IAAKD,UAAU;AAC9D,GAHa;AAKN,IAAME,0BAA0B,wBACrCC,MACAJ,SAAAA;AAGA,QAAMK,SAASN,KAAKC,IAAAA;AACpB,QAAMM,QAAQ,wBAACC,SAAAA;AACb,QAAIF,OAAOE,KAAKC,MAAM,KAAKH,OAAOE,KAAKE,OAAO,GAAG;AAC/CC,gBAAUC,IACRP,KAAKQ,SACLC,eAAeC,OAAO;QAAEd,MAAMO,KAAKQ;QAAMC,MAAM,CAAA;MAAG,CAAA,GAClD,CAACC,GAAGC,MAAMD,EAAEjB,SAASkB,EAAElB,IAAI;AAE7B,aAAO;IACT;AACA,WAAO;EACT,GAVc;AAad,SAAOmB,QAAQC,KAAK,CAACb,SAASD,MAAMC,IAAAA,CAAAA;AACtC,GApBuC;AAsBvC,IAAMY,UAAyB;EAC7B;IACEJ,MAAM;IACNP,QAAQV,GAAGuB,UAAUC;IACrBb,SAASX,GAAGuB,UAAUE;EACxB;EACA;IACER,MAAM;IACNP,QAAQV,GAAGuB,UAAUG;IACrBf,SAASX,GAAGuB,UAAUI;EACxB;EACA;IACEV,MAAM;IACNP,QAAQV,GAAGuB,UAAUK;IACrBjB,SAASX,GAAGuB,UAAUM;EACxB;EACA;IACEZ,MAAM;IACNP,QAAQV,GAAGuB,UAAUO;IACrBnB,SAASX,GAAGuB,UAAUQ;EACxB","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAtomic } from \"../../../schemas/metadata/MetadataAtomic\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nconst same = (type: ts.Type | null) => {\n  if (type === null) return () => false;\n  return (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n};\n\nexport const iterate_metadata_atomic = (\n  meta: Metadata,\n  type: ts.Type,\n): boolean => {\n  // PREPARE INTERNAL FUNCTIONS\n  const filter = same(type);\n  const check = (info: IAtomicInfo) => {\n    if (filter(info.atomic) || filter(info.literal)) {\n      ArrayUtil.add(\n        meta.atomics,\n        MetadataAtomic.create({ type: info.name, tags: [] }),\n        (x, y) => x.type === y.type,\n      );\n      return true;\n    }\n    return false;\n  };\n\n  // CHECK EACH TYPES\n  return ATOMICS.some((info) => check(info));\n};\n\nconst ATOMICS: IAtomicInfo[] = [\n  {\n    name: \"boolean\",\n    atomic: ts.TypeFlags.BooleanLike,\n    literal: ts.TypeFlags.BooleanLiteral,\n  },\n  {\n    name: \"number\",\n    atomic: ts.TypeFlags.NumberLike,\n    literal: ts.TypeFlags.NumberLiteral,\n  },\n  {\n    name: \"bigint\",\n    atomic: ts.TypeFlags.BigInt,\n    literal: ts.TypeFlags.BigIntLiteral,\n  },\n  {\n    name: \"string\",\n    atomic: ts.TypeFlags.StringLike,\n    literal: ts.TypeFlags.StringLiteral,\n  },\n];\n\ninterface IAtomicInfo {\n  name: \"boolean\" | \"number\" | \"bigint\" | \"string\";\n  atomic: ts.TypeFlags;\n  literal: ts.TypeFlags;\n}\n"]}