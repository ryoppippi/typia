{"version":3,"sources":["../src/programmers/misc/MiscLiteralsProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nexport namespace MiscLiteralsProgrammer {\n  export const write = (project: IProject) => (type: ts.Type) => {\n    const result = MetadataFactory.analyze(\n      project.checker,\n      project.context,\n    )({\n      escape: true,\n      constant: true,\n      absorb: true,\n      validate: (meta) => {\n        const length: number =\n          meta.constants\n            .map((c) => c.values.length)\n            .reduce((a, b) => a + b, 0) +\n          meta.atomics.filter((a) => a.type === \"boolean\").length;\n        if (0 === length) return [ErrorMessages.NO];\n        else if (meta.size() !== length) return [ErrorMessages.ONLY];\n        return [];\n      },\n    })(new MetadataCollection())(type);\n    if (result.success === false)\n      throw TransformerError.from(`typia.misc.literals`)(result.errors);\n\n    const meta: Metadata = result.data;\n    const values: Set<Atomic.Type | null> = new Set([\n      ...meta.constants.map((c) => c.values.map((v) => v.value)).flat(),\n      ...(meta.atomics.filter((a) => a.type === \"boolean\").length\n        ? [true, false]\n        : []),\n      ...(meta.nullable ? [null] : []),\n    ]);\n    return ts.factory.createAsExpression(\n      ts.factory.createArrayLiteralExpression(\n        [...values].map((v) =>\n          v === null\n            ? ts.factory.createNull()\n            : typeof v === \"boolean\"\n              ? v\n                ? ts.factory.createTrue()\n                : ts.factory.createFalse()\n              : typeof v === \"number\"\n                ? ExpressionFactory.number(v)\n                : typeof v === \"bigint\"\n                  ? ExpressionFactory.bigint(Number(v))\n                  : ts.factory.createStringLiteral(v),\n        ),\n        true,\n      ),\n      ts.factory.createTypeReferenceNode(\"const\"),\n    );\n  };\n}\n\nenum ErrorMessages {\n  NO = \"no constant literal type found.\",\n  ONLY = \"only constant literal types are allowed.\",\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAaEC,yBAAAA;0BACFC,QAAQ,CAACC,YAAsB,CAACC,SAAAA;AAC3C,UAAMC,SAASC,gBAAgBC,QAC7BJ,QAAQK,SACRL,QAAQM,OAAO,EACf;MACAC,QAAQ;MACRC,UAAU;MACVC,QAAQ;MACRC,UAAU,wBAACC,UAAAA;AACT,cAAMC,SACJD,MAAKE,UACFC,IAAI,CAACC,MAAMA,EAAEC,OAAOJ,MAAM,EAC1BK,OAAO,CAACC,GAAGC,MAAMD,IAAIC,GAAG,CAAA,IAC3BR,MAAKS,QAAQC,OAAO,CAACH,MAAMA,EAAEjB,SAAS,SAAA,EAAWW;AACnD,YAAI,MAAMA,OAAQ,QAAO;;;iBAChBD,MAAKW,KAAI,MAAOV,OAAQ,QAAO;;;AACxC,eAAO,CAAA;MACT,GATU;IAUZ,CAAA,EAAG,IAAIW,mBAAAA,CAAAA,EAAsBtB,IAAAA;AAC7B,QAAIC,OAAOsB,YAAY,MACrB,OAAMC,iBAAiBC,KAAK,qBAAqB,EAAExB,OAAOyB,MAAM;AAElE,UAAMhB,OAAiBT,OAAO0B;AAC9B,UAAMZ,SAAkC,oBAAIa,IAAI;SAC3ClB,KAAKE,UAAUC,IAAI,CAACC,MAAMA,EAAEC,OAAOF,IAAI,CAACgB,MAAMA,EAAEC,KAAK,CAAA,EAAGC,KAAI;SAC3DrB,KAAKS,QAAQC,OAAO,CAACH,MAAMA,EAAEjB,SAAS,SAAA,EAAWW,SACjD;QAAC;QAAM;UACP,CAAA;SACAD,KAAKsB,WAAW;QAAC;UAAQ,CAAA;KAC9B;AACD,WAAOC,GAAGC,QAAQC,mBAChBF,GAAGC,QAAQE,6BACT;SAAIrB;MAAQF,IAAI,CAACgB,MACfA,MAAM,OACFI,GAAGC,QAAQG,WAAU,IACrB,OAAOR,MAAM,YACXA,IACEI,GAAGC,QAAQI,WAAU,IACrBL,GAAGC,QAAQK,YAAW,IACxB,OAAOV,MAAM,WACXW,kBAAkBC,OAAOZ,CAAAA,IACzB,OAAOA,MAAM,WACXW,kBAAkBE,OAAOC,OAAOd,CAAAA,CAAAA,IAChCI,GAAGC,QAAQU,oBAAoBf,CAAAA,CAAAA,GAE3C,IAAA,GAEFI,GAAGC,QAAQW,wBAAwB,OAAA,CAAA;EAEvC;AACF,GAnDiBhD,2BAAAA,yBAAAA,CAAAA,EAAAA;;UAqDZiD,gBAAAA;;;GAAAA,kBAAAA,gBAAAA,CAAAA,EAAAA;","names":["ts","MiscLiteralsProgrammer","write","project","type","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","meta","length","constants","map","c","values","reduce","a","b","atomics","filter","size","MetadataCollection","success","TransformerError","from","errors","data","Set","v","value","flat","nullable","ts","factory","createAsExpression","createArrayLiteralExpression","createNull","createTrue","createFalse","ExpressionFactory","number","bigint","Number","createStringLiteral","createTypeReferenceNode","ErrorMessages"]}