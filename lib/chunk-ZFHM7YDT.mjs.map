{"version":3,"sources":["../src/programmers/notations/NotationGeneralProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { NotationJoiner } from \"../helpers/NotationJoiner\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\nimport { wrap_metadata_rest_tuple } from \"../internal/wrap_metadata_rest_tuple\";\n\nexport namespace NotationGeneralProgrammer {\n  export const returnType =\n    (rename: (str: string) => string) => (type: string) =>\n      `typia.${StringUtil.capitalize(rename.name)}Case<${type}>`;\n\n  export const write =\n    (rename: (str: string) => string) =>\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      return FeatureProgrammer.write(project)({\n        ...configure(rename)(project)(importer),\n        addition: (collection) => [\n          ...IsProgrammer.write_function_statements(project)(importer)(\n            collection,\n          ),\n          ...importer.declare(modulo),\n        ],\n      })(importer);\n    };\n\n  const write_array_functions =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      // ANY TYPE\n      if (\n        meta.any ||\n        meta.arrays.some((a) => a.type.value.any) ||\n        meta.tuples.some(\n          (t) =>\n            !!t.type.elements.length && t.type.elements.every((e) => e.any),\n        )\n      )\n        return ts.factory.createCallExpression(importer.use(\"any\"), undefined, [\n          input,\n        ]);\n\n      interface IUnion {\n        type: string;\n        is: () => ts.Expression;\n        value: () => ts.Expression;\n      }\n      const unions: IUnion[] = [];\n\n      //----\n      // LIST UP UNION TYPES\n      //----\n      // FUNCTIONAL\n      if (meta.functional)\n        unions.push({\n          type: \"functional\",\n          is: () =>\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"function\"),\n              ts.factory.createTypeOfExpression(input),\n            ),\n          value: () => ts.factory.createIdentifier(\"undefined\"),\n        });\n\n      // TUPLES\n      for (const tuple of meta.tuples)\n        unions.push({\n          type: \"tuple\",\n          is: () =>\n            IsProgrammer.decode(project)(importer)(\n              input,\n              (() => {\n                const partial = Metadata.initialize();\n                partial.tuples.push(tuple);\n                return partial;\n              })(),\n              explore,\n            ),\n          value: () =>\n            decode_tuple(project)(config)(importer)(input, tuple, explore),\n        });\n\n      // ARRAYS\n      if (meta.arrays.length)\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value: () =>\n            explore_arrays(project)(config)(importer)(input, meta.arrays, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // NATIVE TYPES\n      if (meta.sets.length)\n        unions.push({\n          type: \"set\",\n          is: () => ExpressionFactory.isInstanceOf(\"Set\")(input),\n          value: () =>\n            explore_sets(project)(config)(importer)(input, meta.sets, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n      if (meta.maps.length)\n        unions.push({\n          type: \"map\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: () =>\n            explore_maps(project)(config)(importer)(input, meta.maps, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n      for (const native of meta.natives) {\n        if (native === \"WeakSet\" || native === \"WeakMap\") continue;\n        unions.push({\n          type: \"native\",\n          is: () => ExpressionFactory.isInstanceOf(native)(input),\n          value: () =>\n            native === \"Boolean\" || native === \"Number\" || native === \"String\"\n              ? ts.factory.createCallExpression(\n                  IdentifierFactory.access(input)(\"valueOf\"),\n                  undefined,\n                  undefined,\n                )\n              : decode_native(native)(input),\n        });\n      }\n\n      // OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: false,\n            })(input),\n          value: () =>\n            explore_objects(config)(importer)(input, meta, {\n              ...explore,\n              from: \"object\",\n            }),\n        });\n\n      // COMPOSITION\n      let last: ts.Expression = input;\n      for (const u of unions.reverse())\n        last = ts.factory.createConditionalExpression(\n          u.is(),\n          undefined,\n          u.value(),\n          undefined,\n          last,\n        );\n      return ts.factory.createAsExpression(last, TypeFactory.keyword(\"any\"));\n    };\n\n  const decode_object = (importer: FunctionImporter) =>\n    FeatureProgrammer.decode_object({\n      trace: false,\n      path: false,\n      prefix: PREFIX,\n    })(importer);\n\n  const decode_array =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      array.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}a${array.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n              from: \"array\",\n            })(input),\n          )\n        : decode_array_inline(config)(importer)(input, array, explore);\n\n  const decode_array_inline =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      FeatureProgrammer.decode_array(config)(importer)(NotationJoiner.array)(\n        input,\n        array,\n        explore,\n      );\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n            })(input),\n          )\n        : decode_tuple_inline(project)(config)(importer)(\n            input,\n            tuple.type,\n            explore,\n          );\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const children: ts.Expression[] = tuple.elements\n        .filter((m) => m.rest === null)\n        .map((elem, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            elem,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest = (() => {\n        if (tuple.elements.length === 0) return null;\n\n        const last: Metadata = tuple.elements.at(-1)!;\n        const rest: Metadata | null = last.rest;\n        if (rest === null) return null;\n\n        return decode(project)(config)(importer)(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"slice\"),\n            undefined,\n            [ExpressionFactory.number(tuple.elements.length - 1)],\n          ),\n          wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n          {\n            ...explore,\n            start: tuple.elements.length - 1,\n          },\n        );\n      })();\n      return NotationJoiner.tuple(children, rest);\n    };\n\n  /* -----------------------------------------------------------\n        NATIVE CLASSES\n    ----------------------------------------------------------- */\n  const decode_native = (type: string) => (input: ts.Expression) =>\n    type === \"Date\"\n      ? ts.factory.createNewExpression(\n          ts.factory.createIdentifier(type),\n          undefined,\n          [input],\n        )\n      : input;\n\n  /* -----------------------------------------------------------\n        EXPLORERS FOR UNION TYPES\n    ----------------------------------------------------------- */\n  const explore_sets =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      sets: Metadata[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.set({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: (input, array, explore) =>\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Set\"),\n              [TypeFactory.keyword(\"any\")],\n              [decode_array(config)(importer)(input, array, explore)],\n            ),\n          empty: ts.factory.createNewExpression(\n            ts.factory.createIdentifier(\"Set\"),\n            [TypeFactory.keyword(\"any\")],\n            [],\n          ),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        })([])(input, sets, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_maps =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      maps: Metadata.Entry[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.map({\n          checker: (top, entry, explore) => {\n            const func = IsProgrammer.decode(project)(importer);\n            return ts.factory.createLogicalAnd(\n              func(ts.factory.createElementAccessExpression(top, 0), entry[0], {\n                ...explore,\n                postfix: `${explore.postfix}[0]`,\n              }),\n              func(ts.factory.createElementAccessExpression(top, 1), entry[1], {\n                ...explore,\n                postfix: `${explore.postfix}[1]`,\n              }),\n            );\n          },\n          decoder: (input, array, explore) =>\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Map\"),\n              [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n              [decode_array(config)(importer)(input, array, explore)],\n            ),\n          empty: ts.factory.createNewExpression(\n            ts.factory.createIdentifier(\"Map\"),\n            [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n            [],\n          ),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        })([])(input, maps, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_objects =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ) => {\n      if (meta.objects.length === 1)\n        return decode_object(importer)(input, meta.objects[0]!, explore);\n\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(`${PREFIX}u${meta.union_index!}`),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: MetadataArray[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: decode_array(config)(importer),\n          empty: ts.factory.createIdentifier(\"[]\"),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: FeatureProgrammer.IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (\n      input: ts.Expression,\n      elements: T[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: FeatureProgrammer.IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.emplaceUnion(\n            config.prefix,\n            elements.map((e) => e.type.name).join(\" | \"),\n            () =>\n              arrow(\n                FeatureProgrammer.parameterDeclarations(config)(\n                  TypeFactory.keyword(\"any\"),\n                )(ts.factory.createIdentifier(\"input\")),\n              )({\n                ...explore,\n                postfix: \"\",\n              })(ts.factory.createIdentifier(\"input\")),\n          ),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  /* -----------------------------------------------------------\n        CONFIGURATIONS\n    ----------------------------------------------------------- */\n  const PREFIX = \"$c\";\n\n  const configure =\n    (rename: (str: string) => string) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => {\n      const config: FeatureProgrammer.IConfig = {\n        types: {\n          input: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          output: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              returnType(rename)(\n                name ?? TypeFactory.getFullName(project.checker)(type),\n              ),\n            ),\n        },\n        prefix: PREFIX,\n        trace: false,\n        path: false,\n        initializer,\n        decoder: () => decode(project)(config)(importer),\n        objector: {\n          checker: () => IsProgrammer.decode(project)(importer),\n          decoder: () => decode_object(importer),\n          joiner: NotationJoiner.object(rename),\n          unionizer: decode_union_object(\n            IsProgrammer.decode_object(project)(importer),\n          )(decode_object(importer))((exp) => exp)((input, expected) =>\n            create_throw_error(importer)(expected)(input),\n          ),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        },\n        generator: {\n          arrays: () => write_array_functions(config)(importer),\n          tuples: () => write_tuple_functions(project)(config)(importer),\n        },\n      };\n      return config;\n    };\n\n  const initializer: FeatureProgrammer.IConfig[\"initializer\"] =\n    (project) => (importer) => (type) => {\n      const collection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.misc.${importer.method}`)(\n          result.errors,\n        );\n      return [collection, result.data];\n    };\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n"],"mappings":"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","names":["ts","NotationGeneralProgrammer","returnType","rename","type","StringUtil","capitalize","name","write","project","modulo","importer","FunctionImporter","getText","FeatureProgrammer","configure","addition","collection","IsProgrammer","write_function_statements","declare","write_array_functions","config","arrays","filter","a","recursive","map","i","StatementFactory","constant","prefix","ts","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","decode","input","meta","explore","any","some","value","elements","length","every","e","createCallExpression","use","unions","functional","push","is","createStrictEquality","createStringLiteral","createTypeOfExpression","partial","Metadata","initialize","decode_tuple","ExpressionFactory","isArray","explore_arrays","sets","isInstanceOf","explore_sets","maps","explore_maps","native","natives","IdentifierFactory","access","decode_native","objects","isObject","checkNull","checkArray","explore_objects","last","u","reverse","createConditionalExpression","createAsExpression","decode_object","path","PREFIX","decode_array","array","useLocal","index","argumentsArray","NotationJoiner","children","m","rest","elem","createElementAccessExpression","slice","at","number","wrap_metadata_rest_tuple","start","createNewExpression","UnionExplorer","set","checker","decoder","empty","success","createTrue","failure","expected","create_throw_error","top","entry","func","createLogicalAnd","union_index","explore_array_like_union_types","arrow","parameters","emplaceUnion","join","types","createTypeReferenceNode","getFullName","output","initializer","objector","joiner","object","unionizer","decode_union_object","exp","generator","MetadataCollection","result","MetadataFactory","analyze","context","escape","absorb","TransformerError","method","errors","data","createExpressionStatement","createObjectLiteralExpression","createPropertyAssignment"]}