{"version":3,"sources":["../src/programmers/misc/MiscCloneProgrammer.ts"],"names":["ts","MiscCloneProgrammer","write","project","modulo","importer","FunctionImporter","getText","FeatureProgrammer","configure","addition","collection","IsProgrammer","write_function_statements","declare","write_array_functions","config","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","decode","input","meta","explore","any","some","value","elements","length","every","e","createCallExpression","use","unions","functional","push","is","createStrictEquality","createStringLiteral","createTypeOfExpression","partial","Metadata","initialize","decode_tuple","ExpressionFactory","isArray","explore_arrays","sets","isInstanceOf","explore_sets","maps","explore_maps","native","natives","IdentifierFactory","access","decode_native","objects","isObject","checkNull","checkArray","explore_objects","last","u","reverse","createConditionalExpression","createAsExpression","decode_object","path","PREFIX","decode_array","array","useLocal","index","argumentsArray","CloneJoiner","children","m","rest","elem","createElementAccessExpression","slice","at","number","wrap_metadata_rest_tuple","start","decode_native_copyable","decode_native_buffer","decode_native_data_view","createNewExpression","selfCall","createBlock","createExpressionStatement","createReturnStatement","UnionExplorer","set","checker","decoder","empty","success","createTrue","failure","expected","create_throw_error","top","entry","func","createLogicalAnd","union_index","explore_array_like_union_types","arrow","parameters","emplaceUnion","name","join","types","createTypeReferenceNode","getFullName","output","createImportTypeNode","createLiteralTypeNode","initializer","objector","joiner","object","unionizer","decode_union_object","exp","generator","MetadataCollection","result","MetadataFactory","analyze","context","escape","absorb","validate","n","TransformerError","method","errors","data","createObjectLiteralExpression","createPropertyAssignment"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAyBEC,sBAAAA;uBACFC,QACX,CAACC,YAAsB,CAACC,WAAAA;AACtB,UAAMC,WAA6B,IAAIC,iBAAiBF,OAAOG,QAAO,CAAA;AACtE,WAAOC,kBAAkBN,MAAMC,OAAAA,EAAS;MACtC,GAAGM,UAAUN,OAAAA,EAASE,QAAAA;MACtBK,UAAU,wBAACC,eAAe;WACrBC,aAAaC,0BAA0BV,OAAAA,EAASE,QAAAA,EACjDM,UAAAA;WAECN,SAASS,QAAQV,MAAAA;SAJZ;IAMZ,CAAA,EAAGC,QAAAA;EACL;AAEF,QAAMU,wBACJ,wBAACC,WACD,CAACX,aACD,CAACM,eACCA,WACGM,OAAM,EACNC,OAAO,CAACC,MAAMA,EAAEC,SAAS,EACzBC,IAAI,CAACC,MAAMC,MACVC,iBAAiBC,SACf,GAAGT,OAAOU,MAAM,IAAIH,CAAAA,IACpBvB,GAAG2B,QAAQC,oBACTC,QACAA,QACArB,kBAAkBsB,sBAAsBd,MAAAA,EACtCe,YAAYC,QAAQ,KAAA,CAAA,EACpBhC,GAAG2B,QAAQM,iBAAiB,OAAA,CAAA,GAC9BF,YAAYC,QAAQ,KAAA,GACpBH,QACAK,oBAAoBlB,MAAAA,EAAQX,QAAAA,EAC1BL,GAAG2B,QAAQM,iBAAiB,OAAA,GAC5BE,cAAcC,OAAO;IACnBd;IACAe,MAAM,CAAA;EACR,CAAA,GACA;IACEC,UAAUtB,OAAOuB;IACjBC,QAAQ;IACRC,MAAM;IACNC,SAAS;EACX,CAAA,CAAA,CAAA,CAAA,GA5BZ;AAkCF,QAAMC,wBACJ,wBAACxC,YACD,CAACa,WACD,CAACX,aACD,CAACM,eACCA,WACGiC,OAAM,EACN1B,OAAO,CAAC2B,MAAMA,EAAEzB,SAAS,EACzBC,IAAI,CAACyB,OAAOvB,MACXC,iBAAiBC,SACf,GAAGT,OAAOU,MAAM,IAAIH,CAAAA,IACpBvB,GAAG2B,QAAQC,oBACTC,QACAA,QACArB,kBAAkBsB,sBAAsBd,MAAAA,EACtCe,YAAYC,QAAQ,KAAA,CAAA,EACpBhC,GAAG2B,QAAQM,iBAAiB,OAAA,CAAA,GAC9BF,YAAYC,QAAQ,KAAA,GACpBH,QACAkB,oBAAoB5C,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EACnCL,GAAG2B,QAAQM,iBAAiB,OAAA,GAC5Ba,OACA;IACER,UAAUtB,OAAOuB;IACjBC,QAAQ;IACRC,MAAM;IACNC,SAAS;EACX,CAAA,CAAA,CAAA,CAAA,GA1BZ;AAmCF,QAAMM,SACJ,wBAAC7C,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACAC,MACAC,YAAAA;AAGA,QACED,KAAKE,OACLF,KAAKjC,OAAOoC,KAAK,CAAClC,MAAMA,EAAEG,KAAKgC,MAAMF,GAAG,KACxCF,KAAKN,OAAOS,KACV,CAACR,MACC,CAAC,CAACA,EAAEvB,KAAKiC,SAASC,UAAUX,EAAEvB,KAAKiC,SAASE,MAAM,CAACC,MAAMA,EAAEN,GAAG,CAAA,EAGlE,QAAOpD,GAAG2B,QAAQgC,qBAAqBtD,SAASuD,IAAI,KAAA,GAAQ/B,QAAW;MACrEoB;KACD;AAOH,UAAMY,SAAmB,CAAA;AAMzB,QAAIX,KAAKY,WACPD,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BACFhE,GAAG2B,QAAQsC,qBACTjE,GAAG2B,QAAQuC,oBAAoB,UAAA,GAC/BlE,GAAG2B,QAAQwC,uBAAuBlB,KAAAA,CAAAA,GAHlC;MAKJK,OAAO,6BAAMtD,GAAG2B,QAAQM,iBAAiB,WAAA,GAAlC;IACT,CAAA;AAGF,eAAWa,SAASI,KAAKN,OACvBiB,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BACFpD,aAAaoC,OAAO7C,OAAAA,EAASE,QAAAA,EAC3B4C,QACC,MAAA;AACC,cAAMmB,UAAUC,SAASC,WAAU;AACnCF,gBAAQxB,OAAOmB,KAAKjB,KAAAA;AACpB,eAAOsB;MACT,GAAA,GACAjB,OAAAA,GARA;MAUJG,OAAO,6BACLiB,aAAapE,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOH,OAAOK,OAAAA,GADjD;IAET,CAAA;AAGF,QAAID,KAAKjC,OAAOuC,OACdK,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BAAMQ,kBAAkBC,QAAQxB,KAAAA,GAAhC;MACJK,OAAO,6BACLoB,eAAevE,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOC,KAAKjC,QAAQ;QAC5D,GAAGkC;QACHV,MAAM;MACR,CAAA,GAJK;IAKT,CAAA;AAGF,QAAIS,KAAKyB,KAAKnB,OACZK,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BAAMQ,kBAAkBI,aAAa,KAAA,EAAO3B,KAAAA,GAA5C;MACJK,OAAO,6BACLuB,aAAa1E,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOC,KAAKyB,MAAM;QACxD,GAAGxB;QACHV,MAAM;MACR,CAAA,GAJK;IAKT,CAAA;AACF,QAAIS,KAAK4B,KAAKtB,OACZK,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BAAMQ,kBAAkBI,aAAa,KAAA,EAAO3B,KAAAA,GAA5C;MACJK,OAAO,6BACLyB,aAAa5E,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOC,KAAK4B,MAAM;QACxD,GAAG3B;QACHV,MAAM;MACR,CAAA,GAJK;IAKT,CAAA;AACF,eAAWuC,UAAU9B,KAAK+B,QACxBpB,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BAAMQ,kBAAkBI,aAAaI,MAAAA,EAAQ/B,KAAAA,GAA7C;MACJK,OAAO,6BACL0B,WAAW,aAAaA,WAAW,YAAYA,WAAW,WACtDhF,GAAG2B,QAAQgC,qBACTuB,kBAAkBC,OAAOlC,KAAAA,EAAO,SAAA,GAChCpB,QACAA,MAAAA,IAEFuD,cAAcJ,MAAAA,EAAQ/B,KAAAA,GAPrB;IAQT,CAAA;AAGF,QAAIC,KAAKmC,QAAQ7B,OACfK,QAAOE,KAAK;MACVzC,MAAM;MACN0C,IAAI,6BACFQ,kBAAkBc,SAAS;QACzBC,WAAW;QACXC,YAAY;MACd,CAAA,EAAGvC,KAAAA,GAJD;MAKJK,OAAO,6BACLmC,gBAAgBzE,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOC,MAAM;QAC7C,GAAGC;QACHV,MAAM;MACR,CAAA,GAJK;IAKT,CAAA;AAGF,QAAIiD,OAAsBzC;AAC1B,eAAW0C,KAAK9B,OAAO+B,QAAO,EAC5BF,QAAO1F,GAAG2B,QAAQkE,4BAChBF,EAAE3B,GAAE,GACJnC,QACA8D,EAAErC,MAAK,GACPzB,QACA6D,IAAAA;AAEJ,WAAO1F,GAAG2B,QAAQmE,mBAAmBJ,MAAM3D,YAAYC,QAAQ,KAAA,CAAA;EACjE,GAvIA;AAyIF,QAAM+D,gBAAgB,wBAAC1F,aACrBG,kBAAkBuF,cAAc;IAC9BxD,OAAO;IACPyD,MAAM;IACNtE,QAAQuE;EACV,CAAA,EAAG5F,QAAAA,GALiB;AAOtB,QAAM6F,eACJ,wBAAClF,WACD,CAACX,aACD,CACE4C,OACAkD,OACAhD,YAEAgD,MAAM7E,KAAKF,YACPpB,GAAG2B,QAAQgC,qBACT3D,GAAG2B,QAAQM,iBACT5B,SAAS+F,SAAS,GAAGpF,OAAOU,MAAM,IAAIyE,MAAM7E,KAAK+E,KAAK,EAAE,CAAA,GAE1DxE,QACArB,kBAAkB8F,eAAetF,MAAAA,EAAQ;IACvC,GAAGmC;IACHX,QAAQ;IACRC,MAAM;EACR,CAAA,EAAGQ,KAAAA,CAAAA,IAELf,oBAAoBlB,MAAAA,EAAQX,QAAAA,EAAU4C,OAAOkD,OAAOhD,OAAAA,GAnB1D;AAqBF,QAAMjB,sBACJ,wBAAClB,WACD,CAACX,aACD,CACE4C,OACAkD,OACAhD,YAEA3C,kBAAkB0F,aAAalF,MAAAA,EAAQX,QAAAA,EAAUkG,YAAYJ,KAAK,EAChElD,OACAkD,OACAhD,OAAAA,GAVJ;AAaF,QAAMoB,eACJ,wBAACpE,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACAH,OACAK,YAEAL,MAAMxB,KAAKF,YACPpB,GAAG2B,QAAQgC,qBACT3D,GAAG2B,QAAQM,iBACT5B,SAAS+F,SAAS,GAAGpF,OAAOU,MAAM,IAAIoB,MAAMxB,KAAK+E,KAAK,EAAE,CAAA,GAE1DxE,QACArB,kBAAkB8F,eAAetF,MAAAA,EAAQ;IACvC,GAAGmC;IACHX,QAAQ;EACV,CAAA,EAAGS,KAAAA,CAAAA,IAELF,oBAAoB5C,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EACnC4C,OACAH,MAAMxB,MACN6B,OAAAA,GAtBR;AAyBF,QAAMJ,sBACJ,wBAAC5C,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACAH,OACAK,YAAAA;AAEA,UAAMqD,WAA4B1D,MAAMS,SACrCrC,OAAO,CAACuF,MAAMA,EAAEC,SAAS,IAAA,EACzBrF,IAAI,CAACsF,MAAMN,UACVrD,OAAO7C,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EACtBL,GAAG2B,QAAQiF,8BAA8B3D,OAAOoD,KAAAA,GAChDM,MACA;MACE,GAAGxD;MACHV,MAAM;MACNC,SAASS,QAAQT,QAAQc,SACrB,GAAGL,QAAQT,QAAQmE,MAAM,GAAG,EAAC,CAAA,IAAMR,KAAAA,OACnC,KAAKA,KAAAA;IACX,CAAA,CAAA;AAGN,UAAMK,QAAQ,MAAA;AACZ,UAAI5D,MAAMS,SAASC,WAAW,EAAG,QAAO;AAExC,YAAMkC,OAAiB5C,MAAMS,SAASuD,GAAG,EAAC;AAC1C,YAAMJ,QAAwBhB,KAAKgB;AACnC,UAAIA,UAAS,KAAM,QAAO;AAE1B,aAAO1D,OAAO7C,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,EAC7BL,GAAG2B,QAAQgC,qBACTuB,kBAAkBC,OAAOlC,KAAAA,EAAO,OAAA,GAChCpB,QACA;QAAC2C,kBAAkBuC,OAAOjE,MAAMS,SAASC,SAAS,CAAA;OAAG,GAEvDwD,yBAAyBlE,MAAMS,SAASuD,GAAG,EAAC,EAAIJ,IAAI,GACpD;QACE,GAAGvD;QACH8D,OAAOnE,MAAMS,SAASC,SAAS;MACjC,CAAA;IAEJ,GAAA;AACA,WAAO+C,YAAYzD,MAAM0D,UAAUE,IAAAA;EACrC,GA5CA;AAiDF,QAAMtB,gBAAgB,wBAAC9D,SAAiB,CAAC2B,UACvC3B,SAAS,UACTA,SAAS,gBACTA,SAAS,uBACTA,SAAS,iBACTA,SAAS,iBACTA,SAAS,oBACTA,SAAS,eACTA,SAAS,gBACTA,SAAS,gBACTA,SAAS,mBACTA,SAAS,kBACTA,SAAS,iBACL4F,uBAAuB5F,IAAAA,EAAM2B,KAAAA,IAC7B3B,SAAS,iBAAiBA,SAAS,sBACjC6F,qBAAqB7F,IAAAA,EAAM2B,KAAAA,IAC3B3B,SAAS,aACP8F,wBAAwBnE,KAAAA,IACxBjD,GAAG2B,QAAQgC,qBACT3D,GAAG2B,QAAQM,iBAAiBX,IAAAA,GAC5BO,QACA,CAAA,CAAE,GArBQ;AAwBtB,QAAMqF,yBAAyB,wBAAC5F,SAAiB,CAAC2B,UAChDjD,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiBX,IAAAA,GAC5BO,QACA;IAACoB;GAAM,GAJoB;AAO/B,QAAMkE,uBACJ,wBAAC7F,SAA8C,CAAC2B,UAC9CuB,kBAAkB8C,SAChBtH,GAAG2B,QAAQ4F,YACT;IACE/F,iBAAiBC,SACf,UACAzB,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiBX,IAAAA,GAC5BO,QACA;MAACqD,kBAAkBC,OAAOlC,KAAAA,EAAO,YAAA;KAAc,CAAA;IAGnDjD,GAAG2B,QAAQ6F,0BACTxH,GAAG2B,QAAQgC,qBACTuB,kBAAkBC,OAChBnF,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiB,YAAA,GAC5BJ,QACA;MAAC7B,GAAG2B,QAAQM,iBAAiB,QAAA;KAAU,CAAA,EAEzC,KAAA,GACFJ,QACA;MACE7B,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiB,YAAA,GAC5BJ,QACA;QAACoB;OAAM;KAEV,CAAA;IAGLjD,GAAG2B,QAAQ8F,sBACTzH,GAAG2B,QAAQM,iBAAiB,QAAA,CAAA;KAGhC,IAAA,CAAA,GAnCN;AAuCF,QAAMmF,0BAA0B,wBAACnE,UAC/BjD,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiB,UAAA,GAC5BJ,QACA;IAACqD,kBAAkBC,OAAOlC,KAAAA,EAAO,QAAA;GAAU,GAJf;AAUhC,QAAM4B,eACJ,wBAAC1E,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACA0B,MACAxB,YAEAnD,GAAG2B,QAAQgC,qBACT+D,cAAcC,IAAI;IAChBC,SAAShH,aAAaoC,OAAO7C,OAAAA,EAASE,QAAAA;IACtCwH,SAAS,wBAAC5E,QAAOkD,OAAOhD,aACtBnD,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiB,KAAA,GAC5B;MAACF,YAAYC,QAAQ,KAAA;OACrB;MAACkE,aAAalF,MAAAA,EAAQX,QAAAA,EAAU4C,QAAOkD,OAAOhD,QAAAA;KAAS,GAJlD;IAMT2E,OAAO9H,GAAG2B,QAAQ0F,oBAChBrH,GAAG2B,QAAQM,iBAAiB,KAAA,GAC5B;MAACF,YAAYC,QAAQ,KAAA;OACrB,CAAA,CAAE;IAEJ+F,SAAS/H,GAAG2B,QAAQqG,WAAU;IAC9BC,SAAS,wBAAChF,QAAOiF,aACfC,mBAAmB9H,QAAAA,EAAU6H,QAAAA,EAAUjF,MAAAA,GADhC;EAEX,CAAA,EAAG,CAAA,CAAE,EAAEA,OAAO0B,MAAMxB,OAAAA,GACpBtB,QACAA,MAAAA,GA3BJ;AA8BF,QAAMkD,eACJ,wBAAC5E,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACA6B,MACA3B,YAEAnD,GAAG2B,QAAQgC,qBACT+D,cAAcrG,IAAI;IAChBuG,SAAS,wBAACQ,KAAKC,OAAOlF,aAAAA;AACpB,YAAMmF,OAAO1H,aAAaoC,OAAO7C,OAAAA,EAASE,QAAAA;AAC1C,aAAOL,GAAG2B,QAAQ4G,iBAChBD,KAAKtI,GAAG2B,QAAQiF,8BAA8BwB,KAAK,CAAA,GAAIC,MAAM,CAAA,GAAI;QAC/D,GAAGlF;QACHT,SAAS,GAAGS,SAAQT,OAAO;MAC7B,CAAA,GACA4F,KAAKtI,GAAG2B,QAAQiF,8BAA8BwB,KAAK,CAAA,GAAIC,MAAM,CAAA,GAAI;QAC/D,GAAGlF;QACHT,SAAS,GAAGS,SAAQT,OAAO;MAC7B,CAAA,CAAA;IAEJ,GAZS;IAaTmF,SAAS,wBAAC5E,QAAOkD,OAAOhD,aACtBnD,GAAG2B,QAAQ0F,oBACTrH,GAAG2B,QAAQM,iBAAiB,KAAA,GAC5B;MAACF,YAAYC,QAAQ,KAAA;MAAQD,YAAYC,QAAQ,KAAA;OACjD;MAACkE,aAAalF,MAAAA,EAAQX,QAAAA,EAAU4C,QAAOkD,OAAOhD,QAAAA;KAAS,GAJlD;IAMT2E,OAAO9H,GAAG2B,QAAQ0F,oBAChBrH,GAAG2B,QAAQM,iBAAiB,KAAA,GAC5B;MAACF,YAAYC,QAAQ,KAAA;MAAQD,YAAYC,QAAQ,KAAA;OACjD,CAAA,CAAE;IAEJ+F,SAAS/H,GAAG2B,QAAQqG,WAAU;IAC9BC,SAAS,wBAAChF,QAAOiF,aACfC,mBAAmB9H,QAAAA,EAAU6H,QAAAA,EAAUjF,MAAAA,GADhC;EAEX,CAAA,EAAG,CAAA,CAAE,EAAEA,OAAO6B,MAAM3B,OAAAA,GACpBtB,QACAA,MAAAA,GAvCJ;AA0CF,QAAM4D,kBACJ,wBAACzE,WACD,CAACX,aACD,CACE4C,OACAC,MACAC,YAAAA;AAEA,QAAID,KAAKmC,QAAQ7B,WAAW,EAC1B,QAAOuC,cAAc1F,QAAAA,EAAU4C,OAAOC,KAAKmC,QAAQ,CAAA,GAAKlC,OAAAA;AAE1D,WAAOnD,GAAG2B,QAAQgC,qBAChB3D,GAAG2B,QAAQM,iBACT5B,SAAS+F,SAAS,GAAGH,MAAAA,IAAU/C,KAAKsF,WAAW,EAAG,CAAA,GAEpD3G,QACArB,kBAAkB8F,eAAetF,MAAAA,EAAQmC,OAAAA,EAASF,KAAAA,CAAAA;EAEtD,GAjBA;AAmBF,QAAMyB,iBACJ,wBAACvE,YACD,CAACa,WACD,CAACX,aACD,CACE4C,OACAM,UACAJ,YAEAsF,+BAA+BzH,MAAAA,EAAQX,QAAAA,EACrCqH,cAAcvB,MAAM;IAClByB,SAAShH,aAAaoC,OAAO7C,OAAAA,EAASE,QAAAA;IACtCwH,SAAS3B,aAAalF,MAAAA,EAAQX,QAAAA;IAC9ByH,OAAO9H,GAAG2B,QAAQM,iBAAiB,IAAA;IACnC8F,SAAS/H,GAAG2B,QAAQqG,WAAU;IAC9BC,SAAS,wBAAChF,QAAOiF,aACfC,mBAAmB9H,QAAAA,EAAU6H,QAAAA,EAAUjF,MAAAA,GADhC;EAEX,CAAA,CAAA,EACAA,OAAOM,UAAUJ,OAAAA,GAjBrB;AAmBF,QAAMsF,iCACJ,wBAACzH,WACD,CAACX,aACD,CACEsB,YAQF,CACEsB,OACAM,UACAJ,YAAAA;AAEA,UAAMuF,QACJ,wBAACC,eACD,CAACxF,aACD,CAACF,WACCtB,QAAQgH,UAAAA,EAAY1F,QAAOM,UAAUJ,QAAAA,GAHvC;AAIF,QAAII,SAASE,MAAM,CAACC,MAAMA,EAAEpC,KAAKF,cAAc,KAAA,EAC7CpB,IAAG2B,QAAQgC,qBACT+E,MAAM,CAAA,CAAE,EAAEvF,OAAAA,EAASF,KAAAA,GACnBpB,QACA,CAAA,CAAE;AAGNsB,cAAU;MACR,GAAGA;MACHX,QAAQ;MACRC,MAAM;IACR;AACA,WAAOzC,GAAG2B,QAAQgC,qBAChB3D,GAAG2B,QAAQM,iBACT5B,SAASuI,aACP5H,OAAOU,QACP6B,SAASlC,IAAI,CAACqC,MAAMA,EAAEpC,KAAKuH,IAAI,EAAEC,KAAK,KAAA,GACtC,MACEJ,MACElI,kBAAkBsB,sBAAsBd,MAAAA,EACtCe,YAAYC,QAAQ,KAAA,CAAA,EACpBhC,GAAG2B,QAAQM,iBAAiB,OAAA,CAAA,CAAA,EAC9B;MACA,GAAGkB;MACHT,SAAS;IACX,CAAA,EAAG1C,GAAG2B,QAAQM,iBAAiB,OAAA,CAAA,CAAA,CAAA,GAGrCJ,QACArB,kBAAkB8F,eAAetF,MAAAA,EAAQmC,OAAAA,EAASF,KAAAA,CAAAA;EAEtD,GApDA;AAyDF,QAAMgD,SAAS;AAEf,QAAMxF,YACJ,wBAACN,YACD,CAACE,aAAAA;AACC,UAAMW,SAAoC;MACxC+H,OAAO;QACL9F,OAAO,wBAAC3B,MAAMuH,SACZ7I,GAAG2B,QAAQqH,wBACTH,QAAQ9G,YAAYkH,YAAY9I,QAAQyH,OAAO,EAAEtG,IAAAA,CAAAA,GAF9C;QAIP4H,QAAQ,wBAAC5H,MAAMuH,SACb7I,GAAG2B,QAAQwH,qBACTnJ,GAAG2B,QAAQyH,sBACTpJ,GAAG2B,QAAQuC,oBAAoB,OAAA,CAAA,GAEjCrC,QACA7B,GAAG2B,QAAQM,iBAAiB,UAAA,GAC5B;UACEjC,GAAG2B,QAAQqH,wBACTH,QAAQ9G,YAAYkH,YAAY9I,QAAQyH,OAAO,EAAEtG,IAAAA,CAAAA;WAGrD,KAAA,GAZI;MAcV;MACAI,QAAQuE;MACR1D,OAAO;MACPyD,MAAM;MACNqD;MACAxB,SAAS,6BAAM7E,OAAO7C,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,GAA9B;MACTiJ,UAAU;QACR1B,SAAS,6BAAMhH,aAAaoC,OAAO7C,OAAAA,EAASE,QAAAA,GAAnC;QACTwH,SAAS,6BAAM9B,cAAc1F,QAAAA,GAApB;QACTkJ,QAAQhD,YAAYiD;QACpBC,WAAWC,oBACT9I,aAAamF,cAAc5F,OAAAA,EAASE,QAAAA,CAAAA,EACpC0F,cAAc1F,QAAAA,CAAAA,EAAW,CAACsJ,QAAQA,GAAAA,EAAK,CAAC1G,OAAOiF,aAC/CC,mBAAmB9H,QAAAA,EAAU6H,QAAAA,EAAUjF,KAAAA,CAAAA;QAEzCgF,SAAS,wBAAChF,OAAOiF,aACfC,mBAAmB9H,QAAAA,EAAU6H,QAAAA,EAAUjF,KAAAA,GADhC;MAEX;MACA2G,WAAW;QACT3I,QAAQ,6BAAMF,sBAAsBC,MAAAA,EAAQX,QAAAA,GAApC;QACRuC,QAAQ,6BAAMD,sBAAsBxC,OAAAA,EAASa,MAAAA,EAAQX,QAAAA,GAA7C;MACV;IACF;AACA,WAAOW;EACT,GA9CA;AAgDF,QAAMqI,cACJ,wBAAClJ,YAAY,CAACE,aAAa,CAACiB,SAAAA;AAC1B,UAAMX,aAAa,IAAIkJ,mBAAAA;AACvB,UAAMC,SAASC,gBAAgBC,QAC7B7J,QAAQyH,SACRzH,QAAQ8J,OAAO,EACf;MACAC,QAAQ;MACRzI,UAAU;MACV0I,QAAQ;MACRC,UAAU,wBAAClH,SAAAA;AACT,cAAMgG,SAAmB,CAAA;AACzB,YAAIhG,KAAK+B,QAAQ5B,KAAK,CAACgH,MAAMA,MAAM,SAAA,EACjCnB,QAAOnF,KAAK,yBAAA;iBACLb,KAAK+B,QAAQ5B,KAAK,CAACgH,MAAMA,MAAM,SAAA,EACtCnB,QAAOnF,KAAK,yBAAA;AACd,eAAOmF;MACT,GAPU;IAQZ,CAAA,EAAGvI,UAAAA,EAAYW,IAAAA;AACf,QAAIwI,OAAO/B,YAAY,MACrB,OAAMuC,iBAAiB7H,KAAK,cAAcpC,SAASkK,MAAM,EAAE,EACzDT,OAAOU,MAAM;AAEjB,WAAO;MAAC7J;MAAYmJ,OAAOW;;EAC7B,GAvBA;AAyBF,QAAMtC,qBACJ,wBAAC9H,aACD,CAAC6H,aACD,CAAC5E,UACCtD,GAAG2B,QAAQ6F,0BACTxH,GAAG2B,QAAQgC,qBACTtD,SAASuD,IAAI,QAAA,GACb,CAAA,GACA;IACE5D,GAAG2B,QAAQ+I,8BACT;MACE1K,GAAG2B,QAAQgJ,yBACT,YACA3K,GAAG2B,QAAQuC,oBAAoBgE,QAAAA,CAAAA;MAEjClI,GAAG2B,QAAQgJ,yBAAyB,SAASrH,KAAAA;OAE/C,IAAA;GAEH,CAAA,GAlBP;AAqBJ,GAvrBiBrD,wBAAAA,sBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { CloneJoiner } from \"../helpers/CloneJoiner\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\nimport { wrap_metadata_rest_tuple } from \"../internal/wrap_metadata_rest_tuple\";\n\nexport namespace MiscCloneProgrammer {\n  export const write =\n    (project: IProject) => (modulo: ts.LeftHandSideExpression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      return FeatureProgrammer.write(project)({\n        ...configure(project)(importer),\n        addition: (collection) => [\n          ...IsProgrammer.write_function_statements(project)(importer)(\n            collection,\n          ),\n          ...importer.declare(modulo),\n        ],\n      })(importer);\n    };\n\n  const write_array_functions =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      // ANY TYPE\n      if (\n        meta.any ||\n        meta.arrays.some((a) => a.type.value.any) ||\n        meta.tuples.some(\n          (t) =>\n            !!t.type.elements.length && t.type.elements.every((e) => e.any),\n        )\n      )\n        return ts.factory.createCallExpression(importer.use(\"any\"), undefined, [\n          input,\n        ]);\n\n      interface IUnion {\n        type: string;\n        is: () => ts.Expression;\n        value: () => ts.Expression;\n      }\n      const unions: IUnion[] = [];\n\n      //----\n      // LIST UP UNION TYPES\n      //----\n      // FUNCTIONAL\n      if (meta.functional)\n        unions.push({\n          type: \"functional\",\n          is: () =>\n            ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"function\"),\n              ts.factory.createTypeOfExpression(input),\n            ),\n          value: () => ts.factory.createIdentifier(\"undefined\"),\n        });\n\n      // TUPLES\n      for (const tuple of meta.tuples)\n        unions.push({\n          type: \"tuple\",\n          is: () =>\n            IsProgrammer.decode(project)(importer)(\n              input,\n              (() => {\n                const partial = Metadata.initialize();\n                partial.tuples.push(tuple);\n                return partial;\n              })(),\n              explore,\n            ),\n          value: () =>\n            decode_tuple(project)(config)(importer)(input, tuple, explore),\n        });\n\n      // ARRAYS\n      if (meta.arrays.length)\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value: () =>\n            explore_arrays(project)(config)(importer)(input, meta.arrays, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // NATIVE TYPES\n      if (meta.sets.length)\n        unions.push({\n          type: \"set\",\n          is: () => ExpressionFactory.isInstanceOf(\"Set\")(input),\n          value: () =>\n            explore_sets(project)(config)(importer)(input, meta.sets, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n      if (meta.maps.length)\n        unions.push({\n          type: \"map\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: () =>\n            explore_maps(project)(config)(importer)(input, meta.maps, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n      for (const native of meta.natives)\n        unions.push({\n          type: \"native\",\n          is: () => ExpressionFactory.isInstanceOf(native)(input),\n          value: () =>\n            native === \"Boolean\" || native === \"Number\" || native === \"String\"\n              ? ts.factory.createCallExpression(\n                  IdentifierFactory.access(input)(\"valueOf\"),\n                  undefined,\n                  undefined,\n                )\n              : decode_native(native)(input),\n        });\n\n      // OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: false,\n            })(input),\n          value: () =>\n            explore_objects(config)(importer)(input, meta, {\n              ...explore,\n              from: \"object\",\n            }),\n        });\n\n      // COMPOSITION\n      let last: ts.Expression = input;\n      for (const u of unions.reverse())\n        last = ts.factory.createConditionalExpression(\n          u.is(),\n          undefined,\n          u.value(),\n          undefined,\n          last,\n        );\n      return ts.factory.createAsExpression(last, TypeFactory.keyword(\"any\"));\n    };\n\n  const decode_object = (importer: FunctionImporter) =>\n    FeatureProgrammer.decode_object({\n      trace: false,\n      path: false,\n      prefix: PREFIX,\n    })(importer);\n\n  const decode_array =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      array.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}a${array.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n              from: \"array\",\n            })(input),\n          )\n        : decode_array_inline(config)(importer)(input, array, explore);\n\n  const decode_array_inline =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      FeatureProgrammer.decode_array(config)(importer)(CloneJoiner.array)(\n        input,\n        array,\n        explore,\n      );\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n            })(input),\n          )\n        : decode_tuple_inline(project)(config)(importer)(\n            input,\n            tuple.type,\n            explore,\n          );\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const children: ts.Expression[] = tuple.elements\n        .filter((m) => m.rest === null)\n        .map((elem, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            elem,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest = (() => {\n        if (tuple.elements.length === 0) return null;\n\n        const last: Metadata = tuple.elements.at(-1)!;\n        const rest: Metadata | null = last.rest;\n        if (rest === null) return null;\n\n        return decode(project)(config)(importer)(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"slice\"),\n            undefined,\n            [ExpressionFactory.number(tuple.elements.length - 1)],\n          ),\n          wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n          {\n            ...explore,\n            start: tuple.elements.length - 1,\n          },\n        );\n      })();\n      return CloneJoiner.tuple(children, rest);\n    };\n\n  /* -----------------------------------------------------------\n        NATIVE CLASSES\n    ----------------------------------------------------------- */\n  const decode_native = (type: string) => (input: ts.Expression) =>\n    type === \"Date\" ||\n    type === \"Uint8Array\" ||\n    type === \"Uint8ClampedArray\" ||\n    type === \"Uint16Array\" ||\n    type === \"Uint32Array\" ||\n    type === \"BigUint64Array\" ||\n    type === \"Int8Array\" ||\n    type === \"Int16Array\" ||\n    type === \"Int32Array\" ||\n    type === \"BigInt64Array\" ||\n    type === \"Float32Array\" ||\n    type === \"Float64Array\"\n      ? decode_native_copyable(type)(input)\n      : type === \"ArrayBuffer\" || type === \"SharedArrayBuffer\"\n        ? decode_native_buffer(type)(input)\n        : type === \"DataView\"\n          ? decode_native_data_view(input)\n          : ts.factory.createCallExpression(\n              ts.factory.createIdentifier(type),\n              undefined,\n              [],\n            );\n\n  const decode_native_copyable = (type: string) => (input: ts.Expression) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(type),\n      undefined,\n      [input],\n    );\n\n  const decode_native_buffer =\n    (type: \"ArrayBuffer\" | \"SharedArrayBuffer\") => (input: ts.Expression) =>\n      ExpressionFactory.selfCall(\n        ts.factory.createBlock(\n          [\n            StatementFactory.constant(\n              \"buffer\",\n              ts.factory.createNewExpression(\n                ts.factory.createIdentifier(type),\n                undefined,\n                [IdentifierFactory.access(input)(\"byteLength\")],\n              ),\n            ),\n            ts.factory.createExpressionStatement(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    undefined,\n                    [ts.factory.createIdentifier(\"buffer\")],\n                  ),\n                )(\"set\"),\n                undefined,\n                [\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    undefined,\n                    [input],\n                  ),\n                ],\n              ),\n            ),\n            ts.factory.createReturnStatement(\n              ts.factory.createIdentifier(\"buffer\"),\n            ),\n          ],\n          true,\n        ),\n      );\n\n  const decode_native_data_view = (input: ts.Expression) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"DataView\"),\n      undefined,\n      [IdentifierFactory.access(input)(\"buffer\")],\n    );\n\n  /* -----------------------------------------------------------\n        EXPLORERS FOR UNION TYPES\n    ----------------------------------------------------------- */\n  const explore_sets =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      sets: Metadata[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.set({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: (input, array, explore) =>\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Set\"),\n              [TypeFactory.keyword(\"any\")],\n              [decode_array(config)(importer)(input, array, explore)],\n            ),\n          empty: ts.factory.createNewExpression(\n            ts.factory.createIdentifier(\"Set\"),\n            [TypeFactory.keyword(\"any\")],\n            [],\n          ),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        })([])(input, sets, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_maps =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      maps: Metadata.Entry[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(\n        UnionExplorer.map({\n          checker: (top, entry, explore) => {\n            const func = IsProgrammer.decode(project)(importer);\n            return ts.factory.createLogicalAnd(\n              func(ts.factory.createElementAccessExpression(top, 0), entry[0], {\n                ...explore,\n                postfix: `${explore.postfix}[0]`,\n              }),\n              func(ts.factory.createElementAccessExpression(top, 1), entry[1], {\n                ...explore,\n                postfix: `${explore.postfix}[1]`,\n              }),\n            );\n          },\n          decoder: (input, array, explore) =>\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Map\"),\n              [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n              [decode_array(config)(importer)(input, array, explore)],\n            ),\n          empty: ts.factory.createNewExpression(\n            ts.factory.createIdentifier(\"Map\"),\n            [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n            [],\n          ),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        })([])(input, maps, explore),\n        undefined,\n        undefined,\n      );\n\n  const explore_objects =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ) => {\n      if (meta.objects.length === 1)\n        return decode_object(importer)(input, meta.objects[0]!, explore);\n\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(`${PREFIX}u${meta.union_index!}`),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: MetadataArray[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: decode_array(config)(importer),\n          empty: ts.factory.createIdentifier(\"[]\"),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: FeatureProgrammer.IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (\n      input: ts.Expression,\n      elements: T[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: FeatureProgrammer.IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.emplaceUnion(\n            config.prefix,\n            elements.map((e) => e.type.name).join(\" | \"),\n            () =>\n              arrow(\n                FeatureProgrammer.parameterDeclarations(config)(\n                  TypeFactory.keyword(\"any\"),\n                )(ts.factory.createIdentifier(\"input\")),\n              )({\n                ...explore,\n                postfix: \"\",\n              })(ts.factory.createIdentifier(\"input\")),\n          ),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  /* -----------------------------------------------------------\n        CONFIGURATIONS\n    ----------------------------------------------------------- */\n  const PREFIX = \"$c\";\n\n  const configure =\n    (project: IProject) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => {\n      const config: FeatureProgrammer.IConfig = {\n        types: {\n          input: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          output: (type, name) =>\n            ts.factory.createImportTypeNode(\n              ts.factory.createLiteralTypeNode(\n                ts.factory.createStringLiteral(\"typia\"),\n              ),\n              undefined,\n              ts.factory.createIdentifier(\"Resolved\"),\n              [\n                ts.factory.createTypeReferenceNode(\n                  name ?? TypeFactory.getFullName(project.checker)(type),\n                ),\n              ],\n              false,\n            ),\n        },\n        prefix: PREFIX,\n        trace: false,\n        path: false,\n        initializer,\n        decoder: () => decode(project)(config)(importer),\n        objector: {\n          checker: () => IsProgrammer.decode(project)(importer),\n          decoder: () => decode_object(importer),\n          joiner: CloneJoiner.object,\n          unionizer: decode_union_object(\n            IsProgrammer.decode_object(project)(importer),\n          )(decode_object(importer))((exp) => exp)((input, expected) =>\n            create_throw_error(importer)(expected)(input),\n          ),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        },\n        generator: {\n          arrays: () => write_array_functions(config)(importer),\n          tuples: () => write_tuple_functions(project)(config)(importer),\n        },\n      };\n      return config;\n    };\n\n  const initializer: FeatureProgrammer.IConfig[\"initializer\"] =\n    (project) => (importer) => (type) => {\n      const collection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate: (meta) => {\n          const output: string[] = [];\n          if (meta.natives.some((n) => n === \"WeakSet\"))\n            output.push(\"unable to clone WeakSet\");\n          else if (meta.natives.some((n) => n === \"WeakMap\"))\n            output.push(\"unable to clone WeakMap\");\n          return output;\n        },\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.misc.${importer.method}`)(\n          result.errors,\n        );\n      return [collection, result.data];\n    };\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n"]}