{"version":3,"sources":["../src/programmers/functional/FunctionalIsParametersProgrammer.ts","../src/programmers/functional/FunctionalIsFunctionProgrammer.ts","../src/programmers/functional/FunctionalIsReturnProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionalIsFunctionProgrammer } from \"./FunctionalIsFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalIsParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalIsFunctionProgrammer.getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...writeStatements(project)(modulo)(equals)(declaration),\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                expression,\n                undefined,\n                declaration.parameters.map((p) =>\n                  ts.factory.createIdentifier(p.name.getText()),\n                ),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (declaration: ts.FunctionDeclaration): ts.Statement[] =>\n      declaration.parameters\n        .map((p) => [\n          ts.factory.createIfStatement(\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createCallExpression(\n                IsProgrammer.write(project)(modulo)(equals)(\n                  project.checker.getTypeFromTypeNode(\n                    p.type ?? TypeFactory.keyword(\"any\"),\n                  ),\n                ),\n                undefined,\n                [ts.factory.createIdentifier(p.name.getText())],\n              ),\n            ),\n            ts.factory.createReturnStatement(ts.factory.createNull()),\n          ),\n        ])\n        .flat();\n}\n","import ts from \"typescript\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionalIsParametersProgrammer } from \"./FunctionalIsParametersProgrammer\";\nimport { FunctionalIsReturnProgrammer } from \"./FunctionalIsReturnProgrammer\";\n\nexport namespace FunctionalIsFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } =\n        FunctionalIsReturnProgrammer.writeStatements(project)(modulo)(equals)(\n          expression,\n          declaration,\n        );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...FunctionalIsParametersProgrammer.writeStatements(project)(\n              modulo,\n            )(equals)(declaration),\n            ...statements,\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const getReturnTypeNode = (\n    declaration: ts.FunctionDeclaration,\n    async: boolean,\n  ): ts.TypeNode | undefined =>\n    declaration.type\n      ? async\n        ? !!(declaration.type! as ts.TypeReferenceNode).typeArguments?.[0]\n          ? ts.factory.createTypeReferenceNode(\"Promise\", [\n              ts.factory.createUnionTypeNode([\n                (declaration.type! as ts.TypeReferenceNode).typeArguments![0]!,\n                ts.factory.createTypeReferenceNode(\"null\"),\n              ]),\n            ])\n          : undefined\n        : ts.factory.createUnionTypeNode([\n            declaration.type,\n            ts.factory.createTypeReferenceNode(\"null\"),\n          ])\n      : undefined;\n}\n","import ts from \"typescript\";\n\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionalIsFunctionProgrammer } from \"./FunctionalIsFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalIsReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } = writeStatements(project)(modulo)(equals)(\n        expression,\n        declaration,\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalIsFunctionProgrammer.getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(statements, true),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): {\n      async: boolean;\n      statements: ts.Statement[];\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n\n      const name: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"result\");\n      const statements: ts.Statement[] = [\n        StatementFactory.constant(\n          name,\n          async ? ts.factory.createAwaitExpression(caller) : caller,\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createConditionalExpression(\n            ts.factory.createCallExpression(\n              IsProgrammer.write(project)(modulo)(equals)(type),\n              undefined,\n              [ts.factory.createIdentifier(name)],\n            ),\n            undefined,\n            ts.factory.createIdentifier(name),\n            undefined,\n            ts.factory.createNull(),\n          ),\n        ),\n      ];\n      return { async, statements };\n    };\n}\n"],"mappings":"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","names":["ts","ts","ts","FunctionalIsReturnProgrammer","write","project","modulo","equals","expression","declaration","async","statements","writeStatements","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","FunctionalIsFunctionProgrammer","getReturnTypeNode","createBlock","type","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","name","getText","StringUtil","escapeDuplicate","StatementFactory","constant","createAwaitExpression","createReturnStatement","createConditionalExpression","IsProgrammer","createNull","FunctionalIsFunctionProgrammer","write","project","modulo","equals","expression","declaration","async","statements","FunctionalIsReturnProgrammer","writeStatements","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","getReturnTypeNode","createBlock","FunctionalIsParametersProgrammer","type","typeArguments","createTypeReferenceNode","createUnionTypeNode","FunctionalIsParametersProgrammer","write","project","modulo","equals","expression","declaration","async","FunctionalGeneralProgrammer","getReturnType","checker","ts","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","FunctionalIsFunctionProgrammer","getReturnTypeNode","createBlock","writeStatements","createReturnStatement","createCallExpression","map","p","createIdentifier","name","getText","createIfStatement","createStrictEquality","createFalse","IsProgrammer","getTypeFromTypeNode","type","TypeFactory","keyword","createNull","flat"]}