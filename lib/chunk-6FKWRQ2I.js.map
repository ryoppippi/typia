{"version":3,"sources":["../src/programmers/internal/stringify_dynamic_properties.ts"],"names":["ts","stringify_dynamic_properties","dynamic","regular","statements","factory","createIfStatement","createStrictEquality","createIdentifier","createReturnStatement","createStringLiteral","output","mapped","createCallExpression","IdentifierFactory","access","undefined","createArrowFunction","parameter","createArrayBindingPattern","createBindingElement","createTypeReferenceNode","createBlock","filtered","createStrictInequality","length","push","createArrayLiteralExpression","map","key","simple","size","atomics","type","stringify","entry","condition","metadata_to_pattern","TemplateFactory","generate","expression"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { TemplateFactory } from \"../../factories/TemplateFactory\";\n\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { metadata_to_pattern } from \"./metadata_to_pattern\";\n\n/**\n * @internal\n */\nexport const stringify_dynamic_properties = (\n  dynamic: IExpressionEntry<ts.Expression>[],\n  regular: string[],\n): ts.Expression => {\n  // BASIC STATMEMENT, CHECK UNDEFINED\n  const statements: ts.Statement[] = [\n    ts.factory.createIfStatement(\n      ts.factory.createStrictEquality(\n        ts.factory.createIdentifier(\"undefined\"),\n        ts.factory.createIdentifier(\"value\"),\n      ),\n      ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n    ),\n  ];\n\n  // PREPARE RETURN FUNCTION\n  const output = () => {\n    const mapped = ts.factory.createCallExpression(\n      IdentifierFactory.access(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"Object.entries\"),\n          undefined,\n          [ts.factory.createIdentifier(\"input\")],\n        ),\n      )(\"map\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\n              ts.factory.createArrayBindingPattern([\n                ts.factory.createBindingElement(undefined, undefined, \"key\"),\n                ts.factory.createBindingElement(undefined, undefined, \"value\"),\n              ]),\n              ts.factory.createTypeReferenceNode(\"[string, any]\"),\n            ),\n          ],\n          undefined,\n          undefined,\n          ts.factory.createBlock(statements),\n        ),\n      ],\n    );\n    const filtered = ts.factory.createCallExpression(\n      IdentifierFactory.access(mapped)(\"filter\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [IdentifierFactory.parameter(\"str\")],\n          undefined,\n          undefined,\n          ts.factory.createStrictInequality(\n            ts.factory.createStringLiteral(\"\"),\n            ts.factory.createIdentifier(\"str\"),\n          ),\n        ),\n      ],\n    );\n    return ts.factory.createCallExpression(\n      IdentifierFactory.access(filtered)(\"join\"),\n      undefined,\n      [ts.factory.createStringLiteral(\",\")],\n    );\n  };\n\n  // WHEN REGULAR PROPERTY EXISTS\n  if (regular.length)\n    statements.push(\n      ts.factory.createIfStatement(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(\n            ts.factory.createArrayLiteralExpression(\n              regular.map((key) => ts.factory.createStringLiteral(key)),\n            ),\n          )(\"some\"),\n          undefined,\n          [\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [IdentifierFactory.parameter(\"regular\")],\n              undefined,\n              undefined,\n              ts.factory.createStrictEquality(\n                ts.factory.createIdentifier(\"regular\"),\n                ts.factory.createIdentifier(\"key\"),\n              ),\n            ),\n          ],\n        ),\n        ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n      ),\n    );\n\n  // ONLY STRING TYPED KEY EXISTS\n  const simple: boolean =\n    dynamic.length === 1 &&\n    dynamic[0]!.key.size() === 1 &&\n    dynamic[0]!.key.atomics[0]?.type === \"string\";\n  if (simple === true) {\n    statements.push(stringify(dynamic[0]!));\n    return output();\n  }\n\n  // COMPOSITE TEMPLATE LITERAL TYPES\n  for (const entry of dynamic) {\n    const condition: ts.IfStatement = ts.factory.createIfStatement(\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          `RegExp(/${metadata_to_pattern(true)(entry.key)}/).test`,\n        ),\n        undefined,\n        [ts.factory.createIdentifier(\"key\")],\n      ),\n      stringify(entry),\n    );\n    statements.push(condition);\n  }\n  statements.push(\n    ts.factory.createReturnStatement(ts.factory.createStringLiteral(\"\")),\n  );\n\n  return output();\n};\n\n/**\n * @internal\n */\nconst stringify = (\n  entry: IExpressionEntry<ts.Expression>,\n): ts.ReturnStatement =>\n  ts.factory.createReturnStatement(\n    TemplateFactory.generate([\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\"JSON.stringify\"),\n        [],\n        [ts.factory.createIdentifier(\"key\")],\n      ),\n      ts.factory.createStringLiteral(\":\"),\n      entry.expression,\n    ]),\n  );\n"]}