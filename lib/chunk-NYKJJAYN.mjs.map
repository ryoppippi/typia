{"version":3,"sources":["../src/protobuf.ts"],"sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    PROTOCOL BUFFER\n      - MESSAGE\n      - DECODE\n      - ENCODE\n      - FACTORY FUNCTIONS\n==============================================================\n    SCHEMA\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Message Schema.\n *\n * Creates a Protocol Buffer Message Schema from a TypeScript type. The message\n * schema would be returned as a string value, and it can be used to share with\n * other developers/languages/frameworks.\n *\n * For reference, Protocol Buffer has lots of restrictions, so that expression power\n * of Protocol Buffer is not enough strong to fully meet the TypeScript type specs.\n * In such reason, if you put a TypeScript type that is not compatible with Protocol\n * Buffer, this function would throw compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Target type\n * @returns Protocol Buffer Message Schema.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function message(): never;\n\n/**\n * Protocol Buffer Message Schema.\n *\n * Creates a Protocol Buffer Message Schema from a TypeScript type. The message\n * schema would be returned as a string value, and it can be used to share with\n * other developers/languages/frameworks.\n *\n * For reference, Protocol Buffer has lots of restrictions, so that expression power\n * of Protocol Buffer is not enough strong to fully meet the TypeScript type specs.\n * In such reason, if you put a TypeScript type that is not compatible with Protocol\n * Buffer, this function would throw compilation errors.\n *\n * @template T Target type\n * @returns Protocol Buffer Message Schema.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function message<T>(): string;\n\n/**\n * @internal\n */\nexport function message(): never {\n  halt(\"message\");\n}\n\n/* -----------------------------------------------------------\n    DECODE\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder.\n *\n * `typia.protobuf.decode()` is a function decoding a binary data of Protocol Buffer\n * format to a TypeScript instance.\n *\n * For reference, as Protocol Buffer handles binary data directly, there's no way\n * when `input` binary data was not encoded from the `T` typed value. In that case,\n * unexpected behavior or internal error would be occured. Therefore, I recommend you\n * to encode binary data of Protocol Buffer from type safe encode functions like below.\n * Use {@link encode} function only when you can ensure it.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * Also, `typia` is providing type safe decoders like {@link assertDecode}, but it\n * is just for additional type validation like `number & Minimum<7>` or\n * `string & Format<\"uuid\">` cases, that are represented by\n * [custom tags](https://typia.io/docs/validators/tags). Thus, I repeat that,\n * you've to ensure the type safety when using decoder functions.\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction decode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder.\n *\n * `typia.protobuf.decode()` is a function decoding a binary data of Protocol Buffer\n * format to a TypeScript instance.\n *\n * For reference, as Protocol Buffer handles binary data directly, there's no way\n * when `input` binary data was not encoded from the `T` typed value. In that case,\n * unexpected behavior or internal error would be occured. Therefore, I recommend you\n * to encode binary data of Protocol Buffer from type safe encode functions like below.\n * Use {@link encode} function only when you can ensure it.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * Also, `typia` is providing type safe decoders like {@link assertDecode}, but it\n * is just for additional type validation like `number & Minimum<7>` or\n * `string & Format<\"uuid\">` cases, that are represented by\n * [custom tags](https://typia.io/docs/validators/tags). Thus, I repeat that,\n * you've to ensure the type safety when using decoder functions.\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction decode<T>(input: Uint8Array): Resolved<T>;\n\n/**\n * @internal\n */\nfunction decode(): never {\n  halt(\"decode\");\n}\nconst decodePure = /** @__PURE__ */ Object.assign<typeof decode, {}>(\n  decode,\n  /** @__PURE__ */ Namespace.protobuf.decode(\"decode\"),\n);\nexport { decodePure as decode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type assertion, but not safe.\n *\n * `typia.protobuf.assertDecode()` is a combination function of {@link decode} and\n * {@link assert} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type assertion process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it throws\n * {@link TypeGuardError} instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type assertion like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.assertDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertDecode(\n  input: Uint8Array,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Protocol Buffer Decoder wity type assertion, but not safe.\n *\n * `typia.protobuf.assertDecode()` is a combination function of {@link decode} and\n * {@link assert} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type assertion process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it throws\n * {@link TypeGuardError} instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type assertion like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.assertDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertDecode<T>(\n  input: Uint8Array,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertDecode(): never {\n  halt(\"assertDecode\");\n}\n\nconst assertDecodePure = /** @__PURE__ */ Object.assign<\n  typeof assertDecode,\n  {},\n  {}\n>(\n  assertDecode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.assertDecode\"),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"assertDecode\"),\n);\nexport { assertDecodePure as assertDecode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type checking, but not safe.\n *\n * `typia.protobuf.isDecode()` is a combination function of {@link decode} and\n * {@link is} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type checking process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it returns\n * `null` value instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type checking like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.isDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isDecode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder wity type checking, but not safe.\n *\n * `typia.protobuf.isDecode()` is a combination function of {@link decode} and\n * {@link is} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type checking process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it returns\n * `null` value instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type checking like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.isDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isDecode<T>(input: Uint8Array): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isDecode(): never {\n  halt(\"isDecode\");\n}\nconst isDecodePure = /** @__PURE__ */ Object.assign<typeof isDecode, {}, {}>(\n  isDecode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"isDecode\"),\n);\nexport { isDecodePure as isDecode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type validation, but not safe.\n *\n * `typia.protobuf.validateDecode()` is a combination function of {@link decode} and\n * {@link validate} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type validation process. If decoded value is\n * following the type `T`, it returns the decoded value with\n * {@link IValidation.ISuccess} typed instance. Otherwise, it returns\n * {@link IValidation.IFailure} value instead with detailed error reasons.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type validation like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.validateDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateDecode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder wity type validation, but not safe.\n *\n * `typia.protobuf.validateDecode()` is a combination function of {@link decode} and\n * {@link validate} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type validation process. If decoded value is\n * following the type `T`, it returns the decoded value with\n * {@link IValidation.ISuccess} typed instance. Otherwise, it returns\n * {@link IValidation.IFailure} value instead with detailed error reasons.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type validation like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.validateDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateDecode<T>(input: Uint8Array): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateDecode(): never {\n  halt(\"validateDecode\");\n}\nconst validateDecodePure = /** @__PURE__ */ Object.assign<\n  typeof validateDecode,\n  {},\n  {}\n>(\n  validateDecode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"validateDecode\"),\n);\nexport { validateDecodePure as validateDecode };\n\n/* -----------------------------------------------------------\n    ENCODE\n----------------------------------------------------------- */\n/**\n * Protocol Buffer Encoder.\n *\n * Converts an input value to a binary data of Protocol Buffer format.\n *\n * For reference, this `typia.protobuf.encode()` does not validate the `input` value.\n * It just believes that the `input` value is valid and converts it to a binary data\n * directly. Therefore, if you can't ensure the `input` value type, it would better to\n * call one of below functions intead.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction encode<T>(input: T): Uint8Array;\n\n/**\n * @internal\n */\nfunction encode(): never {\n  halt(\"encode\");\n}\nconst encodePure = /** @__PURE__ */ Object.assign<typeof encode, {}>(\n  encode,\n  /** @__PURE__ */ Namespace.protobuf.encode(\"encode\"),\n);\nexport { encodePure as encode };\n\n/**\n * Protocol Buffer Encoder with type assertion.\n *\n * `typia.protobuf.assertEncode()` is a combination function of {@link assert} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type assertion. If `input` value is not valid, it throws\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value,\n * Protocol Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEncode<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Uint8Array;\n\n/**\n * Protocol Buffer Encoder with type assertion.\n *\n * `typia.protobuf.assertEncode()` is a combination function of {@link assert} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type assertion. If `input` value is not valid, it throws\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value,\n * Protocol Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEncode<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Uint8Array;\n\n/**\n * @internal\n */\nfunction assertEncode(): never {\n  halt(\"assertEncode\");\n}\nconst assertEncodePure = /** @__PURE__ */ Object.assign<\n  typeof assertEncode,\n  {},\n  {}\n>(\n  assertEncode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.assertEncode\"),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"assertEncode\"),\n);\nexport { assertEncodePure as assertEncode };\n\n/**\n * Protocol Buffer Encoder with type checking.\n *\n * `typia.protobuf.isEncode()` is a combination function of {@link is} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type checking. If `input` value is not valid, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, Protocol\n * Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isEncode<T>(input: T): Uint8Array | null;\n\n/**\n * Protocol Buffer Encoder with type checking.\n *\n * `typia.protobuf.isEncode()` is a combination function of {@link is} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type checking. If `input` value is not valid, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, Protocol\n * Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isEncode<T>(input: unknown): Uint8Array | null;\n\n/**\n * @internal\n */\nfunction isEncode(): never {\n  halt(\"isEncode\");\n}\nconst isEncodePure = /** @__PURE__ */ Object.assign<typeof isEncode, {}, {}>(\n  isEncode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"isEncode\"),\n);\nexport { isEncodePure as isEncode };\n\n/**\n * Protocol Buffer Encoder with type validation.\n *\n * `typia.protobuf.validateEncode()` is a combination function of\n * {@link validation} and {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type validation. If `input` value is not valid, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, Protocol Buffer binary data would be stored in\n * `data` property of the output {@link IValidation.ISuccess} instance.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEncode<T>(input: T): IValidation<Uint8Array>;\n\n/**\n * Protocol Buffer Encoder with type validation.\n *\n * `typia.protobuf.validateEncode()` is a combination function of\n * {@link validation} and {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type validation. If `input` value is not valid, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, Protocol Buffer binary data would be stored in\n * `data` property of the output {@link IValidation.ISuccess} instance.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEncode<T>(input: unknown): IValidation<Uint8Array>;\n\n/**\n * @internal\n */\nfunction validateEncode(): never {\n  halt(\"validateEncode\");\n}\nconst validateEncodePure = /** @__PURE__ */ Object.assign<\n  typeof validateEncode,\n  {},\n  {}\n>(\n  validateEncode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"validateEncode\"),\n);\nexport { validateEncodePure as validateEncode };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link decode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createDecode(): never;\n\n/**\n * Creates a reusable {@link decode} function.\n *\n * @template T Target type\n * @returns A reusable `decode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createDecode<T>(): (input: Uint8Array) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createDecode<T>(): (input: Uint8Array) => Resolved<T> {\n  halt(\"createDecode\");\n}\nconst createDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createDecode,\n  {}\n>(createDecode, /** @__PURE__ */ Namespace.protobuf.decode(\"createDecode\"));\nexport { createDecodePure as createDecode };\n\n/**\n * Creates a reusable {@link isDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsDecode(): never;\n\n/**\n * Creates a reusable {@link isDecode} function.\n *\n * @template T Target type\n * @returns A reusable `isDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsDecode<T>(): (input: Uint8Array) => Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction createIsDecode<T>(): (input: Uint8Array) => Resolved<T> | null {\n  halt(\"createIsDecode\");\n}\nconst createIsDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createIsDecode,\n  {},\n  {}\n>(\n  createIsDecode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createIsDecode\"),\n);\nexport { createIsDecodePure as createIsDecode };\n\n/**\n * Creates a reusable {@link assertDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertDecode(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertDecode} function.\n *\n * @template T Target type\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertDecode<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: Uint8Array) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createAssertDecode<T>(): (input: Uint8Array) => Resolved<T> {\n  halt(\"createAssertDecode\");\n}\nconst createAssertDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertDecode,\n  {},\n  {}\n>(\n  createAssertDecode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.createAssertDecode\"),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createAssertDecode\"),\n);\nexport { createAssertDecodePure as createAssertDecode };\n\n/**\n * Creates a reusable {@link validateDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateDecode(): never;\n\n/**\n * Creates a reusable {@link validateDecode} function.\n *\n * @template T Target type\n * @returns A reusable `validateDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateDecode<T>(): (\n  input: Uint8Array,\n) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateDecode<T>(): (\n  input: Uint8Array,\n) => IValidation<Resolved<T>> {\n  halt(\"createValidateDecode\");\n}\nconst createValidateDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateDecode,\n  {},\n  {}\n>(\n  createValidateDecode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createValidateDecode\"),\n);\nexport { createValidateDecodePure as createValidateDecode };\n\n/**\n * Creates a reusable {@link encode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEncode(): never;\n\n/**\n * Creates a reusable {@link encode} function.\n *\n * @template T Target type\n * @returns A reusable `encode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEncode<T>(): (input: T) => Uint8Array;\n\n/**\n * @internal\n */\nfunction createEncode<T>(): (input: T) => Uint8Array {\n  halt(\"createEncode\");\n}\nconst createEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createEncode,\n  {}\n>(createEncode, /** @__PURE__ */ Namespace.protobuf.encode(\"createEncode\"));\nexport { createEncodePure as createEncode };\n\n/**\n * Creates a reusable {@link isEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsEncode(): never;\n\n/**\n * Creates a reusable {@link isEncode} function.\n *\n * @template T Target type\n * @returns A reusable `isEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsEncode<T>(): (input: T) => Uint8Array | null;\n\n/**\n * @internal\n */\nfunction createIsEncode<T>(): (input: T) => Uint8Array | null {\n  halt(\"createIsEncode\");\n}\nconst createIsEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createIsEncode,\n  {},\n  {}\n>(\n  createIsEncode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createIsEncode\"),\n);\nexport { createIsEncodePure as createIsEncode };\n\n/**\n * Creates a reusable {@link assertEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEncode(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertEncode} function.\n *\n * @template T Target type\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEncode<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => Uint8Array;\n\n/**\n * @internal\n */\nfunction createAssertEncode<T>(): (input: T) => Uint8Array {\n  halt(\"createAssertEncode\");\n}\nconst createAssertEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertEncode,\n  {},\n  {}\n>(\n  createAssertEncode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.createAssertEncode\"),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createAssertEncode\"),\n);\nexport { createAssertEncodePure as createAssertEncode };\n\n/**\n * Creates a reusable {@link validateEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEncode(): never;\n\n/**\n * Creates a reusable {@link validateEncode} function.\n *\n * @template T Target type\n * @returns A reusable `validateEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEncode<T>(): (input: T) => IValidation<Uint8Array>;\n\n/**\n * @internal\n */\nfunction createValidateEncode<T>(): (input: T) => IValidation<Uint8Array> {\n  halt(\"createValidateEncode\");\n}\nconst createValidateEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateEncode,\n  {},\n  {}\n>(\n  createValidateEncode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createValidateEncode\"),\n);\nexport { createValidateEncodePure as createValidateEncode };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.protobuf.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"],"mappings":"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","names":["protobuf_exports","message","halt","decode","decodePure","Object","assign","Namespace","protobuf","assertDecode","halt","assertDecodePure","Object","assign","Namespace","assert","protobuf","decode","isDecode","halt","isDecodePure","Object","assign","Namespace","is","protobuf","decode","validateDecode","halt","validateDecodePure","Object","assign","Namespace","validate","protobuf","decode","encode","halt","encodePure","Object","assign","Namespace","protobuf","assertEncode","halt","assertEncodePure","Object","assign","Namespace","assert","protobuf","encode","isEncode","halt","isEncodePure","Object","assign","Namespace","is","protobuf","encode","validateEncode","halt","validateEncodePure","Object","assign","Namespace","validate","protobuf","encode","createDecode","halt","createDecodePure","Object","assign","Namespace","protobuf","decode","createIsDecode","halt","createIsDecodePure","Object","assign","Namespace","is","protobuf","decode","createAssertDecode","halt","createAssertDecodePure","Object","assign","Namespace","assert","protobuf","decode","createValidateDecode","halt","createValidateDecodePure","Object","assign","Namespace","validate","protobuf","decode","createEncode","halt","createEncodePure","Object","assign","Namespace","protobuf","encode","createIsEncode","halt","createIsEncodePure","Object","assign","Namespace","is","protobuf","encode","createAssertEncode","halt","createAssertEncodePure","Object","assign","Namespace","assert","protobuf","encode","createValidateEncode","halt","createValidateEncodePure","Object","assign","Namespace","validate","protobuf","encode","halt","name","Error"]}