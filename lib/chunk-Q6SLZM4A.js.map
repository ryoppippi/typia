{"version":3,"sources":["../src/transformers/features/json/JsonApplicationTransformer.ts"],"names":["ts","JsonApplicationTransformer","transform","project","expression","typeArguments","length","TransformerError","code","message","top","isTupleTypeNode","elements","some","child","isTypeNode","types","map","checker","getTypeFromTypeNode","t","isTypeParameter","version","get_parameter","name","is","str","cast","default","collection","MetadataCollection","replace","results","type","MetadataFactory","analyze","context","escape","constant","absorb","validate","JsonApplicationProgrammer","metadatas","errors","r","success","push","data","from","app","write","LiteralFactory","generate","props","node","isLiteral","getFlags","TypeFlags","BooleanLiteral","value","typeToString"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAgBEC,6BAAAA;8BACFC,YACX,CAACC,YACD,CAACC,eAAAA;AACC,QAAI,CAACA,WAAWC,eAAeC,OAC7B,OAAM,IAAIC,iBAAiB;MACzBC,MAAM;MACNC,SAAS;IACX,CAAA;AAMF,UAAMC,MAAeN,WAAWC,cAAc,CAAA;AAC9C,QAAI,CAACL,GAAGW,gBAAgBD,GAAAA,EAAM,QAAON;aAC5BM,IAAIE,SAASC,KAAK,CAACC,UAAU,CAACd,GAAGe,WAAWD,KAAAA,CAAAA,EACnD,QAAOV;AAGT,UAAMY,QAAmBN,IAAIE,SAASK,IAAI,CAACH,UACzCX,QAAQe,QAAQC,oBAAoBL,KAAAA,CAAAA;AAEtC,QAAIE,MAAMH,KAAK,CAACO,MAAMA,EAAEC,gBAAe,CAAA,EACrC,OAAM,IAAId,iBAAiB;MACzBC,MAAM;MACNC,SAAS;IACX,CAAA;AAGF,UAAMa,UAAyBC,cAA6B;MAC1DL,SAASf,QAAQe;MACjBM,MAAM;MACNC,IAAI,wBAACC,QAAQA,QAAQ,SAASA,QAAQ,OAAlC;MACJC,MAAM,wBAACD,QAAQA,KAAT;MACNE,SAAS,6BAAM,OAAN;IACX,CAAA,EAAGxB,WAAWC,cAAc,CAAA,CAAE;AAM9B,UAAMwB,aAAiC,IAAIC,mBAAmB;MAC5DC,SAASD,mBAAmBC;IAC9B,CAAA;AACA,UAAMC,UACJhB,MAAMC,IAAI,CAACgB,SACTC,gBAAgBC,QACdhC,QAAQe,SACRf,QAAQiC,OAAO,EACf;MACAC,QAAQ;MACRC,UAAU;MACVC,QAAQ;MACRC,UAAUC,0BAA0BD;IACtC,CAAA,EAAGX,UAAAA,EAAYI,IAAAA,CAAAA;AAInB,UAAMS,YAAwB,CAAA;AAC9B,UAAMC,SAAmC,CAAA;AACzC,eAAWC,KAAKZ,SAAS;AACvB,UAAIY,EAAEC,YAAY,MAAOF,QAAOG,KAAI,GAAIF,EAAED,MAAM;UAC3CD,WAAUI,KAAKF,EAAEG,IAAI;IAC5B;AACA,QAAIJ,OAAOrC,OACT,OAAMC,iBAAiByC,KAAK,wBAAA,EAA0BL,MAAAA;AAGxD,UAAMM,MACJR,0BAA0BS,MAAM5B,OAAAA,EAASoB,SAAAA;AAC3C,WAAOS,eAAeC,SAASH,GAAAA;EACjC;AAEF,QAAM1B,gBACJ,wBAAQ8B,UAOR,CAACC,SAAAA;AACC,QAAI,CAACA,KAAM,QAAOD,MAAMzB,QAAO;AAG/B,UAAMK,OAAgBoB,MAAMnC,QAAQC,oBAAoBmC,IAAAA;AACxD,QACE,CAACrB,KAAKsB,UAAS,MACdtB,KAAKuB,SAAQ,IAAKxD,GAAGyD,UAAUC,oBAAoB,EAEpD,OAAM,IAAInD,iBAAiB;MACzBC,MAAM;MACNC,SAAS,qBAAqB4C,MAAM7B,IAAI;IAC1C,CAAA;AAGF,UAAMmC,QAAQ1B,KAAKsB,UAAS,IACxBtB,KAAK0B,QACLN,MAAMnC,QAAQ0C,aAAa3B,IAAAA;AAC/B,QAAI,OAAO0B,UAAU,YAAYN,MAAM5B,GAAGkC,KAAAA,MAAW,MACnD,OAAM,IAAIpD,iBAAiB;MACzBC,MAAM;MACNC,SAAS,sCAAsC4C,MAAM7B,IAAI;IAC3D,CAAA;AACF,WAAO6B,MAAM1B,KAAKgC,KAAAA;EACpB,GA/BA;AAgCJ,GA3GiB1D,+BAAAA,6BAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { LiteralFactory } from \"../../../factories/LiteralFactory\";\nimport { MetadataCollection } from \"../../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../../factories/MetadataFactory\";\n\nimport { IJsonApplication } from \"../../../schemas/json/IJsonApplication\";\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { JsonApplicationProgrammer } from \"../../../programmers/json/JsonApplicationProgrammer\";\n\nimport { ValidationPipe } from \"../../../typings/ValidationPipe\";\n\nimport { IProject } from \"../../IProject\";\nimport { TransformerError } from \"../../TransformerError\";\n\nexport namespace JsonApplicationTransformer {\n  export const transform =\n    (project: IProject) =>\n    (expression: ts.CallExpression): ts.Expression => {\n      if (!expression.typeArguments?.length)\n        throw new TransformerError({\n          code: \"typia.json.application\",\n          message: \"no generic argument.\",\n        });\n\n      //----\n      // GET ARGUMENTS\n      //----\n      // VALIDATE TUPLE ARGUMENTS\n      const top: ts.Node = expression.typeArguments[0]!;\n      if (!ts.isTupleTypeNode(top)) return expression;\n      else if (top.elements.some((child) => !ts.isTypeNode(child)))\n        return expression;\n\n      // GET TYPES\n      const types: ts.Type[] = top.elements.map((child) =>\n        project.checker.getTypeFromTypeNode(child as ts.TypeNode),\n      );\n      if (types.some((t) => t.isTypeParameter()))\n        throw new TransformerError({\n          code: \"typia.json.application\",\n          message: \"non-specified generic argument(s).\",\n        });\n\n      // ADDITIONAL PARAMETERS\n      const version: \"3.0\" | \"3.1\" = get_parameter<\"3.0\" | \"3.1\">({\n        checker: project.checker,\n        name: \"Version\",\n        is: (str) => str === \"3.0\" || str === \"3.1\",\n        cast: (str) => str as \"3.0\" | \"3.1\",\n        default: () => \"3.1\",\n      })(expression.typeArguments[1]);\n\n      //----\n      // GENERATORS\n      //----\n      // METADATA\n      const collection: MetadataCollection = new MetadataCollection({\n        replace: MetadataCollection.replace,\n      });\n      const results: ValidationPipe<Metadata, MetadataFactory.IError>[] =\n        types.map((type) =>\n          MetadataFactory.analyze(\n            project.checker,\n            project.context,\n          )({\n            escape: true,\n            constant: true,\n            absorb: false,\n            validate: JsonApplicationProgrammer.validate,\n          })(collection)(type),\n        );\n\n      // REPORT BUG IF REQUIRED\n      const metadatas: Metadata[] = [];\n      const errors: MetadataFactory.IError[] = [];\n      for (const r of results) {\n        if (r.success === false) errors.push(...r.errors);\n        else metadatas.push(r.data);\n      }\n      if (errors.length)\n        throw TransformerError.from(\"typia.json.application\")(errors);\n\n      // APPLICATION\n      const app: IJsonApplication<any> =\n        JsonApplicationProgrammer.write(version)(metadatas);\n      return LiteralFactory.generate(app);\n    };\n\n  const get_parameter =\n    <Value>(props: {\n      checker: ts.TypeChecker;\n      name: string;\n      is: (value: string) => boolean;\n      cast: (value: string) => Value;\n      default: () => Value;\n    }) =>\n    (node: ts.TypeNode | undefined): Value => {\n      if (!node) return props.default();\n\n      // CHECK LITERAL TYPE\n      const type: ts.Type = props.checker.getTypeFromTypeNode(node);\n      if (\n        !type.isLiteral() &&\n        (type.getFlags() & ts.TypeFlags.BooleanLiteral) === 0\n      )\n        throw new TransformerError({\n          code: \"typia.json.application\",\n          message: `generic argument \"${props.name}\" must be constant.`,\n        });\n\n      // GET VALUE AND VALIDATE IT\n      const value = type.isLiteral()\n        ? type.value\n        : props.checker.typeToString(type);\n      if (typeof value !== \"string\" || props.is(value) === false)\n        throw new TransformerError({\n          code: \"typia.json.application\",\n          message: `invalid value on generic argument \"${props.name}\".`,\n        });\n      return props.cast(value);\n    };\n}\n"]}