{"version":3,"sources":["../src/programmers/helpers/RandomRanger.ts"],"names":["ts","RandomRanger","length","coalesce","defs","acc","tags","props","minimum","getter","maximum","undefined","gap","factory","createCallExpression","ExpressionFactory","number","config","range","value","exclusive","stepper","multiply","multiplier","createMultiply","transform","setter","integer","Math","floor","type","ceil","kind","find","t","Number","m","x","y"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\n\nimport { IMetadataTypeTag } from \"../../schemas/metadata/IMetadataTypeTag\";\n\nexport namespace RandomRanger {\n  export interface IDefaults {\n    minimum: number;\n    maximum: number;\n    gap: number;\n  }\n\n  export const length =\n    (coalesce: (method: string) => ts.Expression) =>\n    (defs: IDefaults) =>\n    (acc: length.IAccessors) =>\n    (tags: IMetadataTypeTag[]): ts.Expression | undefined => {\n      const props = {\n        minimum: getter(tags)(acc.minimum),\n        maximum: getter(tags)(acc.maximum),\n      };\n      if (props.minimum === undefined && props.maximum === undefined)\n        return undefined;\n\n      if (props.maximum !== undefined && props.minimum === undefined) {\n        if (props.maximum <= 0) {\n          props.maximum = 0;\n          props.minimum = 0;\n        } else if (props.maximum < defs.gap)\n          props.minimum = defs.minimum === 0 ? 0 : 1;\n      }\n      props.minimum ??= defs.minimum;\n      props.maximum ??= defs.maximum;\n      if (props.maximum < props.minimum) (props.maximum as number) += defs.gap;\n\n      return ts.factory.createCallExpression(coalesce(\"integer\"), undefined, [\n        ExpressionFactory.number(props.minimum),\n        ExpressionFactory.number(props.maximum),\n      ]);\n    };\n  export namespace length {\n    export interface IAccessors {\n      minimum: string;\n      maximum: string;\n    }\n  }\n\n  export const number =\n    (config: number.IConfig) =>\n    (defs: IDefaults) =>\n    (tags: IMetadataTypeTag[]): ts.Expression => {\n      const range = {\n        minimum: {\n          value: getter(tags)(\"minimum\") ?? getter(tags)(\"exclusiveMinimum\"),\n          exclusive: getter(tags)(\"exclusiveMinimum\") !== undefined,\n        },\n        maximum: {\n          value: getter(tags)(\"maximum\") ?? getter(tags)(\"exclusiveMaximum\"),\n          exclusive: getter(tags)(\"exclusiveMaximum\") !== undefined,\n        },\n        stepper: undefined,\n        multiply: getter(tags)(\"multipleOf\"),\n      };\n\n      //----\n      // MULTIPLIERS\n      //----\n      if (range.multiply !== undefined) {\n        const { minimum, maximum } = multiplier(defs.gap)(range)(\n          range.multiply,\n        );\n        return ts.factory.createMultiply(\n          config.transform(range.multiply),\n          config.setter([minimum, maximum]),\n        );\n      }\n\n      //----\n      // RANGE\n      //----\n      // INT\n      const integer = (value: number) => value === Math.floor(value);\n      if (config.type === \"int\") {\n        if (range.minimum.value !== undefined) {\n          if (range.minimum.exclusive) {\n            range.minimum.exclusive = false;\n            if (integer(range.minimum.value)) range.minimum.value += 1;\n          }\n          range.minimum.value = Math.ceil(range.minimum.value);\n        }\n        if (range.maximum.value !== undefined) {\n          if (range.maximum.exclusive) {\n            range.maximum.exclusive = false;\n            if (integer(range.maximum.value)) range.maximum.value -= 1;\n          }\n          range.maximum.value = Math.floor(range.maximum.value);\n        }\n      }\n\n      // UNSIGNED INT\n      if (config.type === \"uint\") {\n        if (range.minimum.value === undefined) range.minimum.value = 0;\n        else if (range.minimum.value <= 0) {\n          range.minimum.value = 0;\n          range.minimum.exclusive = false;\n        }\n      }\n\n      const minimum =\n        range.minimum.value ??\n        (range.maximum.value !== undefined\n          ? range.maximum.value - defs.gap\n          : defs.minimum);\n      const maximum =\n        range.maximum.value ??\n        (range.minimum.value !== undefined\n          ? range.minimum.value + defs.gap\n          : defs.maximum);\n      return config.setter([minimum, maximum]);\n    };\n  export namespace number {\n    export interface IConfig {\n      setter: (args: number[]) => ts.Expression;\n      transform: (value: number) => ts.Expression;\n      type: \"int\" | \"uint\" | \"double\";\n    }\n  }\n}\n\nconst getter =\n  (tags: IMetadataTypeTag[]) =>\n  (kind: string): number | undefined => {\n    const value: bigint | number | undefined = tags.find(\n      (t) =>\n        t.kind === kind &&\n        (typeof t.value === \"number\" || typeof t.value === \"bigint\"),\n    )?.value;\n    return value !== undefined ? Number(value) : undefined;\n  };\n\nconst multiplier = (gap: number) => (range: IRange) => (m: number) => {\n  const minimum: number =\n    range.minimum.value === undefined\n      ? 0\n      : (() => {\n          const x: number = m * Math.ceil(range.minimum.value / m);\n          return range.minimum.exclusive && x === range.minimum.value\n            ? x + m\n            : x;\n        })() / m;\n  const maximum: number =\n    range.maximum.value === undefined\n      ? gap\n      : (() => {\n          const y: number = m * Math.floor(range.maximum.value / m);\n          return range.maximum.exclusive && y === range.maximum.value\n            ? y - m\n            : y;\n        })() / m;\n  return { minimum, maximum };\n};\n\ninterface IRange {\n  minimum: IScalar;\n  maximum: IScalar;\n}\ninterface IScalar {\n  value?: undefined | number;\n  exclusive: boolean;\n}\n"]}