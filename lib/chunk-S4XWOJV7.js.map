{"version":3,"sources":["../src/factories/MetadataCommentTagFactory.ts"],"names":["MetadataCommentTagFactory","analyze","errors","metadata","commentList","explore","messages","report","msg","push","validateReport","property","comment","tagger","parse","key","value","Object","entries","filtered","filter","v","validate","arrays","length","a","Writable","tags","x","MetadataTypeTagFactory","atomic","atomics","find","type","undefined","opposite","some","kind","name","parser","PARSER","text","items","Value","array","target","parse_integer","exclusive","schema","minItems","maxItems","uniqueItems","startsWith","endsWith","substring","includes","number","JSON","stringify","bigint","minimum","parse_number","BigInt","maximum","exclusiveMinimum","exclusiveMaximum","multipleOf","format","matched","FORMATS","get","string","pattern","minLength","maxLength","str","Number","isNaN","unsigned","Math","floor","Map","FormatCheatSheet","map"],"mappings":";;;;;;;;;;;;;;;UAgBiBA,4BAAAA;6BACFC,UACX,CAACC,WACD,CAACC,aACD,CACEC,aACAC,YAAAA;AAGA,UAAMC,WAAqB,CAAA;AAC3B,UAAMC,SAAS,wBAACC,QAAAA;AACdF,eAASG,KAAKD,GAAAA;AACd,aAAO;IACT,GAHe;AAIf,UAAME,iBACJ,wBAACC,aACD,CAACH,QAAAA;AACCF,eAASG,KACP,gBACEE,aAAa,OAAO,kBAAkB,eAAeA,QAAAA,IAAY,IAC/DH,GAAAA,GAAM;AAEZ,aAAO;IACT,GARA;AAWF,eAAWI,WAAWR,aAAa;AACjC,YAAMS,SAA2BC,MAAMP,MAAAA,EAAQK,OAAAA;AAC/C,UAAIC,WAAW,KAAM;AACrB,iBAAW,CAACE,KAAKC,KAAAA,KAAUC,OAAOC,QAAQL,MAAAA,GAAS;AACjD,cAAMM,WAA+BH,MAAMI,OACzC,CAACC,MAAMA,EAAEC,aAAa,IAAA;AAExB,YAAIP,QAAQ,SAAS;AACnB,cAAIZ,SAASoB,OAAOC,WAAW,GAAG;AAChCjB,mBAAO,qBAAqB;AAC5B;UACF;AACA,qBAAWkB,KAAKtB,SAASoB,QAAQ;AAC/BG,qBAASD,CAAAA,EAAGE,OAAOF,EAAEE,KAAKP,OAAO,CAACQ,MAChCC,uBAAuBP,SAASZ,cAAAA,EAAgB,OAAA,EAAS;iBACpDkB;iBACAT;aACJ,CAAA;AAEH,gBAAIM,EAAEE,KAAKH,WAAW,EAAGC,GAAEE,KAAKlB,KAAKU,QAAAA;gBAChC,YAAWQ,QAAQF,EAAEE,KAAMA,MAAKlB,KAAI,GAAIU,QAAAA;UAC/C;QACF,OAAO;AACL,gBAAMW,SAAS3B,SAAS4B,QAAQC,KAAK,CAACP,MAAMA,EAAEQ,QAAQlB,GAAAA;AACtD,cAAIe,WAAWI,OACb,KAAInB,QAAQ,YAAYA,QAAQ,UAAU;AACxC,kBAAMoB,WAAWpB,QAAQ,WAAW,WAAW;AAC/C,gBACEF,OAAOsB,QAAAA,MAAcD,UACrB/B,SAAS4B,QAAQK,KAAK,CAACX,MAAMA,EAAEQ,SAASE,QAAAA,EAExC;UACJ,WACEpB,QAAQ,YACRC,MAAM,CAAA,GAAIqB,SAAS,YACnBrB,MAAM,CAAA,GAAIA,UAAU,YAEpB;cACGT,QAAO,YAAYQ,GAAAA,OAAU;eAC/B;AACHW,qBAASI,MAAAA,EAAQH,OAAOG,OAAOH,KAAKP,OAAO,CAACQ,MAC1CC,uBAAuBP,SAASZ,cAAAA,EAC9BK,GAAAA,EACA;iBAAIa;iBAAMT;aAAS,CAAA;AAEvB,gBAAIW,OAAOH,KAAKH,WAAW,EAAGM,QAAOH,KAAKlB,KAAKU,QAAAA;gBAC1C,YAAWQ,QAAQG,OAAOH,KAAMA,MAAKlB,KAAI,GAAIU,QAAAA;UACpD;QACF;MACF;IACF;AAGA,QAAIb,SAASkB,WAAW,EACtBtB,QAAOO,KAAK;MACV6B,MAAM;MACNjC;MACAC;IACF,CAAA;EACJ;AAEF,QAAMQ,QACJ,wBAACP,WACD,CAACK,YAAAA;AACC,UAAM2B,SAASC,OAAO5B,QAAQ0B,IAAI;AAClC,QAAIC,WAAWL,OAAW,QAAO,CAAC;AAElC,UAAMO,QAAQ7B,QAAQ6B,QAAQ,CAAA,GAAI,CAAA,GAAIA;AACtC,QAAIA,SAASP,UAAatB,QAAQ0B,SAAS,cACzC,QAAO/B,OAAO,sBAAsB;AACtC,WAAOgC,OAAOhC,MAAAA,EAAQkC,IAAAA;EACxB,GATA;AAUJ,GAlGiBzC,8BAAAA,4BAAAA,CAAAA,EAAAA;AA6GjB,IAAMwC,SAKF;;;;EAIFE,OAAO,wBAACnC,WAAW,CAACoC,WAAW;IAC7BC,OAAO;MACL;QACEN,MAAM,YAAYK,KAAAA;QAClBE,QAAQ;QACRR,MAAM;QACNrB,OAAO8B,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACnCrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;QACXC,QAAQ;UACNC,UAAUH,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACxC;MACF;MACA;QACEL,MAAM,YAAYK,KAAAA;QAClBE,QAAQ;QACRR,MAAM;QACNrB,OAAO8B,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACnCrB,UAAU,oBAAoBqB,KAAAA;QAC9BI,WAAW;QACXC,QAAQ;UACNE,UAAUJ,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACxC;MACF;;EAEJ,IAzBO;EA0BPM,UAAU,wBAAC1C,WAAW,CAACoC,WAAW;IAChCC,OAAO;MACL;QACEN,MAAM,YAAYK,KAAAA;QAClBE,QAAQ;QACRR,MAAM;QACNrB,OAAO8B,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACnCrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;QACXC,QAAQ;UACNC,UAAUH,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACxC;MACF;;EAEJ,IAdU;EAeVO,UAAU,wBAAC3C,WAAW,CAACoC,WAAW;IAChCC,OAAO;MACL;QACEN,MAAM,YAAYK,KAAAA;QAClBE,QAAQ;QACRR,MAAM;QACNrB,OAAO8B,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACnCrB,UAAU,oBAAoBqB,KAAAA;QAC9BI,WAAW;QACXC,QAAQ;UACNE,UAAUJ,cAAcvC,MAAAA,EAAQ,IAAA,EAAMoC,KAAAA;QACxC;MACF;;EAEJ,IAdU;EAeVQ,aAAa,6BAAM,OAAO;IACxBP,OAAO;MACL;QACEN,MAAM;QACNO,QAAQ;QACRR,MAAM;QACNrB,OAAO;QACPM,UAAU;QACVyB,WAAW;QACXC,QAAQ;UACNG,aAAa;QACf;MACF;;EAEJ,IAda;;;;EAmBblB,MAAM,6BAAM,CAACU,UAAAA;AAEX,QAAIA,MAAMS,WAAW,GAAA,KAAQT,MAAMU,SAAS,GAAA,EAC1CV,SAAQA,MAAMW,UAAU,GAAGX,MAAMnB,SAAS,CAAA;AAC5C,QAAImB,UAAU,MAAOA,SAAQ;aACpBA,UAAU,OAAQA,SAAQ;AAGnC,QACE;MAAC;MAAS;MAAU;MAAS;MAAU;MAAS;MAAUY,SACxDZ,KAAAA,MACI,MAEN,QAAO,CAAC;AACV,WAAO;MACLa,QAAQ;QACN;UACElB,MAAM,QAAQmB,KAAKC,UAAUf,KAAAA,CAAAA;UAC7BE,QAAQ;UACRR,MAAM;UACNrB,OAAO2B;UACPrB,UACEqB,UAAU,UACN,mFACAA,UAAU,WACR,yEACAA,UAAU,UACR,qGACAA,UAAU,WACR,mFACAA,UAAU,UACR,wDACA;UACdI,WAAW;UACXC,QAAQ;YAAC;YAAS;YAAU;YAAS;YAAUO,SAASZ,KAAAA,IACpD;YAAEV,MAAM;UAAU,IAClBC;QACN;;MAEFyB,QACEhB,UAAU,WAAW,WACjB;QACE;UACEL,MAAM,QAAQmB,KAAKC,UAAUf,KAAAA,CAAAA;UAC7BE,QAAQ;UACRR,MAAM;UACNrB,OAAO2B;UACPrB,UAAUqB,UAAU,UAAU,SAAS;UACvCI,WAAW;UACXC,QAAQd;QACV;UAEF,CAAA;IACR;EACF,GAtDM;EAuDN0B,SAAS,wBAACrD,WAAW,CAACoC,WAAW;IAC/Ba,QAAQ;MACN;QACElB,MAAM,WAAWK,KAAAA;QACjBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;UAAC;UAAW;;QACvBC,QAAQ;UACNY,SAASC,aAAatD,MAAAA,EAAQoC,KAAAA;QAChC;MACF;;IAEFgB,QAAQ;MACN;QACErB,MAAM,WAAWK,KAAAA;QACjBE,QAAQ;QACRR,MAAM;QACNrB,QAAQ,MAAA;AACN,gBAAMA,QAAQ8B,cAAcvC,MAAAA,EAAQ,KAAA,EAAOoC,KAAAA;AAC3C,iBAAO3B,UAAU,OAAO,OAAO8C,OAAO9C,KAAAA;QACxC,GAAA;QACAM,UAAU,GAAGqB,KAAAA;QACbI,WAAW;UAAC;UAAW;;QACvBC,QAAQd;MACV;;EAEJ,IA5BS;EA6BT6B,SAAS,wBAACxD,WAAW,CAACoC,WAAW;IAC/Ba,QAAQ;MACN;QACElB,MAAM,WAAWK,KAAAA;QACjBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,aAAaqB,KAAAA;QACvBI,WAAW;UAAC;UAAW;;QACvBC,QAAQ;UACNe,SAASF,aAAatD,MAAAA,EAAQoC,KAAAA;QAChC;MACF;;IAEFgB,QAAQ;MACN;QACErB,MAAM,WAAWK,KAAAA;QACjBE,QAAQ;QACRR,MAAM;QACNrB,QAAQ,MAAA;AACN,gBAAMA,QAAQ8B,cAAcvC,MAAAA,EAAQ,KAAA,EAAOoC,KAAAA;AAC3C,iBAAO3B,UAAU,OAAO,OAAO8C,OAAO9C,KAAAA;QACxC,GAAA;QACAM,UAAU,aAAaqB,KAAAA;QACvBI,WAAW;UAAC;UAAW;;QACvBC,QAAQd;MACV;;EAEJ,IA5BS;EA6BT8B,kBAAkB,wBAACzD,WAAW,CAACoC,WAAW;IACxCa,QAAQ;MACN;QACElB,MAAM,oBAAoBK,KAAAA;QAC1BE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;UAAC;UAAW;;QACvBC,QAAQ;UACNgB,kBAAkB;UAClBJ,SAASC,aAAatD,MAAAA,EAAQoC,KAAAA;QAChC;MACF;;IAEFgB,QAAQ;MACN;QACErB,MAAM,oBAAoBK,KAAAA;QAC1BE,QAAQ;QACRR,MAAM;QACNrB,QAAQ,MAAA;AACN,gBAAMA,QAAQ8B,cAAcvC,MAAAA,EAAQ,KAAA,EAAOoC,KAAAA;AAC3C,iBAAO3B,UAAU,OAAO,OAAO8C,OAAO9C,KAAAA;QACxC,GAAA;QACAM,UAAU,GAAGqB,KAAAA;QACbI,WAAW;UAAC;UAAW;;QACvBC,QAAQd;MACV;;EAEJ,IA7BkB;EA8BlB+B,kBAAkB,wBAAC1D,WAAW,CAACoC,WAAW;IACxCa,QAAQ;MACN;QACElB,MAAM,oBAAoBK,KAAAA;QAC1BE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,YAAYqB,KAAAA;QACtBI,WAAW;UAAC;UAAW;;QACvBC,QAAQ;UACNiB,kBAAkB;UAClBF,SAASF,aAAatD,MAAAA,EAAQoC,KAAAA;QAChC;MACF;;IAEFgB,QAAQ;MACN;QACErB,MAAM,oBAAoBK,KAAAA;QAC1BE,QAAQ;QACRR,MAAM;QACNrB,QAAQ,MAAA;AACN,gBAAMA,QAAQ8B,cAAcvC,MAAAA,EAAQ,KAAA,EAAOoC,KAAAA;AAC3C,iBAAO3B,UAAU,OAAO,OAAO8C,OAAO9C,KAAAA;QACxC,GAAA;QACAM,UAAU,YAAYqB,KAAAA;QACtBI,WAAW;UAAC;UAAW;;QACvBC,QAAQd;MACV;;EAEJ,IA7BkB;EA8BlBgC,YAAY,wBAAC3D,WAAW,CAACoC,WAAW;IAClCa,QAAQ;MACN;QACElB,MAAM,cAAcK,KAAAA;QACpBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,YAAYqB,KAAAA;QACtBI,WAAW;QACXC,QAAQ;UACNkB,YAAYL,aAAatD,MAAAA,EAAQoC,KAAAA;QACnC;MACF;;IAEFgB,QAAQ;MACN;QACErB,MAAM,cAAcK,KAAAA;QACpBE,QAAQ;QACRR,MAAM;QACNrB,QAAQ,MAAA;AACN,gBAAMA,QAAQ8B,cAAcvC,MAAAA,EAAQ,KAAA,EAAOoC,KAAAA;AAC3C,iBAAO3B,UAAU,OAAO,OAAO8C,OAAO9C,KAAAA;QACxC,GAAA;QACAM,UAAU,YAAYqB,KAAAA;QACtBI,WAAW;QACXC,QAAQd;MACV;;EAEJ,IA5BY;;;;EAiCZiC,QAAQ,6BAAM,CAACxB,UAAAA;AACb,UAAMyB,UAAUC,QAAQC,IAAI3B,KAAAA;AAC5B,QAAIyB,YAAYlC,OAAW,QAAO,CAAC;AACnC,WAAO;MACLqC,QAAQ;QACN;UACEjC,MAAM,UAAUmB,KAAKC,UAAUU,QAAQ,CAAA,CAAE,CAAA;UACzCvB,QAAQ;UACRR,MAAM;UACNrB,OAAOoD,QAAQ,CAAA;UACf9C,UAAU8C,QAAQ,CAAA;UAClBrB,WAAW;UACXC,QAAQ;YACNmB,QAAQC,QAAQ,CAAA;UAClB;QACF;;IAEJ;EACF,GAlBQ;EAmBRI,SAAS,6BAAM,CAAC7B,WAAW;IACzB4B,QAAQ;MACN;QACEjC,MAAM,WAAWmB,KAAKC,UAAUf,KAAAA,CAAAA;QAChCE,QAAQ;QACRR,MAAM;QACNrB,OAAO2B;QACPrB,UAAU,WAAWqB,KAAAA;QACrBI,WAAW;UAAC;;QACZC,QAAQ;UACNwB,SAAS7B;QACX;MACF;;EAEJ,IAdS;EAeTnB,QAAQ,wBAACjB,WAAW,CAACoC,WAAW;IAC9B4B,QAAQ;MACN;QACEjC,MAAM,aAAaK,KAAAA;QACnBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;QACXC,QAAQ;UACNyB,WAAWZ,aAAatD,MAAAA,EAAQoC,KAAAA;QAClC;MACF;MACA;QACEL,MAAM,aAAaK,KAAAA;QACnBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,oBAAoBqB,KAAAA;QAC9BI,WAAW;QACXC,QAAQ;UACN0B,WAAWb,aAAatD,MAAAA,EAAQoC,KAAAA;QAClC;MACF;;EAEJ,IAzBQ;EA0BR8B,WAAW,wBAAClE,WAAW,CAACoC,WAAW;IACjC4B,QAAQ;MACN;QACEjC,MAAM,aAAaK,KAAAA;QACnBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,GAAGqB,KAAAA;QACbI,WAAW;QACXC,QAAQ;UACNyB,WAAWZ,aAAatD,MAAAA,EAAQoC,KAAAA;QAClC;MACF;;EAEJ,IAdW;EAeX+B,WAAW,wBAACnE,WAAW,CAACoC,WAAW;IACjC4B,QAAQ;MACN;QACEjC,MAAM,aAAaK,KAAAA;QACnBE,QAAQ;QACRR,MAAM;QACNrB,OAAO6C,aAAatD,MAAAA,EAAQoC,KAAAA;QAC5BrB,UAAU,oBAAoBqB,KAAAA;QAC9BI,WAAW;QACXC,QAAQ;UACN0B,WAAWb,aAAatD,MAAAA,EAAQoC,KAAAA;QAClC;MACF;;EAEJ,IAdW;AAeb;AAEA,IAAMkB,eACJ,wBAACtD,WACD,CAACoE,QAAAA;AACC,QAAM3D,QAAgB4D,OAAOD,GAAAA;AAC7B,MAAIE,MAAM7D,KAAAA,MAAW,KAAM,QAAOT,OAAO,gBAAgB;AACzD,SAAOS;AACT,GALA;AAOF,IAAM8B,gBACJ,wBAACvC,WACD,CAACuE,aACD,CAACH,QAAAA;AACC,QAAM3D,QAAuB6C,aAAatD,MAAAA,EAAQoE,GAAAA;AAClD,MAAI3D,UAAU,KAAM,QAAO;WAClB+D,KAAKC,MAAMhE,KAAAA,MAAWA,MAAO,QAAOT,OAAO,iBAAiB;WAC5DuE,aAAa,QAAQ9D,QAAQ,EACpC,QAAOT,OAAO,0BAA0B;AAC1C,SAAOS;AACT,GATA;AAWF,IAAMqD,UAAyC,IAAIY,IAAI;KAClDhE,OAAOC,QAAQgE,gBAAAA,EAAkBC,IAClC,CAAC,CAACpE,KAAKC,KAAAA,MAAW;IAACD;IAAK;MAACA;MAAKC;;GAAO;EAEvC;IAAC;IAAY;MAAC;MAAa;;;EAC3B;IAAC;IAAY;MAAC;MAAa;;;CAC5B","sourcesContent":["import ts from \"typescript\";\n\nimport { IMetadataTypeTag } from \"../schemas/metadata/IMetadataTypeTag\";\nimport { Metadata } from \"../schemas/metadata/Metadata\";\n\nimport { Writable } from \"../typings/Writable\";\n\nimport { FormatCheatSheet } from \"../tags/internal/FormatCheatSheet\";\nimport { MetadataFactory } from \"./MetadataFactory\";\nimport { MetadataTypeTagFactory } from \"./MetadataTypeTagFactory\";\n\n/**\n * Extremely hard coded, but no reason to maintain.\n *\n * @internal\n */\nexport namespace MetadataCommentTagFactory {\n  export const analyze =\n    (errors: MetadataFactory.IError[]) =>\n    (metadata: Metadata) =>\n    (\n      commentList: ts.JSDocTagInfo[],\n      explore: MetadataFactory.IExplore,\n    ): void => {\n      // PREPARE MESSAGE CONTAINER\n      const messages: string[] = [];\n      const report = (msg: string) => {\n        messages.push(msg);\n        return null;\n      };\n      const validateReport =\n        (property: string | null) =>\n        (msg: string): false => {\n          messages.push(\n            `the property ${\n              property === null ? `[\"typia.tag\"]` : `[\"typia.tag.${property}\"]`\n            } ${msg}.`,\n          );\n          return false;\n        };\n\n      // VALIDATE AND CONSTRUCT COMMENT TAGS\n      for (const comment of commentList) {\n        const tagger: TagRecord | null = parse(report)(comment);\n        if (tagger === null) continue;\n        for (const [key, value] of Object.entries(tagger)) {\n          const filtered: IMetadataTypeTag[] = value.filter(\n            (v) => v.validate !== null,\n          ) as IMetadataTypeTag[];\n          if (key === \"array\") {\n            if (metadata.arrays.length === 0) {\n              report(`requires array type`);\n              continue;\n            }\n            for (const a of metadata.arrays) {\n              Writable(a).tags = a.tags.filter((x) =>\n                MetadataTypeTagFactory.validate(validateReport)(\"array\")([\n                  ...x,\n                  ...filtered,\n                ]),\n              );\n              if (a.tags.length === 0) a.tags.push(filtered);\n              else for (const tags of a.tags) tags.push(...filtered);\n            }\n          } else {\n            const atomic = metadata.atomics.find((a) => a.type == key);\n            if (atomic === undefined)\n              if (key === \"bigint\" || key === \"number\") {\n                const opposite = key === \"bigint\" ? \"number\" : \"bigint\";\n                if (\n                  tagger[opposite] !== undefined &&\n                  metadata.atomics.some((a) => a.type === opposite)\n                )\n                  continue;\n              } else if (\n                key === \"string\" &&\n                value[0]?.kind === \"format\" &&\n                value[0]?.value === \"date-time\"\n              )\n                continue;\n              else report(`requires ${key} type`);\n            else {\n              Writable(atomic).tags = atomic.tags.filter((x) =>\n                MetadataTypeTagFactory.validate(validateReport)(\n                  key as \"string\",\n                )([...x, ...filtered]),\n              );\n              if (atomic.tags.length === 0) atomic.tags.push(filtered);\n              else for (const tags of atomic.tags) tags.push(...filtered);\n            }\n          }\n        }\n      }\n\n      // DO REPORT\n      if (messages.length !== 0)\n        errors.push({\n          name: \"comment tag(s)\",\n          explore,\n          messages,\n        });\n    };\n\n  const parse =\n    (report: (msg: string) => null) =>\n    (comment: ts.JSDocTagInfo): TagRecord | null => {\n      const parser = PARSER[comment.name];\n      if (parser === undefined) return {};\n\n      const text = (comment.text || [])[0]?.text;\n      if (text === undefined && comment.name !== \"uniqueItems\")\n        return report(`no comment tag value`);\n      return parser(report)(text!);\n    };\n}\n\ntype TagRecord = {\n  [P in Target]?: NotDeterminedTypeTag[];\n};\ntype Target = \"bigint\" | \"number\" | \"string\" | \"array\";\ntype NotDeterminedTypeTag = Omit<IMetadataTypeTag, \"validate\" | \"schema\"> & {\n  validate: string | null;\n  schema: object | undefined;\n};\n\nconst PARSER: Record<\n  string,\n  (report: (msg: string) => null) => (text: string) => {\n    [P in Target]?: NotDeterminedTypeTag[];\n  }\n> = {\n  /* -----------------------------------------------------------\n        ARRAY\n    ----------------------------------------------------------- */\n  items: (report) => (Value) => ({\n    array: [\n      {\n        name: `MinItems<${Value}>`,\n        target: \"array\",\n        kind: \"minItems\",\n        value: parse_integer(report)(true)(Value),\n        validate: `${Value} <= $input.length`,\n        exclusive: true,\n        schema: {\n          minItems: parse_integer(report)(true)(Value),\n        },\n      },\n      {\n        name: `MaxItems<${Value}>`,\n        target: \"array\",\n        kind: \"maxItems\",\n        value: parse_integer(report)(true)(Value),\n        validate: `$input.length <= ${Value}`,\n        exclusive: true,\n        schema: {\n          maxItems: parse_integer(report)(true)(Value),\n        },\n      },\n    ],\n  }),\n  minItems: (report) => (Value) => ({\n    array: [\n      {\n        name: `MinItems<${Value}>`,\n        target: \"array\",\n        kind: \"minItems\",\n        value: parse_integer(report)(true)(Value),\n        validate: `${Value} <= $input.length`,\n        exclusive: true,\n        schema: {\n          minItems: parse_integer(report)(true)(Value),\n        },\n      },\n    ],\n  }),\n  maxItems: (report) => (Value) => ({\n    array: [\n      {\n        name: `MaxItems<${Value}>`,\n        target: \"array\",\n        kind: \"maxItems\",\n        value: parse_integer(report)(true)(Value),\n        validate: `$input.length <= ${Value}`,\n        exclusive: true,\n        schema: {\n          maxItems: parse_integer(report)(true)(Value),\n        },\n      },\n    ],\n  }),\n  uniqueItems: () => () => ({\n    array: [\n      {\n        name: `UniqueItems`,\n        target: \"array\",\n        kind: \"uniqueItems\",\n        value: true,\n        validate: `true === ($input.length === 0 || new Set($input).size === $input.length)`,\n        exclusive: true,\n        schema: {\n          uniqueItems: true,\n        },\n      },\n    ],\n  }),\n\n  /* -----------------------------------------------------------\n        NUMBER\n    ----------------------------------------------------------- */\n  type: () => (Value) => {\n    // EMENDATIONS\n    if (Value.startsWith(\"{\") && Value.endsWith(\"}\"))\n      Value = Value.substring(1, Value.length - 1);\n    if (Value === \"int\") Value = \"int32\";\n    else if (Value === \"uint\") Value = \"uint32\";\n\n    // MUST BE ONE OF THEM\n    if (\n      [\"int32\", \"uint32\", \"int64\", \"uint64\", \"float\", \"double\"].includes(\n        Value,\n      ) === false\n    )\n      return {};\n    return {\n      number: [\n        {\n          name: `Type<${JSON.stringify(Value)}>`,\n          target: \"number\",\n          kind: \"type\",\n          value: Value,\n          validate:\n            Value === \"int32\"\n              ? `Math.floor($input) === $input && -2147483648 <= $input && $input <= 2147483647`\n              : Value === \"uint32\"\n                ? `Math.floor($input) === $input && 0 <= $input && $input <= 4294967295`\n                : Value === \"int64\"\n                  ? `Math.floor($input) === $input && -9223372036854775808 <= $input && $input <= 9223372036854775807`\n                  : Value === \"uint64\"\n                    ? `Math.floor($input) === $input && 0 <= $input && $input <= 18446744073709551615`\n                    : Value === \"float\"\n                      ? `-1.175494351e38 <= $input && $input <= 3.4028235e38`\n                      : `true`,\n          exclusive: true,\n          schema: [\"int32\", \"uint32\", \"int64\", \"uint64\"].includes(Value)\n            ? { type: \"integer\" }\n            : undefined,\n        },\n      ],\n      bigint:\n        Value === \"int64\" || \"uint64\"\n          ? [\n              {\n                name: `Type<${JSON.stringify(Value)}>`,\n                target: \"bigint\",\n                kind: \"type\",\n                value: Value,\n                validate: Value === \"int64\" ? \"true\" : \"BigInt(0) <= $input\",\n                exclusive: true,\n                schema: undefined,\n              },\n            ]\n          : [],\n    };\n  },\n  minimum: (report) => (Value) => ({\n    number: [\n      {\n        name: `Minimum<${Value}>`,\n        target: \"number\",\n        kind: \"minimum\",\n        value: parse_number(report)(Value),\n        validate: `${Value} <= $input`,\n        exclusive: [\"minimum\", \"exclusiveMinimum\"],\n        schema: {\n          minimum: parse_number(report)(Value),\n        },\n      },\n    ],\n    bigint: [\n      {\n        name: `Minimum<${Value}n>`,\n        target: \"bigint\",\n        kind: \"minimum\",\n        value: (() => {\n          const value = parse_integer(report)(false)(Value);\n          return value === null ? null : BigInt(value);\n        })(),\n        validate: `${Value} <= $input`,\n        exclusive: [\"minimum\", \"exclusiveMinimum\"],\n        schema: undefined,\n      },\n    ],\n  }),\n  maximum: (report) => (Value) => ({\n    number: [\n      {\n        name: `Maximum<${Value}>`,\n        target: \"number\",\n        kind: \"maximum\",\n        value: parse_number(report)(Value),\n        validate: `$input <= ${Value}`,\n        exclusive: [\"maximum\", \"exclusiveMaximum\"],\n        schema: {\n          maximum: parse_number(report)(Value),\n        },\n      },\n    ],\n    bigint: [\n      {\n        name: `Maximum<${Value}n>`,\n        target: \"bigint\",\n        kind: \"maximum\",\n        value: (() => {\n          const value = parse_integer(report)(false)(Value);\n          return value === null ? null : BigInt(value);\n        })(),\n        validate: `$input <= ${Value}`,\n        exclusive: [\"maximum\", \"exclusiveMaximum\"],\n        schema: undefined,\n      },\n    ],\n  }),\n  exclusiveMinimum: (report) => (Value) => ({\n    number: [\n      {\n        name: `ExclusiveMinimum<${Value}>`,\n        target: \"number\",\n        kind: \"exclusiveMinimum\",\n        value: parse_number(report)(Value),\n        validate: `${Value} < $input`,\n        exclusive: [\"minimum\", \"exclusiveMinimum\"],\n        schema: {\n          exclusiveMinimum: true,\n          minimum: parse_number(report)(Value),\n        },\n      },\n    ],\n    bigint: [\n      {\n        name: `ExclusiveMinimum<${Value}n>`,\n        target: \"bigint\",\n        kind: \"exclusiveMinimum\",\n        value: (() => {\n          const value = parse_integer(report)(false)(Value);\n          return value === null ? null : BigInt(value);\n        })(),\n        validate: `${Value} < $input`,\n        exclusive: [\"minimum\", \"exclusiveMinimum\"],\n        schema: undefined,\n      },\n    ],\n  }),\n  exclusiveMaximum: (report) => (Value) => ({\n    number: [\n      {\n        name: `ExclusiveMaximum<${Value}>`,\n        target: \"number\",\n        kind: \"exclusiveMaximum\",\n        value: parse_number(report)(Value),\n        validate: `$input < ${Value}`,\n        exclusive: [\"maximum\", \"exclusiveMaximum\"],\n        schema: {\n          exclusiveMaximum: true,\n          maximum: parse_number(report)(Value),\n        },\n      },\n    ],\n    bigint: [\n      {\n        name: `ExclusiveMaximum<${Value}n>`,\n        target: \"bigint\",\n        kind: \"exclusiveMaximum\",\n        value: (() => {\n          const value = parse_integer(report)(false)(Value);\n          return value === null ? null : BigInt(value);\n        })(),\n        validate: `$input < ${Value}`,\n        exclusive: [\"maximum\", \"exclusiveMaximum\"],\n        schema: undefined,\n      },\n    ],\n  }),\n  multipleOf: (report) => (Value) => ({\n    number: [\n      {\n        name: `MultipleOf<${Value}>`,\n        target: \"number\",\n        kind: \"multipleOf\",\n        value: parse_number(report)(Value),\n        validate: `$input % ${Value} === 0`,\n        exclusive: true,\n        schema: {\n          multipleOf: parse_number(report)(Value),\n        },\n      },\n    ],\n    bigint: [\n      {\n        name: `MultipleOf<${Value}n>`,\n        target: \"bigint\",\n        kind: \"multipleOf\",\n        value: (() => {\n          const value = parse_integer(report)(false)(Value);\n          return value === null ? null : BigInt(value);\n        })(),\n        validate: `$input % ${Value}n === 0n`,\n        exclusive: true,\n        schema: undefined,\n      },\n    ],\n  }),\n\n  /* -----------------------------------------------------------\n        STRING\n    ----------------------------------------------------------- */\n  format: () => (Value) => {\n    const matched = FORMATS.get(Value);\n    if (matched === undefined) return {};\n    return {\n      string: [\n        {\n          name: `Format<${JSON.stringify(matched[0])}>`,\n          target: \"string\",\n          kind: \"format\",\n          value: matched[0],\n          validate: matched[1],\n          exclusive: true,\n          schema: {\n            format: matched[0],\n          },\n        },\n      ],\n    };\n  },\n  pattern: () => (Value) => ({\n    string: [\n      {\n        name: `Pattern<${JSON.stringify(Value)}>`,\n        target: \"string\",\n        kind: \"pattern\",\n        value: Value,\n        validate: `RegExp(/${Value}/).test($input)`,\n        exclusive: [\"format\"],\n        schema: {\n          pattern: Value,\n        },\n      },\n    ],\n  }),\n  length: (report) => (Value) => ({\n    string: [\n      {\n        name: `MinLength<${Value}>`,\n        target: \"string\",\n        kind: \"minLength\",\n        value: parse_number(report)(Value),\n        validate: `${Value} <= $input.length`,\n        exclusive: true,\n        schema: {\n          minLength: parse_number(report)(Value),\n        },\n      },\n      {\n        name: `MaxLength<${Value}>`,\n        target: \"string\",\n        kind: \"maxLength\",\n        value: parse_number(report)(Value),\n        validate: `$input.length <= ${Value}`,\n        exclusive: true,\n        schema: {\n          maxLength: parse_number(report)(Value),\n        },\n      },\n    ],\n  }),\n  minLength: (report) => (Value) => ({\n    string: [\n      {\n        name: `MinLength<${Value}>`,\n        target: \"string\",\n        kind: \"minLength\",\n        value: parse_number(report)(Value),\n        validate: `${Value} <= $input.length`,\n        exclusive: true,\n        schema: {\n          minLength: parse_number(report)(Value),\n        },\n      },\n    ],\n  }),\n  maxLength: (report) => (Value) => ({\n    string: [\n      {\n        name: `MaxLength<${Value}>`,\n        target: \"string\",\n        kind: \"maxLength\",\n        value: parse_number(report)(Value),\n        validate: `$input.length <= ${Value}`,\n        exclusive: true,\n        schema: {\n          maxLength: parse_number(report)(Value),\n        },\n      },\n    ],\n  }),\n};\n\nconst parse_number =\n  (report: (msg: string) => null) =>\n  (str: string): number | null => {\n    const value: number = Number(str);\n    if (isNaN(value) === true) return report(`invalid number`);\n    return value;\n  };\n\nconst parse_integer =\n  (report: (msg: string) => null) =>\n  (unsigned: boolean) =>\n  (str: string): number | null => {\n    const value: number | null = parse_number(report)(str);\n    if (value === null) return null;\n    else if (Math.floor(value) !== value) return report(`invalid integer`);\n    else if (unsigned === true && value < 0)\n      return report(`invalid unsigned integer`);\n    return value;\n  };\n\nconst FORMATS: Map<string, [string, string]> = new Map([\n  ...Object.entries(FormatCheatSheet).map(\n    ([key, value]) => [key, [key, value]] as any,\n  ),\n  [\"datetime\", [\"date-time\", `!isNaN(new Date($input).getTime())`]],\n  [\"dateTime\", [\"date-time\", `!isNaN(new Date($input).getTime())`]],\n]);\n"]}