{"version":3,"sources":["../src/programmers/internal/template_to_pattern.ts","../src/programmers/internal/metadata_to_pattern.ts"],"names":["template_to_pattern","top","template","pattern","map","meta","metadata_to_pattern","join","PatternUtil","fix","atomics","find","a","type","undefined","values","constants","c","v","toString","value","str","escape","flat","push","NUMBER","BOOLEAN","childTpl","templates","length"],"mappings":";;;;;;;;AASO,IAAMA,sBAAsB,wBAACC,QAAiB,CAACC,aAAAA;AACpD,QAAMC,UAAkBD,SACrBE,IAAI,CAACC,SAASC,oBAAoB,KAAA,EAAOD,IAAAA,CAAAA,EACzCE,KAAK,EAAA;AACR,SAAON,MAAMO,YAAYC,IAAIN,OAAAA,IAAWA;AAC1C,GALmC;;;ACA5B,IAAMG,sBACX,wBAACL,QACD,CAACI,SAAAA;AACC,MAAIA,KAAKK,QAAQC,KAAK,CAACC,MAAMA,EAAEC,SAAS,QAAA,MAAcC,OACpD,QAAO;AAET,QAAMC,SAAmBV,KAAKW,UAC3BZ,IAAI,CAACa,MAAAA;AACJ,QAAIA,EAAEJ,SAAS,SAAU,QAAOI,EAAEF,OAAOX,IAAI,CAACc,MAAMA,EAAEC,SAAQ,CAAA;AAC9D,WAAQF,EAAEF,OAAOX,IAAI,CAACc,MAAMA,EAAEE,KAAK,EAAehB,IAAI,CAACiB,QACrDb,YAAYc,OAAOD,GAAAA,CAAAA;EAEvB,CAAA,EACCE,KAAI;AACP,aAAWX,KAAKP,KAAKK,QACnB,KAAIE,EAAEC,SAAS,YAAYD,EAAEC,SAAS,SACpCE,QAAOS,KAAKhB,YAAYiB,MAAM;WACvBb,EAAEC,SAAS,UAAWE,QAAOS,KAAKhB,YAAYkB,OAAO;AAChE,aAAWC,YAAYtB,KAAKuB,UAC1Bb,QAAOS,KAAK,MAAMxB,oBAAoB,KAAA,EAAO2B,QAAAA,IAAY,GAAA;AAE3D,QAAMxB,UACJY,OAAOc,WAAW,IAAId,OAAO,CAAA,IAAM,MAAMA,OAAOR,KAAK,GAAA,IAAO;AAC9D,SAAON,MAAMO,YAAYC,IAAIN,OAAAA,IAAWA;AAC1C,GAvBA","sourcesContent":["import { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { PatternUtil } from \"../../utils/PatternUtil\";\n\nimport { metadata_to_pattern } from \"./metadata_to_pattern\";\n\n/**\n * @internal\n */\nexport const template_to_pattern = (top: boolean) => (template: Metadata[]) => {\n  const pattern: string = template\n    .map((meta) => metadata_to_pattern(false)(meta))\n    .join(\"\");\n  return top ? PatternUtil.fix(pattern) : pattern;\n};\n","import { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { PatternUtil } from \"../../utils/PatternUtil\";\n\nimport { template_to_pattern } from \"./template_to_pattern\";\n\n/**\n * @internal\n */\nexport const metadata_to_pattern =\n  (top: boolean) =>\n  (meta: Metadata): string => {\n    if (meta.atomics.find((a) => a.type === \"string\") !== undefined)\n      return \"(.*)\";\n\n    const values: string[] = meta.constants\n      .map((c) => {\n        if (c.type !== \"string\") return c.values.map((v) => v.toString());\n        return (c.values.map((v) => v.value) as string[]).map((str) =>\n          PatternUtil.escape(str),\n        );\n      })\n      .flat();\n    for (const a of meta.atomics)\n      if (a.type === \"number\" || a.type === \"bigint\")\n        values.push(PatternUtil.NUMBER);\n      else if (a.type === \"boolean\") values.push(PatternUtil.BOOLEAN);\n    for (const childTpl of meta.templates)\n      values.push(\"(\" + template_to_pattern(false)(childTpl) + \")\");\n\n    const pattern: string =\n      values.length === 1 ? values[0]! : \"(\" + values.join(\"|\") + \")\";\n    return top ? PatternUtil.fix(pattern) : pattern;\n  };\n"]}