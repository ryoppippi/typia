{"version":3,"sources":["../src/programmers/AssertProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { check_object } from \"./internal/check_object\";\n\nexport namespace AssertProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (props: boolean | { equals: boolean; guard: boolean }) =>\n    (type: ts.Type, name?: string, init?: ts.Expression) => {\n      // TO SUPPORT LEGACY FEATURE\n      if (typeof props === \"boolean\") props = { equals: props, guard: false };\n\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const is: ts.ArrowFunction = IsProgrammer.write(project)(modulo, true)(\n        props.equals,\n      )(type, name ?? TypeFactory.getFullName(project.checker)(type));\n      const assert: ts.ArrowFunction = CheckerProgrammer.write(project)({\n        prefix: \"$a\",\n        path: true,\n        trace: true,\n        numeric: OptionPredicator.numeric(project.options),\n        equals: props.equals,\n        atomist: (explore) => (entry) => (input) =>\n          [\n            ...(entry.expression ? [entry.expression] : []),\n            ...(entry.conditions.length === 0\n              ? []\n              : entry.conditions.length === 1\n                ? entry.conditions[0]!.map((cond) =>\n                    ts.factory.createLogicalOr(\n                      cond.expression,\n                      create_guard_call(importer)(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        cond.expected,\n                        input,\n                      ),\n                    ),\n                  )\n                : [\n                    ts.factory.createLogicalOr(\n                      entry.conditions\n                        .map((set) =>\n                          set\n                            .map((s) => s.expression)\n                            .reduce((a, b) =>\n                              ts.factory.createLogicalAnd(a, b),\n                            ),\n                        )\n                        .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n                      create_guard_call(importer)(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        entry.expected,\n                        input,\n                      ),\n                    ),\n                  ]),\n          ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n        combiner: combiner(props.equals)(project)(importer),\n        joiner: joiner(props.equals)(project)(importer),\n        success: ts.factory.createTrue(),\n        addition: () => importer.declare(modulo),\n      })(importer)(type, name);\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\")),\n          Guardian.parameter(init),\n        ],\n        props.guard\n          ? ts.factory.createTypePredicateNode(\n              ts.factory.createToken(ts.SyntaxKind.AssertsKeyword),\n              ts.factory.createIdentifier(\"input\"),\n              ts.factory.createTypeReferenceNode(\n                name ?? TypeFactory.getFullName(project.checker)(type),\n              ),\n            )\n          : ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            StatementFactory.constant(\"__is\", is),\n            ts.factory.createIfStatement(\n              ts.factory.createStrictEquality(\n                ts.factory.createFalse(),\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"__is\"),\n                  undefined,\n                  [ts.factory.createIdentifier(\"input\")],\n                ),\n              ),\n              ts.factory.createExpressionStatement(\n                ts.factory.createCallExpression(assert, undefined, [\n                  ts.factory.createIdentifier(\"input\"),\n                  ts.factory.createStringLiteral(\"$input\"),\n                  ts.factory.createTrue(),\n                ]),\n              ),\n              undefined,\n            ),\n            ...(props.guard === false\n              ? [\n                  ts.factory.createReturnStatement(\n                    ts.factory.createIdentifier(`input`),\n                  ),\n                ]\n              : []),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const combiner =\n    (equals: boolean) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig.Combiner =>\n    (explore: CheckerProgrammer.IExplore) => {\n      if (explore.tracable === false)\n        return IsProgrammer.configure({\n          object: assert_object(equals)(project)(importer),\n          numeric: true,\n        })(project)(importer).combiner(explore);\n\n      const path: string = explore.postfix\n        ? `_path + ${explore.postfix}`\n        : \"_path\";\n      return (logic) => (input, binaries, expected) =>\n        logic === \"and\"\n          ? binaries\n              .map((binary) =>\n                binary.combined\n                  ? binary.expression\n                  : ts.factory.createLogicalOr(\n                      binary.expression,\n                      create_guard_call(importer)(\n                        explore.source === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(ts.factory.createIdentifier(path), expected, input),\n                    ),\n              )\n              .reduce(ts.factory.createLogicalAnd)\n          : ts.factory.createLogicalOr(\n              binaries\n                .map((binary) => binary.expression)\n                .reduce(ts.factory.createLogicalOr),\n              create_guard_call(importer)(\n                explore.source === \"top\"\n                  ? ts.factory.createTrue()\n                  : ts.factory.createIdentifier(\"_exceptionable\"),\n              )(ts.factory.createIdentifier(path), expected, input),\n            );\n      // : (() => {\n      //       const addicted = binaries.slice();\n      //       if (\n      //           addicted[addicted.length - 1]!.combined === false\n      //       ) {\n      //           addicted.push({\n      //               combined: true,\n      //               expression: create_guard_call(importer)(\n      //                   explore.source === \"top\"\n      //                       ? ts.factory.createTrue()\n      //                       : ts.factory.createIdentifier(\n      //                             \"_exceptionable\",\n      //                         ),\n      //               )(\n      //                   ts.factory.createIdentifier(path),\n      //                   expected,\n      //                   input,\n      //               ),\n      //           });\n      //       }\n      //       return addicted\n      //           .map((b) => b.expression)\n      //           .reduce(ts.factory.createLogicalOr);\n      //   })();\n    };\n\n  const assert_object =\n    (equals: boolean) => (project: IProject) => (importer: FunctionImporter) =>\n      check_object({\n        equals,\n        assert: true,\n        undefined: true,\n        reduce: ts.factory.createLogicalAnd,\n        positive: ts.factory.createTrue(),\n        superfluous: (value) =>\n          create_guard_call(importer)()(\n            ts.factory.createAdd(\n              ts.factory.createIdentifier(\"_path\"),\n              ts.factory.createCallExpression(importer.use(\"join\"), undefined, [\n                ts.factory.createIdentifier(\"key\"),\n              ]),\n            ),\n            \"undefined\",\n            value,\n          ),\n        halt: (expr) =>\n          ts.factory.createLogicalOr(\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createIdentifier(\"_exceptionable\"),\n            ),\n            expr,\n          ),\n      })(project)(importer);\n\n  const joiner =\n    (equals: boolean) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig.IJoiner => ({\n      object: assert_object(equals)(project)(importer),\n      array: (input, arrow) =>\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"every\"),\n          undefined,\n          [arrow],\n        ),\n      failure: (value, expected, explore) =>\n        create_guard_call(importer)(\n          explore?.from === \"top\"\n            ? ts.factory.createTrue()\n            : ts.factory.createIdentifier(\"_exceptionable\"),\n        )(\n          ts.factory.createIdentifier(\n            explore?.postfix ? `_path + ${explore.postfix}` : \"_path\",\n          ),\n          expected,\n          value,\n        ),\n      full: equals\n        ? undefined\n        : (condition) => (input, expected, explore) =>\n            ts.factory.createLogicalOr(\n              condition,\n              create_guard_call(importer)(\n                explore.from === \"top\"\n                  ? ts.factory.createTrue()\n                  : ts.factory.createIdentifier(\"_exceptionable\"),\n              )(ts.factory.createIdentifier(\"_path\"), expected, input),\n            ),\n    });\n\n  const create_guard_call =\n    (importer: FunctionImporter) =>\n    (exceptionable?: ts.Expression) =>\n    (\n      path: ts.Expression,\n      expected: string,\n      value: ts.Expression,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(importer.use(\"guard\"), undefined, [\n        exceptionable ?? ts.factory.createIdentifier(\"_exceptionable\"),\n        ts.factory.createObjectLiteralExpression(\n          [\n            ts.factory.createPropertyAssignment(\"path\", path),\n            ts.factory.createPropertyAssignment(\n              \"expected\",\n              ts.factory.createStringLiteral(expected),\n            ),\n            ts.factory.createPropertyAssignment(\"value\", value),\n          ],\n          true,\n        ),\n        Guardian.identifier(),\n      ]);\n\n  export namespace Guardian {\n    export const identifier = () => ts.factory.createIdentifier(\"errorFactory\");\n    export const parameter = (init: ts.Expression | undefined) =>\n      IdentifierFactory.parameter(\n        \"errorFactory\",\n        type(),\n        init ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n      );\n    export const type = () =>\n      ts.factory.createFunctionTypeNode(\n        undefined,\n        [\n          ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            ts.factory.createIdentifier(\"p\"),\n            undefined,\n            ts.factory.createImportTypeNode(\n              ts.factory.createLiteralTypeNode(\n                ts.factory.createStringLiteral(\"typia\"),\n              ),\n              undefined,\n              ts.factory.createQualifiedName(\n                ts.factory.createIdentifier(\"TypeGuardError\"),\n                ts.factory.createIdentifier(\"IProps\"),\n              ),\n              undefined,\n              false,\n            ),\n            undefined,\n          ),\n        ],\n        ts.factory.createTypeReferenceNode(\n          ts.factory.createIdentifier(\"Error\"),\n          undefined,\n        ),\n      );\n  }\n}\n"],"mappings":"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","names":["ts","AssertProgrammer","write","project","modulo","props","type","name","init","equals","guard","importer","FunctionImporter","getText","is","IsProgrammer","TypeFactory","getFullName","checker","assert","CheckerProgrammer","prefix","path","trace","numeric","OptionPredicator","options","atomist","explore","entry","input","expression","conditions","length","map","cond","ts","factory","createLogicalOr","create_guard_call","from","createTrue","createIdentifier","postfix","expected","set","s","reduce","a","b","createLogicalAnd","x","y","combiner","joiner","success","addition","declare","createArrowFunction","undefined","IdentifierFactory","parameter","keyword","Guardian","createTypePredicateNode","createToken","SyntaxKind","AssertsKeyword","createTypeReferenceNode","createBlock","StatementFactory","constant","createIfStatement","createStrictEquality","createFalse","createCallExpression","createExpressionStatement","createStringLiteral","createReturnStatement","tracable","configure","object","assert_object","logic","binaries","binary","combined","source","check_object","positive","superfluous","value","createAdd","use","halt","expr","array","arrow","access","failure","full","condition","exceptionable","createObjectLiteralExpression","createPropertyAssignment","identifier","QuestionToken","createFunctionTypeNode","createParameterDeclaration","createImportTypeNode","createLiteralTypeNode","createQualifiedName"]}