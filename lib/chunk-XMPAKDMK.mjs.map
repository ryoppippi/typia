{"version":3,"sources":["../src/programmers/RandomProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../factories/MetadataFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TemplateFactory } from \"../factories/TemplateFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../schemas/metadata/MetadataArrayType\";\nimport { MetadataAtomic } from \"../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../transformers/IProject\";\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { Escaper } from \"../utils/Escaper\";\n\nimport { Format } from \"../tags\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { RandomJoiner } from \"./helpers/RandomJoiner\";\nimport { RandomRanger } from \"./helpers/RandomRanger\";\nimport { random_custom } from \"./internal/random_custom\";\n\nexport namespace RandomProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (init?: ts.Expression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      return (type: ts.Type, name?: string) => {\n        // INITIALIZE METADATA\n        const collection: MetadataCollection = new MetadataCollection();\n        const result = MetadataFactory.analyze(\n          project.checker,\n          project.context,\n        )({\n          escape: false,\n          constant: true,\n          absorb: true,\n          validate: (meta) => {\n            const output: string[] = [];\n            if (meta.natives.some((n) => n === \"WeakSet\"))\n              output.push(`WeakSet is not supported.`);\n            else if (meta.natives.some((n) => n === \"WeakMap\"))\n              output.push(`WeakMap is not supported.`);\n            return output;\n          },\n        })(collection)(type);\n        if (result.success === false)\n          throw TransformerError.from(`typia.${importer.method}`)(\n            result.errors,\n          );\n\n        // GENERATE FUNCTION\n        const functions = {\n          objects: write_object_functions(importer)(collection),\n          arrays: write_array_functions(importer)(collection),\n          tuples: write_tuple_functions(importer)(collection),\n        };\n\n        const output: ts.Expression = decode(importer)({\n          function: false,\n          recursive: false,\n        })(result.data);\n\n        return ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\n              \"generator\",\n              ts.factory.createTypeReferenceNode(\n                \"Partial<typia.IRandomGenerator>\",\n              ),\n              init ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n            ),\n          ],\n          ts.factory.createImportTypeNode(\n            ts.factory.createLiteralTypeNode(\n              ts.factory.createStringLiteral(\"typia\"),\n            ),\n            undefined,\n            ts.factory.createIdentifier(\"Resolved\"),\n            [\n              ts.factory.createTypeReferenceNode(\n                name ?? TypeFactory.getFullName(project.checker)(type),\n              ),\n            ],\n            false,\n          ),\n          undefined,\n          ts.factory.createBlock(\n            [\n              ...importer.declare(modulo),\n              ...functions.objects,\n              ...functions.arrays,\n              ...functions.tuples,\n              ts.factory.createReturnStatement(output),\n            ],\n            true,\n          ),\n        );\n      };\n    };\n\n  const write_object_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection.objects().map((obj, i) =>\n        StatementFactory.constant(\n          PREFIX.object(i),\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              IdentifierFactory.parameter(\n                \"_recursive\",\n                TypeFactory.keyword(\"boolean\"),\n                ts.factory.createIdentifier(String(obj.recursive)),\n              ),\n              IdentifierFactory.parameter(\n                \"_depth\",\n                TypeFactory.keyword(\"number\"),\n                ExpressionFactory.number(0),\n              ),\n            ],\n            TypeFactory.keyword(\"any\"),\n            undefined,\n            RandomJoiner.object(COALESCE(importer))(\n              decode(importer)({\n                recursive: obj.recursive,\n                function: true,\n              }),\n            )(obj),\n          ),\n        ),\n      );\n\n  const write_array_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((array, i) =>\n          StatementFactory.constant(\n            PREFIX.array(i),\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"length\",\n                  TypeFactory.keyword(\"number\"),\n                ),\n                IdentifierFactory.parameter(\n                  \"_recursive\",\n                  TypeFactory.keyword(\"boolean\"),\n                  ts.factory.createTrue(),\n                ),\n                IdentifierFactory.parameter(\n                  \"_depth\",\n                  TypeFactory.keyword(\"number\"),\n                  ExpressionFactory.number(0),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              RandomJoiner.array(COALESCE(importer))(\n                decode(importer)({\n                  recursive: true,\n                  function: true,\n                }),\n              )({\n                recursive: true,\n                function: true,\n              })(ts.factory.createIdentifier(\"length\"))(array.value),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((a) => a.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            PREFIX.tuple(i),\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"_recursive\",\n                  TypeFactory.keyword(\"boolean\"),\n                  ts.factory.createTrue(),\n                ),\n                IdentifierFactory.parameter(\n                  \"_depth\",\n                  TypeFactory.keyword(\"number\"),\n                  ExpressionFactory.number(0),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              RandomJoiner.tuple(\n                decode(importer)({\n                  function: true,\n                  recursive: true,\n                }),\n              )(tuple.elements),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (meta: Metadata): ts.Expression => {\n      const expressions: ts.Expression[] = [];\n      if (meta.any)\n        expressions.push(ts.factory.createStringLiteral(\"any type used...\"));\n\n      // NULL COALESCING\n      if (meta.isRequired() === false || meta.functional === true)\n        expressions.push(ts.factory.createIdentifier(\"undefined\"));\n      if (meta.nullable === true) expressions.push(ts.factory.createNull());\n\n      // CONSTANT TYPES\n      for (const constant of meta.constants)\n        for (const { value } of constant.values)\n          expressions.push(decode_atomic(value));\n\n      // ATOMIC VARIABLES\n      for (const template of meta.templates)\n        expressions.push(decode_template(importer)(explore)(template));\n      for (const atomic of meta.atomics)\n        if (atomic.type === \"boolean\")\n          expressions.push(decode_boolean(importer));\n        else if (atomic.type === \"number\")\n          expressions.push(...decode_number(importer)(atomic));\n        else if (atomic.type === \"string\")\n          expressions.push(...decode_string(importer)(atomic));\n        else if (atomic.type === \"bigint\")\n          expressions.push(...decode_bigint(importer)(atomic));\n\n      // INSTANCE TYPES\n      if (meta.escaped)\n        expressions.push(decode(importer)(explore)(meta.escaped.returns));\n      for (const array of meta.arrays)\n        expressions.push(...decode_array(importer)(explore)(array));\n      for (const tuple of meta.tuples)\n        expressions.push(decode_tuple(importer)(explore)(tuple));\n      for (const o of meta.objects)\n        expressions.push(decode_object(importer)(explore)(o));\n      for (const native of meta.natives)\n        expressions.push(decode_native(importer)(native));\n      for (const set of meta.sets)\n        expressions.push(decode_set(importer)(explore)(set));\n      for (const map of meta.maps)\n        expressions.push(decode_map(importer)(explore)(map));\n\n      // PICK UP A TYPE\n      if (expressions.length === 1) return expressions[0]!;\n      return ts.factory.createCallExpression(\n        ts.factory.createCallExpression(importer.use(\"pick\"), undefined, [\n          ts.factory.createArrayLiteralExpression(\n            expressions.map((expr) =>\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                undefined,\n                undefined,\n                expr,\n              ),\n            ),\n            true,\n          ),\n        ]),\n        undefined,\n        undefined,\n      );\n    };\n\n  const decode_boolean = (importer: FunctionImporter) =>\n    ts.factory.createCallExpression(\n      COALESCE(importer)(\"boolean\"),\n      undefined,\n      undefined,\n    );\n\n  const decode_atomic = (value: Atomic) =>\n    typeof value === \"boolean\"\n      ? ts.factory.createIdentifier(value.toString())\n      : typeof value === \"number\"\n        ? ExpressionFactory.number(value)\n        : typeof value === \"string\"\n          ? ts.factory.createStringLiteral(value)\n          : ExpressionFactory.bigint(Number(value));\n\n  const decode_template =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (template: Metadata[]) =>\n      TemplateFactory.generate(\n        template.map((meta) => decode(importer)(explore)(meta)),\n      );\n\n  const decode_number =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) => {\n        const type = tags.find(\n          (t) =>\n            t.kind === \"type\" && (t.value === \"int32\" || t.value === \"int64\"),\n        )\n          ? \"int\"\n          : tags.find(\n                (t) =>\n                  t.kind === \"type\" &&\n                  (t.value === \"uint32\" || t.value === \"uint64\"),\n              )\n            ? \"uint\"\n            : \"double\";\n        const multiply = tags.find((t) => t.kind === \"multipleOf\");\n        return random_custom(COALESCE(importer))(\"number\")(tags)(\n          RandomRanger.number({\n            type,\n            transform: (value) => ExpressionFactory.number(value),\n            setter: (args) =>\n              ts.factory.createCallExpression(\n                type !== \"double\" || multiply !== undefined\n                  ? COALESCE(importer)(\"integer\")\n                  : COALESCE(importer)(\"number\"),\n                undefined,\n                args.map((val) => ExpressionFactory.number(val)),\n              ),\n          })({\n            minimum: 0,\n            maximum: 100,\n            gap: 10,\n          })(tags),\n        );\n      });\n\n  const decode_bigint =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) =>\n        random_custom(COALESCE(importer))(\"bigint\")(tags)(\n          RandomRanger.number({\n            type: tags.find(\n              (t) =>\n                t.kind === \"type\" &&\n                (t.value === \"uint\" || t.value === \"uint64\"),\n            )\n              ? \"uint\"\n              : \"int\",\n            transform: (value) => ExpressionFactory.bigint(value),\n            setter: (args) =>\n              ts.factory.createCallExpression(\n                COALESCE(importer)(\"bigint\"),\n                undefined,\n                args.map((value) => ExpressionFactory.bigint(value)),\n              ),\n          })({\n            minimum: 0,\n            maximum: 100,\n            gap: 10,\n          })(tags),\n        ),\n      );\n\n  const decode_string =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) =>\n        random_custom(COALESCE(importer))(\"string\")(tags)(\n          (() => {\n            for (const t of tags)\n              if (t.kind === \"format\")\n                return ts.factory.createCallExpression(\n                  COALESCE(importer)(emendFormat(t.value)),\n                  undefined,\n                  undefined,\n                );\n              else if (t.kind === \"pattern\")\n                return ts.factory.createCallExpression(\n                  COALESCE(importer)(\"pattern\"),\n                  undefined,\n                  [ts.factory.createIdentifier(`/${t.value}/`)],\n                );\n\n            const tail = RandomRanger.length(COALESCE(importer))({\n              minimum: 5,\n              maximum: 25,\n              gap: 5,\n            })({\n              minimum: \"minLength\",\n              maximum: \"maxLength\",\n            })(tags);\n            return ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              tail ? [tail] : undefined,\n            );\n          })(),\n        ),\n      );\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (array: MetadataArray): ts.Expression[] => {\n      const lengths: Array<ts.Expression | undefined> = (\n        array.tags.length ? array.tags : [[]]\n      ).map((tags) =>\n        RandomRanger.length(COALESCE(importer))({\n          minimum: 0,\n          maximum: 3,\n          gap: 3,\n        })({\n          minimum: \"minItems\",\n          maximum: \"maxItems\",\n        })(tags),\n      );\n      if (array.type.recursive)\n        return lengths.map((len) =>\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(PREFIX.array(array.type.index!)),\n            ),\n            undefined,\n            [\n              len ?? COALESCE(importer)(\"length\"),\n              ts.factory.createTrue(),\n              explore.recursive\n                ? ts.factory.createAdd(\n                    ExpressionFactory.number(1),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  )\n                : ExpressionFactory.number(0),\n            ],\n          ),\n        );\n      return lengths.map((len) => {\n        const expr: ts.Expression = RandomJoiner.array(COALESCE(importer))(\n          decode(importer)(explore),\n        )(explore)(len)(array.type.value);\n        return explore.recursive\n          ? ts.factory.createConditionalExpression(\n              ts.factory.createLogicalAnd(\n                ts.factory.createIdentifier(\"_recursive\"),\n                ts.factory.createLessThan(\n                  ExpressionFactory.number(5),\n                  ts.factory.createIdentifier(\"_depth\"),\n                ),\n              ),\n              undefined,\n              ts.factory.createIdentifier(\"[]\"),\n              undefined,\n              expr,\n            )\n          : expr;\n      });\n    };\n\n  const decode_tuple =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (tuple: MetadataTuple): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(PREFIX.tuple(tuple.type.index!)),\n            ),\n            undefined,\n            [\n              ts.factory.createTrue(),\n              explore.recursive\n                ? ts.factory.createAdd(\n                    ExpressionFactory.number(1),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  )\n                : ExpressionFactory.number(0),\n            ],\n          )\n        : RandomJoiner.tuple(decode(importer)(explore))(tuple.type.elements);\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (object: MetadataObject) =>\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(PREFIX.object(object.index)),\n        ),\n        undefined,\n        explore.function\n          ? [\n              explore.recursive\n                ? ts.factory.createTrue()\n                : ts.factory.createIdentifier(\"_recursive\"),\n              ts.factory.createConditionalExpression(\n                ts.factory.createIdentifier(\"_recursive\"),\n                undefined,\n                ts.factory.createAdd(\n                  ExpressionFactory.number(1),\n                  ts.factory.createIdentifier(\"_depth\"),\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"_depth\"),\n              ),\n            ]\n          : undefined,\n      );\n\n  /* -----------------------------------------------------------\n        NATIVE CLASSES\n    ----------------------------------------------------------- */\n  const decode_set =\n    (importer: FunctionImporter) => (explore: IExplore) => (meta: Metadata) =>\n      ts.factory.createNewExpression(\n        ts.factory.createIdentifier(\"Set\"),\n        undefined,\n        [\n          decode_array(importer)(explore)(\n            MetadataArray.create({\n              tags: [],\n              type: MetadataArrayType.create({\n                value: meta,\n                recursive: false,\n                index: null,\n                nullables: [],\n                name: `Set<${meta.getName()}>`,\n              }),\n            }),\n          )[0]!,\n        ],\n      );\n\n  const decode_map =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (map: Metadata.Entry) =>\n      ts.factory.createNewExpression(\n        ts.factory.createIdentifier(\"Map\"),\n        undefined,\n        [\n          decode_array(importer)(explore)(\n            MetadataArray.create({\n              tags: [],\n              type: MetadataArrayType.create({\n                name: `Map<${map.key.getName()}, ${map.value.getName()}>`,\n                index: null,\n                recursive: false,\n                nullables: [],\n                value: Metadata.create({\n                  ...Metadata.initialize(),\n                  tuples: [\n                    (() => {\n                      const type = MetadataTupleType.create({\n                        name: `[${map.key.getName()}, ${map.value.getName()}]`,\n                        index: null,\n                        recursive: false,\n                        nullables: [],\n                        elements: [map.key, map.value],\n                      });\n                      type.of_map = true;\n                      return MetadataTuple.create({\n                        type,\n                        tags: [],\n                      });\n                    })(),\n                  ],\n                }),\n              }),\n            }),\n          )[0]!,\n        ],\n      );\n\n  const decode_native =\n    (importer: FunctionImporter) =>\n    (type: string): ts.Expression => {\n      if (type === \"Boolean\") return decode_boolean(importer);\n      else if (type === \"Number\")\n        return decode_number(importer)(\n          MetadataAtomic.create({\n            type: \"number\",\n            tags: [],\n          }),\n        )[0]!;\n      else if (type === \"String\")\n        return decode_string(importer)(\n          MetadataAtomic.create({\n            type: \"string\",\n            tags: [],\n          }),\n        )[0]!;\n      else if (type === \"Date\") return decode_native_date(importer);\n      else if (\n        type === \"Uint8Array\" ||\n        type === \"Uint8ClampedArray\" ||\n        type === \"Uint16Array\" ||\n        type === \"Uint32Array\" ||\n        type === \"BigUint64Array\" ||\n        type === \"Int8Array\" ||\n        type === \"Int16Array\" ||\n        type === \"Int32Array\" ||\n        type === \"BigInt64Array\" ||\n        type === \"Float32Array\" ||\n        type === \"Float64Array\"\n      )\n        return decode_native_byte_array(importer)(type);\n      else if (type === \"ArrayBuffer\" || type === \"SharedArrayBuffer\")\n        return decode_native_array_buffer(importer)(type);\n      else if (type === \"DataView\") return decode_native_data_view(importer);\n      else if (type === \"Blob\") return decode_native_blob(importer);\n      else if (type === \"File\") return decode_native_file(importer);\n      else\n        return ts.factory.createNewExpression(\n          ts.factory.createIdentifier(type),\n          undefined,\n          [],\n        );\n    };\n\n  const decode_native_date = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"Date\"),\n      undefined,\n      [\n        ts.factory.createCallExpression(\n          COALESCE(importer)(\"datetime\"),\n          undefined,\n          [],\n        ),\n      ],\n    );\n\n  const decode_native_byte_array =\n    (importer: FunctionImporter) =>\n    (\n      type:\n        | \"Uint8Array\"\n        | \"Uint8ClampedArray\"\n        | \"Uint16Array\"\n        | \"Uint32Array\"\n        | \"BigUint64Array\"\n        | \"Int8Array\"\n        | \"Int16Array\"\n        | \"Int32Array\"\n        | \"BigInt64Array\"\n        | \"Float32Array\"\n        | \"Float64Array\",\n    ): ts.Expression => {\n      new BigInt64Array();\n      const [minimum, maximum]: [number, number] = (() => {\n        if (type === \"Uint8Array\" || type === \"Uint8ClampedArray\")\n          return [0, 255];\n        else if (type === \"Uint16Array\") return [0, 65535];\n        else if (type === \"Uint32Array\") return [0, 4294967295];\n        else if (type === \"BigUint64Array\") return [0, 18446744073709551615];\n        else if (type === \"Int8Array\") return [-128, 127];\n        else if (type === \"Int16Array\") return [-32768, 32767];\n        else if (type === \"Int32Array\") return [-2147483648, 2147483647];\n        else if (type === \"BigInt64Array\")\n          return [-9223372036854775808, 9223372036854775807];\n        else if (type === \"Float32Array\")\n          return [-1.175494351e38, 3.4028235e38];\n        return [Number.MIN_VALUE, Number.MAX_VALUE];\n      })();\n      const literal =\n        type === \"BigInt64Array\" || type === \"BigUint64Array\"\n          ? ExpressionFactory.bigint\n          : ExpressionFactory.number;\n      return ts.factory.createNewExpression(\n        ts.factory.createIdentifier(type),\n        [],\n        [\n          ts.factory.createCallExpression(\n            COALESCE(importer)(\"array\"),\n            undefined,\n            [\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                TypeFactory.keyword(\"any\"),\n                undefined,\n                ts.factory.createCallExpression(\n                  COALESCE(importer)(\n                    type === \"Float32Array\" || type === \"Float64Array\"\n                      ? \"number\"\n                      : type === \"BigInt64Array\" || type === \"BigUint64Array\"\n                        ? \"bigint\"\n                        : \"integer\",\n                  ),\n                  undefined,\n                  [literal(minimum), literal(maximum)],\n                ),\n              ),\n            ],\n          ),\n        ],\n      );\n    };\n\n  const decode_native_blob = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"Blob\"),\n      undefined,\n      [\n        ts.factory.createArrayLiteralExpression(\n          [decode_native_byte_array(importer)(\"Uint8Array\")],\n          true,\n        ),\n      ],\n    );\n\n  const decode_native_file = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"File\"),\n      undefined,\n      [\n        ts.factory.createArrayLiteralExpression(\n          [decode_native_byte_array(importer)(\"Uint8Array\")],\n          true,\n        ),\n        ts.factory.createTemplateExpression(ts.factory.createTemplateHead(\"\"), [\n          ts.factory.createTemplateSpan(\n            ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              [ts.factory.createNumericLiteral(8)],\n            ),\n            ts.factory.createTemplateMiddle(\".\"),\n          ),\n          ts.factory.createTemplateSpan(\n            ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              [ts.factory.createNumericLiteral(3)],\n            ),\n            ts.factory.createTemplateTail(\"\"),\n          ),\n        ]),\n      ],\n    );\n\n  const decode_native_array_buffer =\n    (importer: FunctionImporter) =>\n    (type: \"ArrayBuffer\" | \"SharedArrayBuffer\"): ts.Expression =>\n      type === \"ArrayBuffer\"\n        ? IdentifierFactory.access(\n            decode_native_byte_array(importer)(\"Uint8Array\"),\n          )(\"buffer\")\n        : ExpressionFactory.selfCall(\n            ts.factory.createBlock(\n              [\n                StatementFactory.constant(\n                  \"length\",\n                  ts.factory.createCallExpression(\n                    COALESCE(importer)(\"integer\"),\n                    undefined,\n                    [],\n                  ),\n                ),\n                StatementFactory.constant(\n                  \"buffer\",\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"SharedArrayBuffer\"),\n                    [],\n                    [ts.factory.createIdentifier(\"length\")],\n                  ),\n                ),\n                StatementFactory.constant(\n                  \"bytes\",\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    [],\n                    [ts.factory.createIdentifier(\"buffer\")],\n                  ),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(\n                      ts.factory.createIdentifier(\"bytes\"),\n                    )(\"set\"),\n                    undefined,\n                    [\n                      ts.factory.createCallExpression(\n                        COALESCE(importer)(\"array\"),\n                        undefined,\n                        [\n                          ts.factory.createArrowFunction(\n                            undefined,\n                            undefined,\n                            [],\n                            TypeFactory.keyword(\"any\"),\n                            undefined,\n                            ts.factory.createCallExpression(\n                              COALESCE(importer)(\"integer\"),\n                              undefined,\n                              [\n                                ExpressionFactory.number(0),\n                                ExpressionFactory.number(255),\n                              ],\n                            ),\n                          ),\n                          ts.factory.createIdentifier(\"length\"),\n                        ],\n                      ),\n                      ExpressionFactory.number(0),\n                    ],\n                  ),\n                ),\n                ts.factory.createReturnStatement(\n                  ts.factory.createIdentifier(\"buffer\"),\n                ),\n              ],\n              true,\n            ),\n          );\n\n  const decode_native_data_view = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"DataView\"),\n      [],\n      [\n        IdentifierFactory.access(\n          decode_native_byte_array(importer)(\"Uint8Array\"),\n        )(\"buffer\"),\n      ],\n    );\n}\n\ntype Atomic = boolean | number | string | bigint;\ninterface IExplore {\n  function: boolean;\n  recursive: boolean;\n}\n\nconst PREFIX = {\n  object: (i: number) => `$ro${i}`,\n  array: (i: number) => `$ra${i}`,\n  tuple: (i: number) => `$rt${i}`,\n};\n\nconst COALESCE = (importer: FunctionImporter) => (name: string) =>\n  ExpressionFactory.coalesce(\n    Escaper.variable(name)\n      ? ts.factory.createPropertyAccessChain(\n          ts.factory.createIdentifier(\"generator\"),\n          ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n          ts.factory.createIdentifier(name),\n        )\n      : ts.factory.createElementAccessChain(\n          ts.factory.createIdentifier(\"generator\"),\n          ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n          ts.factory.createStringLiteral(name),\n        ),\n  )(IdentifierFactory.access(importer.use(\"generator\"))(name));\n\nconst emendFormat = (key: keyof Format.Validator) =>\n  key === \"date-time\"\n    ? \"datetime\"\n    : key\n        .split(\"-\")\n        .map((str, i) =>\n          i === 0 || str.length === 0\n            ? str\n            : str[0]!.toUpperCase() + str.substring(1),\n        )\n        .join(\"\");\n"],"mappings":"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","names":["ts","RandomProgrammer","write","project","modulo","init","importer","FunctionImporter","getText","type","name","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","meta","output","natives","some","n","push","success","TransformerError","from","method","errors","functions","objects","write_object_functions","arrays","write_array_functions","tuples","write_tuple_functions","decode","function","recursive","data","ts","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createToken","SyntaxKind","QuestionToken","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","createReturnStatement","map","obj","i","StatementFactory","PREFIX","object","keyword","String","ExpressionFactory","number","RandomJoiner","COALESCE","filter","a","array","createTrue","value","tuple","elements","explore","expressions","any","isRequired","functional","nullable","createNull","constants","values","decode_atomic","template","templates","decode_template","atomic","atomics","decode_boolean","decode_number","decode_string","decode_bigint","escaped","returns","decode_array","decode_tuple","o","decode_object","native","decode_native","set","sets","decode_set","maps","decode_map","length","createCallExpression","use","createArrayLiteralExpression","expr","toString","bigint","Number","TemplateFactory","generate","tags","find","t","kind","multiply","random_custom","RandomRanger","transform","setter","args","val","minimum","maximum","gap","emendFormat","tail","lengths","len","useLocal","index","createAdd","createConditionalExpression","createLogicalAnd","createLessThan","createNewExpression","MetadataArray","create","MetadataArrayType","nullables","getName","key","Metadata","initialize","MetadataTupleType","of_map","MetadataTuple","MetadataAtomic","decode_native_date","decode_native_byte_array","decode_native_array_buffer","decode_native_data_view","decode_native_blob","decode_native_file","BigInt64Array","MIN_VALUE","MAX_VALUE","literal","createTemplateExpression","createTemplateHead","createTemplateSpan","createNumericLiteral","createTemplateMiddle","createTemplateTail","access","selfCall","createExpressionStatement","coalesce","Escaper","variable","createPropertyAccessChain","QuestionDotToken","createElementAccessChain","split","str","toUpperCase","substring","join"]}