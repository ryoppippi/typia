{"version":3,"sources":["../src/misc.ts"],"names":["misc_exports","literals","halt","clone","clonePure","Object","assign","Namespace","misc","assertClone","assertClonePure","assert","isClone","isClonePure","is","validateClone","validateClonePure","validate","prune","prunePure","assertPrune","assertPrunePure","isPrune","isPrunePure","validatePrune","validatePrunePure","createClone","createClonePure","createAssertClone","createAssertClonePure","createIsClone","createIsClonePure","createValidateClone","createValidateClonePure","createPrune","createPrunePure","createAssertPrune","createAssertPrunePure","createIsPrune","createIsPrunePure","createValidatePrune","createValidatePrunePure","name","Error"],"mappings":"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","sourcesContent":["/* ===========================================================\n    MISCELLAENOUS\n      - LITERALS\n      - CLONE\n      - PRUNE\n      - FACTORY FUNCTIONS\n==============================================================\n    LITERALS\n----------------------------------------------------------- */\nimport * as Namespace from \"./functional/Namespace\";\n\nimport { Atomic } from \"./typings/Atomic\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<\"A\" | \"B\" | 1>; // [\"A\", \"B\", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type's members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function literals(): never;\n\n/**\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<\"A\" | \"B\" | 1>; // [\"A\", \"B\", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type's members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function literals<T extends Atomic.Type | null>(): T[];\n\n/**\n * @internal\n */\nexport function literals(): never {\n  halt(\"literals\");\n}\n\n/* -----------------------------------------------------------\n    CLONE\n----------------------------------------------------------- */\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance having methods, those methods would not be\n * cloned.\n *\n * For reference, this `typia.misc.clone()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call\n * {@link assertClone} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction clone<T>(input: T): Resolved<T>;\n\n/**\n * @internal\n */\nfunction clone(): never {\n  halt(\"clone\");\n}\nconst clonePure = /** @__PURE__ */ Object.assign<typeof clone, {}>(\n  clone,\n  /** @__PURE__ */ Namespace.misc.clone(\"clone\"),\n);\nexport { clonePure as clone };\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, cloned data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertClone<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, cloned data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertClone<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertClone(): never {\n  halt(\"assertClone\");\n}\nconst assertClonePure = /** @__PURE__ */ Object.assign<\n  typeof assertClone,\n  {},\n  {}\n>(\n  assertClone,\n  /** @__PURE__ */ Namespace.assert(\"misc.assertClone\"),\n  /** @__PURE__ */ Namespace.misc.clone(\"assertClone\"),\n);\nexport { assertClonePure as assertClone };\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isClone<T>(input: T): Resolved<T> | null;\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isClone<T>(input: unknown): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isClone(): never {\n  halt(\"isClone\");\n}\nconst isClonePure = /** @__PURE__ */ Object.assign<typeof isClone, {}, {}>(\n  isClone,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.misc.clone(\"isClone\"),\n);\nexport { isClonePure as isClone };\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance having methods,\n * those methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nfunction validateClone<T>(input: T): IValidation<Resolved<T>>;\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance having methods,\n * those methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nfunction validateClone<T>(input: unknown): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateClone(): never {\n  halt(\"validateClone\");\n}\nconst validateClonePure = /** @__PURE__ */ Object.assign<\n  typeof validateClone,\n  {},\n  {}\n>(\n  validateClone,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.misc.clone(\"validateClone\"),\n);\nexport { validateClonePure as validateClone };\n\n/* -----------------------------------------------------------\n    PRUNE\n----------------------------------------------------------- */\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.misc.prune()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would better to call one of below\n * functions instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction prune<T extends object>(input: T): void;\n\n/**\n * @internal\n */\nfunction prune(): never {\n  halt(\"prune\");\n}\nconst prunePure = /** @__PURE__ */ Object.assign<typeof prune, {}>(\n  prune,\n  /** @__PURE__ */ Namespace.misc.prune(\"prune\"),\n);\nexport { prunePure as prune };\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link assert} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, its every superfluous properties would be\n * removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPrune<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link assert} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise, there's\n * no problem on the `input` value, its every superfluous properties would be removed,\n * including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPrune<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertPrune(): unknown {\n  halt(\"assertPrune\");\n}\nconst assertPrunePure = /** @__PURE__ */ Object.assign<\n  typeof assertPrune,\n  {},\n  {}\n>(\n  assertPrune,\n  /** @__PURE__ */ Namespace.assert(\"misc.assertPrune\"),\n  /** @__PURE__ */ Namespace.misc.prune(\"assertPrune\"),\n);\nexport { assertPrunePure as assertPrune };\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link is} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPrune<T>(input: T): input is T;\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link is} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPrune<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nfunction isPrune(): never {\n  halt(\"isPrune\");\n}\nconst isPrunePure = /** @__PURE__ */ Object.assign<typeof isPrune, {}, {}>(\n  isPrune,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.misc.prune(\"isPrune\"),\n);\nexport { isPrunePure as isPrune };\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.misc.validatePrune()` is a combination function of {@link validate} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePrune<T>(input: T): IValidation<T>;\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.misc.validatePrune()` is a combination function of {@link validate} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePrune<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nfunction validatePrune<T>(): IValidation<T> {\n  halt(\"validatePrune\");\n}\n\nconst validatePrunePure = /** @__PURE__ */ Object.assign<\n  typeof validatePrune,\n  {},\n  {}\n>(\n  validatePrune,\n  /** @__PURE__ */ Namespace.misc.prune(\"validatePrune\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validatePrunePure as validatePrune };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createClone(): never;\n\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createClone<T>(): (input: T) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createClone(): never {\n  halt(\"createClone\");\n}\nconst createClonePure = /** @__PURE__ */ Object.assign<typeof createClone, {}>(\n  createClone,\n  clonePure,\n);\nexport { createClonePure as createClone };\n\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertClone(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertClone<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createAssertClone(): never {\n  halt(\"createAssertClone\");\n}\nconst createAssertClonePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertClone,\n  {}\n>(createAssertClone, assertClonePure);\nexport { createAssertClonePure as createAssertClone };\n\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsClone(): never;\n\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsClone<T>(): (input: unknown) => Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction createIsClone(): never {\n  halt(\"createIsClone\");\n}\nconst createIsClonePure = /** @__PURE__ */ Object.assign<\n  typeof createIsClone,\n  {}\n>(createIsClone, isClonePure);\nexport { createIsClonePure as createIsClone };\n\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateClone(): never;\n\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateClone<T>(): (input: unknown) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateClone(): never {\n  halt(\"createValidateClone\");\n}\nconst createValidateClonePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateClone,\n  {}\n>(createValidateClone, validateClonePure);\nexport { createValidateClonePure as createValidateClone };\n\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPrune(): never;\n\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPrune<T extends object>(): (input: T) => void;\n\n/**\n * @internal\n */\nfunction createPrune<T extends object>(): (input: T) => void {\n  halt(\"createPrune\");\n}\nconst createPrunePure = /** @__PURE__ */ Object.assign<typeof createPrune, {}>(\n  createPrune,\n  prunePure,\n);\nexport { createPrunePure as createPrune };\n\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPrune(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPrune<T extends object>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => T;\n\n/**\n * @internal\n */\nfunction createAssertPrune<T extends object>(): (input: T) => T {\n  halt(\"createAssertPrune\");\n}\nconst createAssertPrunePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertPrune,\n  {}\n>(createAssertPrune, assertPrunePure);\nexport { createAssertPrunePure as createAssertPrune };\n\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPrune(): never;\n\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPrune<T extends object>(): (input: T) => input is T;\n\n/**\n * @internal\n */\nfunction createIsPrune<T extends object>(): (input: T) => input is T {\n  halt(\"createIsPrune\");\n}\nconst createIsPrunePure = /** @__PURE__ */ Object.assign<\n  typeof createIsPrune,\n  {}\n>(createIsPrune, isPrunePure);\nexport { createIsPrunePure as createIsPrune };\n\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePrune(): never;\n\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePrune<T extends object>(): (input: T) => IValidation<T>;\n\n/**\n * @internal\n */\nfunction createValidatePrune<T extends object>(): (input: T) => IValidation<T> {\n  halt(\"createValidatePrune\");\n}\nconst createValidatePrunePure = /** @__PURE__ */ Object.assign<\n  typeof createValidatePrune,\n  {}\n>(createValidatePrune, validatePrunePure);\nexport { createValidatePrunePure as createValidatePrune };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.misc.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}