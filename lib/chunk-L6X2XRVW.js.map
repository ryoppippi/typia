{"version":3,"sources":["../src/programmers/json/JsonValidateParseProgrammer.ts"],"names":["ts","JsonValidateParseProgrammer","write","project","modulo","type","name","JsonMetadataFactory","analyze","getText","checker","context","factory","createArrowFunction","undefined","IdentifierFactory","parameter","TypeFactory","keyword","createTypeReferenceNode","getFullName","createBlock","StatementFactory","constant","ValidateProgrammer","options","functional","numeric","createCallExpression","createIdentifier","createReturnStatement","createAsExpression"],"mappings":";;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAWEC,8BAAAA;+BACFC,QACX,CAACC,YACD,CAACC,WACD,CAACC,MAAeC,SAAAA;AACdC,wBAAoBC,QAAQ,cAAcJ,OAAOK,QAAO,CAAA,EAAI,EAC1DN,QAAQO,SACRP,QAAQQ,OAAO,EACfN,IAAAA;AACF,WAAOL,GAAGY,QAAQC,oBAChBC,QACAA,QACA;MAACC,kBAAkBC,UAAU,SAASC,YAAYC,QAAQ,QAAA,CAAA;OAC1DlB,GAAGY,QAAQO,wBACT,qCACEb,QAAQW,YAAYG,YAAYjB,QAAQO,OAAO,EAAEL,IAAAA,CAAAA,IAC/C,GAENS,QACAd,GAAGY,QAAQS,YAAY;MACrBC,iBAAiBC,SACf,YACAC,mBAAmBtB,MAAM;QACvB,GAAGC;QACHsB,SAAS;UACP,GAAGtB,QAAQsB;UACXC,YAAY;UACZC,SAAS;QACX;MACF,CAAA,EAAGvB,MAAAA,EAAQ,KAAA,EAAOC,MAAMC,IAAAA,CAAAA;MAE1BgB,iBAAiBC,SACf,UACAvB,GAAGY,QAAQgB,qBACT5B,GAAGY,QAAQiB,iBAAiB,YAAA,GAC5Bf,QACA;QAACd,GAAGY,QAAQiB,iBAAiB,OAAA;OAAS,CAAA;MAG1C7B,GAAGY,QAAQkB,sBACT9B,GAAGY,QAAQmB,mBACT/B,GAAGY,QAAQgB,qBACT5B,GAAGY,QAAQiB,iBAAiB,UAAA,GAC5Bf,QACA;QAACd,GAAGY,QAAQiB,iBAAiB,QAAA;OAAU,GAEzC7B,GAAGY,QAAQO,wBAAwB,KAAA,CAAA,CAAA;KAGxC,CAAA;EAEL;AACJ,GApDiBlB,gCAAAA,8BAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { JsonMetadataFactory } from \"../../factories/JsonMetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\n\nexport namespace JsonValidateParseProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      JsonMetadataFactory.analyze(`typia.json.${modulo.getText()}`)(\n        project.checker,\n        project.context,\n      )(type);\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"string\"))],\n        ts.factory.createTypeReferenceNode(\n          `typia.IValidation<typia.Primitive<${\n            name ?? TypeFactory.getFullName(project.checker)(type)\n          }>>`,\n        ),\n        undefined,\n        ts.factory.createBlock([\n          StatementFactory.constant(\n            \"validate\",\n            ValidateProgrammer.write({\n              ...project,\n              options: {\n                ...project.options,\n                functional: false,\n                numeric: false,\n              },\n            })(modulo)(false)(type, name),\n          ),\n          StatementFactory.constant(\n            \"output\",\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"JSON.parse\"),\n              undefined,\n              [ts.factory.createIdentifier(\"input\")],\n            ),\n          ),\n          ts.factory.createReturnStatement(\n            ts.factory.createAsExpression(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"validate\"),\n                undefined,\n                [ts.factory.createIdentifier(\"output\")],\n              ),\n              ts.factory.createTypeReferenceNode(\"any\"),\n            ),\n          ),\n        ]),\n      );\n    };\n}\n"]}