{"version":3,"sources":["../src/factories/internal/metadata/iterate_metadata_constant.ts"],"names":["ts","iterate_metadata_constant","checker","options","meta","type","constant","filter","flag","getFlags","isLiteral","value","BigInt","negative","base10Value","ArrayUtil","take","constants","elem","MetadataConstant","create","values","add","MetadataConstantValue","tags","a","b","TypeFlags","BooleanLiteral","typeToString"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;AAUR,IAAMC,4BACX,wBAACC,YACD,CAACC,YACD,CAACC,MAAgBC,SAAAA;AACf,MAAI,CAACF,QAAQG,SAAU,QAAO;AAE9B,QAAMC,SAAS,wBAACC,UAAwBH,KAAKI,SAAQ,IAAKD,UAAU,GAArD;AACf,MAAIH,KAAKK,UAAS,GAAI;AACpB,UAAMC,QACJ,OAAON,KAAKM,UAAU,WAClBC,OAAO,GAAGP,KAAKM,MAAME,WAAW,MAAM,EAAA,GAAKR,KAAKM,MAAMG,WAAW,EAAE,IACnET,KAAKM;AACX,UAAML,WAA6BS,UAAUC,KAC3CZ,KAAKa,WACL,CAACC,SAASA,KAAKb,SAAS,OAAOM,OAC/B,MACEQ,iBAAiBC,OAAO;MACtBf,MAAM,OAAOM;MACbU,QAAQ,CAAA;IACV,CAAA,CAAA;AAEJN,cAAUO,IACRhB,SAASe,QACTE,sBAAsBH,OAAO;MAC3BT;MACAa,MAAM,CAAA;IACR,CAAA,GACA,CAACC,GAAGC,MAAMD,EAAEd,UAAUe,EAAEf,KAAK;AAE/B,WAAO;EACT,WAAWJ,OAAOP,GAAG2B,UAAUC,cAAc,GAAG;AAC9C,UAAMjB,QAAiBT,QAAQ2B,aAAaxB,IAAAA,MAAU;AACtD,UAAMC,WAA6BS,UAAUC,KAC3CZ,KAAKa,WACL,CAACC,SAASA,KAAKb,SAAS,WACxB,MACEc,iBAAiBC,OAAO;MACtBf,MAAM;MACNgB,QAAQ,CAAA;IACV,CAAA,CAAA;AAEJN,cAAUO,IACRhB,SAASe,QACTE,sBAAsBH,OAAO;MAC3BT;MACAa,MAAM,CAAA;IACR,CAAA,GACA,CAACC,GAAGC,MAAMD,EAAEd,UAAUe,EAAEf,KAAK;AAE/B,WAAO;EACT;AACA,SAAO;AACT,GAnDA","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataConstant } from \"../../../schemas/metadata/MetadataConstant\";\nimport { MetadataConstantValue } from \"../../../schemas/metadata/MetadataConstantValue\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataFactory } from \"../../MetadataFactory\";\n\nexport const iterate_metadata_constant =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (meta: Metadata, type: ts.Type): boolean => {\n    if (!options.constant) return false;\n\n    const filter = (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n    if (type.isLiteral()) {\n      const value: string | number | bigint =\n        typeof type.value === \"object\"\n          ? BigInt(`${type.value.negative ? \"-\" : \"\"}${type.value.base10Value}`)\n          : type.value;\n      const constant: MetadataConstant = ArrayUtil.take(\n        meta.constants,\n        (elem) => elem.type === typeof value,\n        () =>\n          MetadataConstant.create({\n            type: typeof value as \"number\",\n            values: [],\n          }),\n      );\n      ArrayUtil.add(\n        constant.values,\n        MetadataConstantValue.create({\n          value,\n          tags: [],\n        }),\n        (a, b) => a.value === b.value,\n      );\n      return true;\n    } else if (filter(ts.TypeFlags.BooleanLiteral)) {\n      const value: boolean = checker.typeToString(type) === \"true\";\n      const constant: MetadataConstant = ArrayUtil.take(\n        meta.constants,\n        (elem) => elem.type === \"boolean\",\n        () =>\n          MetadataConstant.create({\n            type: \"boolean\",\n            values: [],\n          }),\n      );\n      ArrayUtil.add(\n        constant.values,\n        MetadataConstantValue.create({\n          value,\n          tags: [],\n        }),\n        (a, b) => a.value === b.value,\n      );\n      return true;\n    }\n    return false;\n  };\n"]}