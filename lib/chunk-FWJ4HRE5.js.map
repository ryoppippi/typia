{"version":3,"sources":["../src/programmers/FeatureProgrammer.ts"],"names":["ts","FeatureProgrammer","write","project","config","importer","type","name","collection","meta","initializer","output","decoder","ValueFactory","INPUT","tracable","path","trace","source","from","postfix","functions","objects","generator","write_object_functions","unions","write_union_functions","arrays","tuples","added","addition","factory","createArrowFunction","undefined","parameterDeclarations","types","input","createBlock","filter","_","i","hasLocal","prefix","isBlock","statements","createReturnStatement","map","obj","StatementFactory","constant","index","TypeFactory","keyword","objector","joiner","createIdentifier","feature_object_entries","union","write_union","explorer","UnionExplorer","object","decode_array","combiner","rand","increment","toString","tail","IdentifierFactory","parameter","array","explore","arrow","value","start","decode_object","createCallExpression","useLocal","argumentsArray","prev","length","substring","createTrue","createFalse","props","push"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\nimport { ValueFactory } from \"../factories/ValueFactory\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../schemas/metadata/MetadataArray\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"./helpers/IExpressionEntry\";\nimport { UnionExplorer } from \"./helpers/UnionExplorer\";\nimport { feature_object_entries } from \"./internal/feature_object_entries\";\n\nexport namespace FeatureProgrammer {\n  /* -----------------------------------------------------------\n        PARAMETERS\n    ----------------------------------------------------------- */\n  export interface IConfig<Output extends ts.ConciseBody = ts.ConciseBody> {\n    types: IConfig.ITypes;\n\n    /**\n     * Prefix name of internal functions for specific types.\n     */\n    prefix: string;\n\n    /**\n     * Whether to archive access path or not.\n     */\n    path: boolean;\n\n    /**\n     * Whether to trace exception or not.\n     */\n    trace: boolean;\n\n    addition?: undefined | ((collection: MetadataCollection) => ts.Statement[]);\n\n    /**\n     * Initializer of metadata.\n     */\n    initializer: (\n      project: IProject,\n    ) => (\n      importer: FunctionImporter,\n    ) => (type: ts.Type) => [MetadataCollection, Metadata];\n\n    /**\n     * Decoder, station of every types.\n     */\n    decoder: () => Decoder<Metadata, Output>;\n\n    /**\n     * Object configurator.\n     */\n    objector: IConfig.IObjector<Output>;\n\n    /**\n     * Generator of functions for object types.\n     */\n    generator: IConfig.IGenerator;\n  }\n  export namespace IConfig {\n    export interface ITypes {\n      input: (type: ts.Type, name?: undefined | string) => ts.TypeNode;\n      output: (type: ts.Type, name?: undefined | string) => ts.TypeNode;\n    }\n\n    export interface IObjector<Output extends ts.ConciseBody = ts.ConciseBody> {\n      /**\n       * Type checker when union object type comes.\n       */\n      checker: () => Decoder<Metadata, ts.Expression>;\n\n      /**\n       * Decoder, function call expression generator of specific typed objects.\n       */\n      decoder: () => Decoder<MetadataObject, ts.Expression>;\n\n      /**\n       * Joiner of expressions from properties.\n       */\n      joiner(\n        input: ts.Expression,\n        entries: IExpressionEntry<Output>[],\n        parent: MetadataObject,\n      ): ts.ConciseBody;\n\n      /**\n       * Union type specificator.\n       *\n       * Expression of an algorithm specifying object type and calling\n       * the `decoder` function of the specified object type.\n       */\n      unionizer: Decoder<MetadataObject[], ts.Expression>;\n\n      /**\n       * Handler of union type specification failure.\n       *\n       * @param value Expression of input parameter\n       * @param expected Expected type name\n       * @param explore Exploration info\n       * @returns Statement of failure\n       */\n      failure(\n        value: ts.Expression,\n        expected: string,\n        explore?: undefined | IExplore,\n      ): ts.Statement;\n\n      /**\n       * Transformer of type checking expression by discrimination.\n       *\n       * When an object type has been specified by a discrimination without full\n       * iteration, the `unionizer` will decode the object instance after\n       * the last type checking.\n       *\n       * In such circumtance, you can transform the last type checking function.\n       *\n       * @param exp Current expression about type checking\n       * @returns Transformed expression\n       * @deprecated\n       */\n      is?: undefined | ((exp: ts.Expression) => ts.Expression);\n\n      /**\n       * Transformer of non-undefined type checking by discrimination.\n       *\n       * When specifying an union type of objects, `typia` tries to find\n       * descrimination way just by checking only one property type.\n       * If succeeded to find the discrimination way, `typia` will check the target\n       * property type and in the checking, non-undefined type checking would be\n       * done.\n       *\n       * In such process, you can transform the non-undefined type checking.\n       *\n       * @param exp\n       * @returns Transformed expression\n       * @deprecated\n       */\n      required?: undefined | ((exp: ts.Expression) => ts.Expression);\n\n      /**\n       * Conditon wrapper when unable to specify any object type.\n       *\n       * When failed to specify an object type through discrimination, full\n       * iteration type checking would be happend. In such circumstance, you\n       * can wrap the condition with additional function.\n       *\n       * @param condition Current condition\n       * @returns A function wrapped current condition\n       */\n      full?:\n        | undefined\n        | ((\n            condition: ts.Expression,\n          ) => (\n            input: ts.Expression,\n            expected: string,\n            explore: IExplore,\n          ) => ts.Expression);\n\n      /**\n       * Return type.\n       */\n      type?: undefined | ts.TypeNode;\n    }\n    export interface IGenerator {\n      objects?:\n        | undefined\n        | (() => (col: MetadataCollection) => ts.VariableStatement[]);\n      unions?:\n        | undefined\n        | (() => (col: MetadataCollection) => ts.VariableStatement[]);\n      arrays(): (col: MetadataCollection) => ts.VariableStatement[];\n      tuples(): (col: MetadataCollection) => ts.VariableStatement[];\n    }\n  }\n\n  export interface IExplore {\n    tracable: boolean;\n    source: \"top\" | \"function\";\n    from: \"top\" | \"array\" | \"object\";\n    postfix: string;\n    start?: undefined | number;\n  }\n\n  export interface Decoder<T, Output extends ts.ConciseBody = ts.ConciseBody> {\n    (input: ts.Expression, target: T, explore: IExplore): Output;\n  }\n\n  /* -----------------------------------------------------------\n        GENERATORS\n    ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) =>\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (type: ts.Type, name?: string) => {\n      const [collection, meta] = config.initializer(project)(importer)(type);\n\n      // ITERATE OVER ALL METADATA\n      const output: ts.ConciseBody = config.decoder()(\n        ValueFactory.INPUT(),\n        meta,\n        {\n          tracable: config.path || config.trace,\n          source: \"top\",\n          from: \"top\",\n          postfix: '\"\"',\n        },\n      );\n\n      // RETURNS THE OPTIMAL ARROW FUNCTION\n      const functions = {\n        objects: (\n          config.generator.objects?.() ??\n          write_object_functions(config)(importer)\n        )(collection),\n        unions: (config.generator.unions?.() ?? write_union_functions(config))(\n          collection,\n        ),\n        arrays: config.generator.arrays()(collection),\n        tuples: config.generator.tuples()(collection),\n      };\n      const added: ts.Statement[] = (config.addition ?? (() => []))(collection);\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        parameterDeclarations(config)(config.types.input(type, name))(\n          ValueFactory.INPUT(),\n        ),\n        config.types.output(type, name),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...added,\n            ...functions.objects.filter((_, i) =>\n              importer.hasLocal(`${config.prefix}o${i}`),\n            ),\n            ...functions.unions.filter((_, i) =>\n              importer.hasLocal(`${config.prefix}u${i}`),\n            ),\n            ...functions.arrays.filter((_, i) =>\n              importer.hasLocal(`${config.prefix}a${i}`),\n            ),\n            ...functions.tuples.filter((_, i) =>\n              importer.hasLocal(`${config.prefix}t${i}`),\n            ),\n            ...(ts.isBlock(output)\n              ? output.statements\n              : [ts.factory.createReturnStatement(output)]),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const write_object_functions =\n    (config: IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection) =>\n      collection\n        .objects()\n        .map((obj) =>\n          StatementFactory.constant(\n            `${config.prefix}o${obj.index}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              parameterDeclarations(config)(TypeFactory.keyword(\"any\"))(\n                ValueFactory.INPUT(),\n              ),\n              config.objector.type ?? TypeFactory.keyword(\"any\"),\n              undefined,\n              config.objector.joiner(\n                ts.factory.createIdentifier(\"input\"),\n                feature_object_entries(config)(importer)(obj)(\n                  ts.factory.createIdentifier(\"input\"),\n                ),\n                obj,\n              ),\n            ),\n          ),\n        );\n\n  export const write_union_functions =\n    (config: IConfig) => (collection: MetadataCollection) =>\n      collection\n        .unions()\n        .map((union, i) =>\n          StatementFactory.constant(\n            `${config.prefix}u${i}`,\n            write_union(config)(union),\n          ),\n        );\n\n  const write_union = (config: IConfig) => {\n    const explorer = UnionExplorer.object(config);\n    const input = ValueFactory.INPUT();\n\n    return (meta: MetadataObject[]) =>\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        parameterDeclarations(config)(TypeFactory.keyword(\"any\"))(\n          ValueFactory.INPUT(),\n        ),\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        explorer(input, meta, {\n          tracable: config.path || config.trace,\n          source: \"function\",\n          from: \"object\",\n          postfix: \"\",\n        }),\n      );\n  };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  export const decode_array =\n    (config: Pick<IConfig, \"trace\" | \"path\" | \"decoder\" | \"prefix\">) =>\n    (importer: FunctionImporter) =>\n    (\n      combiner: (\n        input: ts.Expression,\n        arrow: ts.ArrowFunction,\n      ) => ts.Expression,\n    ) => {\n      const rand: string = importer.increment().toString();\n      const tail =\n        config.path || config.trace\n          ? [\n              IdentifierFactory.parameter(\n                \"_index\" + rand,\n                TypeFactory.keyword(\"number\"),\n              ),\n            ]\n          : [];\n\n      return (\n        input: ts.Expression,\n        array: MetadataArray,\n        explore: IExplore,\n      ) => {\n        const arrow: ts.ArrowFunction = ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\"elem\", TypeFactory.keyword(\"any\")),\n            ...tail,\n          ],\n          undefined,\n          undefined,\n          config.decoder()(ValueFactory.INPUT(\"elem\"), array.type.value, {\n            tracable: explore.tracable,\n            source: explore.source,\n            from: \"array\",\n            postfix: index(explore.start ?? null)(explore.postfix)(rand),\n          }),\n        );\n        return combiner(input, arrow);\n      };\n    };\n\n  export const decode_object =\n    (config: Pick<IConfig, \"trace\" | \"path\" | \"prefix\">) =>\n    (importer: FunctionImporter) =>\n    (input: ts.Expression, obj: MetadataObject, explore: IExplore) =>\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(`${config.prefix}o${obj.index}`),\n        ),\n        undefined,\n        argumentsArray(config)(explore)(input),\n      );\n\n  /* -----------------------------------------------------------\n        UTILITIES FOR INTERNAL FUNCTIONS\n    ----------------------------------------------------------- */\n  export const index =\n    (start: number | null) => (prev: string) => (rand: string) => {\n      const tail: string =\n        start !== null\n          ? `\"[\" + (${start} + _index${rand}) + \"]\"`\n          : `\"[\" + _index${rand} + \"]\"`;\n      if (prev === \"\") return tail;\n      else if (prev[prev.length - 1] === `\"`)\n        return prev.substring(0, prev.length - 1) + tail.substring(1);\n      return prev + ` + ${tail}`;\n    };\n\n  export const argumentsArray =\n    (config: Pick<IConfig, \"path\" | \"trace\">) =>\n    (explore: FeatureProgrammer.IExplore) => {\n      const tail: ts.Expression[] =\n        config.path === false && config.trace === false\n          ? []\n          : config.path === true && config.trace === true\n            ? [\n                ts.factory.createIdentifier(\n                  explore.postfix ? `_path + ${explore.postfix}` : \"_path\",\n                ),\n                explore.source === \"function\"\n                  ? ts.factory.createIdentifier(\n                      `${explore.tracable} && _exceptionable`,\n                    )\n                  : explore.tracable\n                    ? ts.factory.createTrue()\n                    : ts.factory.createFalse(),\n              ]\n            : config.path === true\n              ? [\n                  ts.factory.createIdentifier(\n                    explore.postfix ? `_path + ${explore.postfix}` : \"_path\",\n                  ),\n                ]\n              : [\n                  explore.source === \"function\"\n                    ? ts.factory.createIdentifier(\n                        `${explore.tracable} && _exceptionable`,\n                      )\n                    : explore.tracable\n                      ? ts.factory.createTrue()\n                      : ts.factory.createFalse(),\n                ];\n      return (input: ts.Expression) => [input, ...tail];\n    };\n\n  export const parameterDeclarations =\n    (props: Pick<CheckerProgrammer.IConfig, \"path\" | \"trace\">) =>\n    (type: ts.TypeNode) => {\n      const tail: ts.ParameterDeclaration[] = [];\n      if (props.path)\n        tail.push(\n          IdentifierFactory.parameter(\"_path\", TypeFactory.keyword(\"string\")),\n        );\n      if (props.trace)\n        tail.push(\n          IdentifierFactory.parameter(\n            \"_exceptionable\",\n            TypeFactory.keyword(\"boolean\"),\n            ts.factory.createTrue(),\n          ),\n        );\n      return (input: ts.Identifier): ts.ParameterDeclaration[] => [\n        IdentifierFactory.parameter(input, type),\n        ...tail,\n      ];\n    };\n}\n"]}