{"version":3,"sources":["../src/programmers/internal/check_union_array_like.ts"],"names":["ts","check_union_array_like","accessor","props","parameters","input","origins","explore","targets","map","transform","length","factory","createArrowFunction","undefined","decoder","array","createIdentifier","top","statements","tupleList","filter","t","MetadataTuple","arrayList","MetadataArray","predicate","meta","createAsExpression","createArrayLiteralExpression","IdentifierFactory","parameter","MetadataArrayType","TypeFactory","keyword","createTypeReferenceNode","checker","element","tracable","postfix","iterate","init","from","stmt","createForOfStatement","createVariableDeclarationList","createVariableDeclaration","NodeFlags","Const","push","StatementFactory","constant","x","createIfStatement","createCallExpression","createReturnStatement","front","createStrictEquality","ExpressionFactory","number","size","isReturnStatement","empty","access","createElementAccessExpression","createNonNullExpression","createLessThan","success","failure","name","join","createBlock"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\n\nimport { CheckerProgrammer } from \"../CheckerProgrammer\";\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\n\n/**\n * @internal\n */\nexport const check_union_array_like =\n  <Origin, Category extends MetadataArray | MetadataTuple, Element>(\n    accessor: check_union_array_like.IAccessor<Origin, Category, Element>,\n  ) =>\n  (props: check_union_array_like.IProps<Category, Element>) =>\n  (parameters: ts.ParameterDeclaration[]) =>\n  (\n    input: ts.Expression,\n    origins: Origin[],\n    explore: FeatureProgrammer.IExplore,\n  ): ts.ArrowFunction => {\n    // ONLY ONE TYPE\n    const targets: Array<Category> = origins.map(accessor.transform);\n    if (targets.length === 1)\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        parameters,\n        undefined,\n        undefined,\n        props.decoder(accessor.array(input), targets[0]!, explore),\n      );\n\n    const array = ts.factory.createIdentifier(\"array\");\n    const top = ts.factory.createIdentifier(\"top\");\n\n    const statements: ts.Statement[] = [];\n    const tupleList: MetadataTuple[] = targets.filter(\n      (t) => t instanceof MetadataTuple,\n    ) as MetadataTuple[];\n    const arrayList: MetadataArray[] = targets.filter(\n      (t) => t instanceof MetadataArray,\n    ) as MetadataArray[];\n\n    const predicate = (meta: Category): ts.Expression =>\n      ts.factory.createAsExpression(\n        ts.factory.createArrayLiteralExpression(\n          [\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"top\",\n                  meta instanceof MetadataArrayType\n                    ? TypeFactory.keyword(\"any\")\n                    : ts.factory.createTypeReferenceNode(\"any[]\"),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              props.checker(\n                ts.factory.createIdentifier(\"top\"),\n                accessor.element(meta),\n                {\n                  ...explore,\n                  tracable: false,\n                  postfix: meta instanceof MetadataArrayType ? `\"[0]\"` : \"\",\n                },\n                array,\n              ),\n            ),\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"entire\",\n                  ts.factory.createTypeReferenceNode(\"any[]\"),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              props.decoder(ts.factory.createIdentifier(\"entire\"), meta, {\n                ...explore,\n                tracable: true,\n              }),\n            ),\n          ],\n          true,\n        ),\n        ts.factory.createTypeReferenceNode(\"const\"),\n      );\n    const iterate =\n      (init: string) =>\n      (from: ts.Expression) =>\n      (stmt: ts.Statement): ts.ForOfStatement =>\n        ts.factory.createForOfStatement(\n          undefined,\n          ts.factory.createVariableDeclarationList(\n            [ts.factory.createVariableDeclaration(init)],\n            ts.NodeFlags.Const,\n          ),\n          from,\n          stmt,\n        );\n\n    if (tupleList.length)\n      statements.push(\n        StatementFactory.constant(\"array\", accessor.array(input)),\n        StatementFactory.constant(\n          \"tuplePredicators\",\n          ts.factory.createArrayLiteralExpression(\n            tupleList.map((x) => predicate(x as Category)),\n            true,\n          ),\n        ),\n        iterate(\"pred\")(ts.factory.createIdentifier(\"tuplePredicators\"))(\n          ts.factory.createIfStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"pred[0]\"),\n              undefined,\n              [array],\n            ),\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(`pred[1]`),\n                undefined,\n                [array],\n              ),\n            ),\n          ),\n        ),\n      );\n    if (arrayList.length) {\n      if (tupleList.length === 0)\n        statements.push(\n          StatementFactory.constant(\"array\", accessor.array(input)),\n        );\n      statements.push(\n        StatementFactory.constant(\"top\", accessor.front(input)),\n        ts.factory.createIfStatement(\n          ts.factory.createStrictEquality(\n            ExpressionFactory.number(0),\n            accessor.size(input),\n          ),\n          ts.isReturnStatement(props.empty)\n            ? props.empty\n            : ts.factory.createReturnStatement(props.empty),\n        ),\n        StatementFactory.constant(\n          \"arrayPredicators\",\n          ts.factory.createArrayLiteralExpression(\n            arrayList.map((x) => predicate(x as Category)),\n            true,\n          ),\n        ),\n        StatementFactory.constant(\n          \"passed\",\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(\n              ts.factory.createIdentifier(\"arrayPredicators\"),\n            )(\"filter\"),\n            undefined,\n            [\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [IdentifierFactory.parameter(\"pred\")],\n                undefined,\n                undefined,\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"pred[0]\"),\n                  undefined,\n                  [top],\n                ),\n              ),\n            ],\n          ),\n        ),\n        ts.factory.createIfStatement(\n          ts.factory.createStrictEquality(\n            ExpressionFactory.number(1),\n            ts.factory.createIdentifier(\"passed.length\"),\n          ),\n          ts.factory.createReturnStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createElementAccessExpression(\n                ts.factory.createNonNullExpression(\n                  ts.factory.createIdentifier(\"passed[0]\"),\n                ),\n                1,\n              ),\n              undefined,\n              [array],\n            ),\n          ),\n          ts.factory.createIfStatement(\n            ts.factory.createLessThan(\n              ExpressionFactory.number(1),\n              ts.factory.createIdentifier(\"passed.length\"),\n            ),\n            iterate(\"pred\")(ts.factory.createIdentifier(\"passed\"))(\n              ts.factory.createIfStatement(\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(array)(\"every\"),\n                  undefined,\n                  [\n                    ts.factory.createArrowFunction(\n                      undefined,\n                      undefined,\n                      [\n                        IdentifierFactory.parameter(\n                          \"value\",\n                          TypeFactory.keyword(\"any\"),\n                        ),\n                      ],\n                      undefined,\n                      undefined,\n                      ts.factory.createStrictEquality(\n                        props.success,\n                        ts.factory.createCallExpression(\n                          ts.factory.createIdentifier(\"pred[0]\"),\n                          undefined,\n                          [ts.factory.createIdentifier(\"value\")],\n                        ),\n                      ),\n                    ),\n                  ],\n                ),\n                ts.factory.createReturnStatement(\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(`pred[1]`),\n                    undefined,\n                    [ts.factory.createIdentifier(\"array\")],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      );\n    }\n    statements.push(\n      props.failure(\n        input,\n        `(${targets\n          .map((t) => accessor.name(t, accessor.element(t)))\n          .join(\" | \")})`,\n        explore,\n      ),\n    );\n    return ts.factory.createArrowFunction(\n      undefined,\n      undefined,\n      parameters,\n      undefined,\n      undefined,\n      ts.factory.createBlock(statements, true),\n    );\n  };\n\n/**\n * @internal\n */\nexport namespace check_union_array_like {\n  export interface IProps<\n    Category extends MetadataArray | MetadataTuple,\n    Element,\n  > {\n    checker(\n      front: ts.Expression,\n      target: Element,\n      explore: FeatureProgrammer.IExplore,\n      container: ts.Expression,\n    ): ts.Expression;\n    decoder: UnionExplorer.Decoder<Category>;\n    empty: ts.ReturnStatement | ts.Expression;\n    success: ts.Expression;\n    failure(\n      input: ts.Expression,\n      expected: string,\n      explore: CheckerProgrammer.IExplore,\n    ): ts.Statement;\n  }\n\n  export interface IAccessor<\n    Origin,\n    Category extends MetadataArray | MetadataTuple,\n    Element,\n  > {\n    transform(origin: Origin): Category;\n    element(meta: Category): Element;\n    name(meta: Category, elem: Element): string;\n    front(input: ts.Expression): ts.Expression;\n    array(input: ts.Expression): ts.Expression;\n    size(input: ts.Expression): ts.Expression;\n  }\n}\n"]}