{"version":3,"sources":["../src/programmers/AssertProgrammer.ts"],"names":["ts","AssertProgrammer","write","project","modulo","props","type","name","init","equals","guard","importer","FunctionImporter","getText","is","IsProgrammer","TypeFactory","getFullName","checker","assert","CheckerProgrammer","prefix","path","trace","numeric","OptionPredicator","options","atomist","explore","entry","input","expression","conditions","length","map","cond","factory","createLogicalOr","create_guard_call","from","createTrue","createIdentifier","postfix","expected","set","s","reduce","a","b","createLogicalAnd","x","y","combiner","joiner","success","addition","declare","createArrowFunction","undefined","IdentifierFactory","parameter","keyword","Guardian","createTypePredicateNode","createToken","SyntaxKind","AssertsKeyword","createTypeReferenceNode","createBlock","StatementFactory","constant","createIfStatement","createStrictEquality","createFalse","createCallExpression","createExpressionStatement","createStringLiteral","createReturnStatement","tracable","configure","object","assert_object","logic","binaries","binary","combined","source","check_object","positive","superfluous","value","createAdd","use","halt","expr","array","arrow","access","failure","full","condition","exceptionable","createObjectLiteralExpression","createPropertyAssignment","identifier","QuestionToken","createFunctionTypeNode","createParameterDeclaration","createImportTypeNode","createLiteralTypeNode","createQualifiedName"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { check_object } from \"./internal/check_object\";\n\nexport namespace AssertProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (props: boolean | { equals: boolean; guard: boolean }) =>\n    (type: ts.Type, name?: string, init?: ts.Expression) => {\n      // TO SUPPORT LEGACY FEATURE\n      if (typeof props === \"boolean\") props = { equals: props, guard: false };\n\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const is: ts.ArrowFunction = IsProgrammer.write(project)(modulo, true)(\n        props.equals,\n      )(type, name ?? TypeFactory.getFullName(project.checker)(type));\n      const assert: ts.ArrowFunction = CheckerProgrammer.write(project)({\n        prefix: \"$a\",\n        path: true,\n        trace: true,\n        numeric: OptionPredicator.numeric(project.options),\n        equals: props.equals,\n        atomist: (explore) => (entry) => (input) =>\n          [\n            ...(entry.expression ? [entry.expression] : []),\n            ...(entry.conditions.length === 0\n              ? []\n              : entry.conditions.length === 1\n                ? entry.conditions[0]!.map((cond) =>\n                    ts.factory.createLogicalOr(\n                      cond.expression,\n                      create_guard_call(importer)(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        cond.expected,\n                        input,\n                      ),\n                    ),\n                  )\n                : [\n                    ts.factory.createLogicalOr(\n                      entry.conditions\n                        .map((set) =>\n                          set\n                            .map((s) => s.expression)\n                            .reduce((a, b) =>\n                              ts.factory.createLogicalAnd(a, b),\n                            ),\n                        )\n                        .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n                      create_guard_call(importer)(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        entry.expected,\n                        input,\n                      ),\n                    ),\n                  ]),\n          ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n        combiner: combiner(props.equals)(project)(importer),\n        joiner: joiner(props.equals)(project)(importer),\n        success: ts.factory.createTrue(),\n        addition: () => importer.declare(modulo),\n      })(importer)(type, name);\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\")),\n          Guardian.parameter(init),\n        ],\n        props.guard\n          ? ts.factory.createTypePredicateNode(\n              ts.factory.createToken(ts.SyntaxKind.AssertsKeyword),\n              ts.factory.createIdentifier(\"input\"),\n              ts.factory.createTypeReferenceNode(\n                name ?? TypeFactory.getFullName(project.checker)(type),\n              ),\n            )\n          : ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            StatementFactory.constant(\"__is\", is),\n            ts.factory.createIfStatement(\n              ts.factory.createStrictEquality(\n                ts.factory.createFalse(),\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"__is\"),\n                  undefined,\n                  [ts.factory.createIdentifier(\"input\")],\n                ),\n              ),\n              ts.factory.createExpressionStatement(\n                ts.factory.createCallExpression(assert, undefined, [\n                  ts.factory.createIdentifier(\"input\"),\n                  ts.factory.createStringLiteral(\"$input\"),\n                  ts.factory.createTrue(),\n                ]),\n              ),\n              undefined,\n            ),\n            ...(props.guard === false\n              ? [\n                  ts.factory.createReturnStatement(\n                    ts.factory.createIdentifier(`input`),\n                  ),\n                ]\n              : []),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const combiner =\n    (equals: boolean) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig.Combiner =>\n    (explore: CheckerProgrammer.IExplore) => {\n      if (explore.tracable === false)\n        return IsProgrammer.configure({\n          object: assert_object(equals)(project)(importer),\n          numeric: true,\n        })(project)(importer).combiner(explore);\n\n      const path: string = explore.postfix\n        ? `_path + ${explore.postfix}`\n        : \"_path\";\n      return (logic) => (input, binaries, expected) =>\n        logic === \"and\"\n          ? binaries\n              .map((binary) =>\n                binary.combined\n                  ? binary.expression\n                  : ts.factory.createLogicalOr(\n                      binary.expression,\n                      create_guard_call(importer)(\n                        explore.source === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(ts.factory.createIdentifier(path), expected, input),\n                    ),\n              )\n              .reduce(ts.factory.createLogicalAnd)\n          : ts.factory.createLogicalOr(\n              binaries\n                .map((binary) => binary.expression)\n                .reduce(ts.factory.createLogicalOr),\n              create_guard_call(importer)(\n                explore.source === \"top\"\n                  ? ts.factory.createTrue()\n                  : ts.factory.createIdentifier(\"_exceptionable\"),\n              )(ts.factory.createIdentifier(path), expected, input),\n            );\n      // : (() => {\n      //       const addicted = binaries.slice();\n      //       if (\n      //           addicted[addicted.length - 1]!.combined === false\n      //       ) {\n      //           addicted.push({\n      //               combined: true,\n      //               expression: create_guard_call(importer)(\n      //                   explore.source === \"top\"\n      //                       ? ts.factory.createTrue()\n      //                       : ts.factory.createIdentifier(\n      //                             \"_exceptionable\",\n      //                         ),\n      //               )(\n      //                   ts.factory.createIdentifier(path),\n      //                   expected,\n      //                   input,\n      //               ),\n      //           });\n      //       }\n      //       return addicted\n      //           .map((b) => b.expression)\n      //           .reduce(ts.factory.createLogicalOr);\n      //   })();\n    };\n\n  const assert_object =\n    (equals: boolean) => (project: IProject) => (importer: FunctionImporter) =>\n      check_object({\n        equals,\n        assert: true,\n        undefined: true,\n        reduce: ts.factory.createLogicalAnd,\n        positive: ts.factory.createTrue(),\n        superfluous: (value) =>\n          create_guard_call(importer)()(\n            ts.factory.createAdd(\n              ts.factory.createIdentifier(\"_path\"),\n              ts.factory.createCallExpression(importer.use(\"join\"), undefined, [\n                ts.factory.createIdentifier(\"key\"),\n              ]),\n            ),\n            \"undefined\",\n            value,\n          ),\n        halt: (expr) =>\n          ts.factory.createLogicalOr(\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createIdentifier(\"_exceptionable\"),\n            ),\n            expr,\n          ),\n      })(project)(importer);\n\n  const joiner =\n    (equals: boolean) =>\n    (project: IProject) =>\n    (importer: FunctionImporter): CheckerProgrammer.IConfig.IJoiner => ({\n      object: assert_object(equals)(project)(importer),\n      array: (input, arrow) =>\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"every\"),\n          undefined,\n          [arrow],\n        ),\n      failure: (value, expected, explore) =>\n        create_guard_call(importer)(\n          explore?.from === \"top\"\n            ? ts.factory.createTrue()\n            : ts.factory.createIdentifier(\"_exceptionable\"),\n        )(\n          ts.factory.createIdentifier(\n            explore?.postfix ? `_path + ${explore.postfix}` : \"_path\",\n          ),\n          expected,\n          value,\n        ),\n      full: equals\n        ? undefined\n        : (condition) => (input, expected, explore) =>\n            ts.factory.createLogicalOr(\n              condition,\n              create_guard_call(importer)(\n                explore.from === \"top\"\n                  ? ts.factory.createTrue()\n                  : ts.factory.createIdentifier(\"_exceptionable\"),\n              )(ts.factory.createIdentifier(\"_path\"), expected, input),\n            ),\n    });\n\n  const create_guard_call =\n    (importer: FunctionImporter) =>\n    (exceptionable?: ts.Expression) =>\n    (\n      path: ts.Expression,\n      expected: string,\n      value: ts.Expression,\n    ): ts.Expression =>\n      ts.factory.createCallExpression(importer.use(\"guard\"), undefined, [\n        exceptionable ?? ts.factory.createIdentifier(\"_exceptionable\"),\n        ts.factory.createObjectLiteralExpression(\n          [\n            ts.factory.createPropertyAssignment(\"path\", path),\n            ts.factory.createPropertyAssignment(\n              \"expected\",\n              ts.factory.createStringLiteral(expected),\n            ),\n            ts.factory.createPropertyAssignment(\"value\", value),\n          ],\n          true,\n        ),\n        Guardian.identifier(),\n      ]);\n\n  export namespace Guardian {\n    export const identifier = () => ts.factory.createIdentifier(\"errorFactory\");\n    export const parameter = (init: ts.Expression | undefined) =>\n      IdentifierFactory.parameter(\n        \"errorFactory\",\n        type(),\n        init ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n      );\n    export const type = () =>\n      ts.factory.createFunctionTypeNode(\n        undefined,\n        [\n          ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            ts.factory.createIdentifier(\"p\"),\n            undefined,\n            ts.factory.createImportTypeNode(\n              ts.factory.createLiteralTypeNode(\n                ts.factory.createStringLiteral(\"typia\"),\n              ),\n              undefined,\n              ts.factory.createQualifiedName(\n                ts.factory.createIdentifier(\"TypeGuardError\"),\n                ts.factory.createIdentifier(\"IProps\"),\n              ),\n              undefined,\n              false,\n            ),\n            undefined,\n          ),\n        ],\n        ts.factory.createTypeReferenceNode(\n          ts.factory.createIdentifier(\"Error\"),\n          undefined,\n        ),\n      );\n  }\n}\n"]}