{"version":3,"sources":["../src/misc.ts"],"sourcesContent":["/* ===========================================================\n    MISCELLAENOUS\n      - LITERALS\n      - CLONE\n      - PRUNE\n      - FACTORY FUNCTIONS\n==============================================================\n    LITERALS\n----------------------------------------------------------- */\nimport * as Namespace from \"./functional/Namespace\";\n\nimport { Atomic } from \"./typings/Atomic\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<\"A\" | \"B\" | 1>; // [\"A\", \"B\", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type's members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function literals(): never;\n\n/**\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<\"A\" | \"B\" | 1>; // [\"A\", \"B\", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type's members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function literals<T extends Atomic.Type | null>(): T[];\n\n/**\n * @internal\n */\nexport function literals(): never {\n  halt(\"literals\");\n}\n\n/* -----------------------------------------------------------\n    CLONE\n----------------------------------------------------------- */\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance having methods, those methods would not be\n * cloned.\n *\n * For reference, this `typia.misc.clone()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call\n * {@link assertClone} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction clone<T>(input: T): Resolved<T>;\n\n/**\n * @internal\n */\nfunction clone(): never {\n  halt(\"clone\");\n}\nconst clonePure = /** @__PURE__ */ Object.assign<typeof clone, {}>(\n  clone,\n  /** @__PURE__ */ Namespace.misc.clone(\"clone\"),\n);\nexport { clonePure as clone };\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, cloned data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertClone<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, cloned data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertClone<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertClone(): never {\n  halt(\"assertClone\");\n}\nconst assertClonePure = /** @__PURE__ */ Object.assign<\n  typeof assertClone,\n  {},\n  {}\n>(\n  assertClone,\n  /** @__PURE__ */ Namespace.assert(\"misc.assertClone\"),\n  /** @__PURE__ */ Namespace.misc.clone(\"assertClone\"),\n);\nexport { assertClonePure as assertClone };\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isClone<T>(input: T): Resolved<T> | null;\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance having methods, those\n * methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isClone<T>(input: unknown): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isClone(): never {\n  halt(\"isClone\");\n}\nconst isClonePure = /** @__PURE__ */ Object.assign<typeof isClone, {}, {}>(\n  isClone,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.misc.clone(\"isClone\"),\n);\nexport { isClonePure as isClone };\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance having methods,\n * those methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nfunction validateClone<T>(input: T): IValidation<Resolved<T>>;\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance having methods,\n * those methods would not be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nfunction validateClone<T>(input: unknown): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateClone(): never {\n  halt(\"validateClone\");\n}\nconst validateClonePure = /** @__PURE__ */ Object.assign<\n  typeof validateClone,\n  {},\n  {}\n>(\n  validateClone,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.misc.clone(\"validateClone\"),\n);\nexport { validateClonePure as validateClone };\n\n/* -----------------------------------------------------------\n    PRUNE\n----------------------------------------------------------- */\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.misc.prune()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would better to call one of below\n * functions instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction prune<T extends object>(input: T): void;\n\n/**\n * @internal\n */\nfunction prune(): never {\n  halt(\"prune\");\n}\nconst prunePure = /** @__PURE__ */ Object.assign<typeof prune, {}>(\n  prune,\n  /** @__PURE__ */ Namespace.misc.prune(\"prune\"),\n);\nexport { prunePure as prune };\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link assert} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise,\n * there's no problem on the `input` value, its every superfluous properties would be\n * removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPrune<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link assert} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError} or custom error generated by *errorFactory*. Otherwise, there's\n * no problem on the `input` value, its every superfluous properties would be removed,\n * including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPrune<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): T;\n\n/**\n * @internal\n */\nfunction assertPrune(): unknown {\n  halt(\"assertPrune\");\n}\nconst assertPrunePure = /** @__PURE__ */ Object.assign<\n  typeof assertPrune,\n  {},\n  {}\n>(\n  assertPrune,\n  /** @__PURE__ */ Namespace.assert(\"misc.assertPrune\"),\n  /** @__PURE__ */ Namespace.misc.prune(\"assertPrune\"),\n);\nexport { assertPrunePure as assertPrune };\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link is} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPrune<T>(input: T): input is T;\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.misc.assertPrune()` is a combination function of {@link is} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPrune<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nfunction isPrune(): never {\n  halt(\"isPrune\");\n}\nconst isPrunePure = /** @__PURE__ */ Object.assign<typeof isPrune, {}, {}>(\n  isPrune,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.misc.prune(\"isPrune\"),\n);\nexport { isPrunePure as isPrune };\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.misc.validatePrune()` is a combination function of {@link validate} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePrune<T>(input: T): IValidation<T>;\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.misc.validatePrune()` is a combination function of {@link validate} and\n * {@link prune}. Therefore, it removes every superfluous properties from the `input`\n * object including nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePrune<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nfunction validatePrune<T>(): IValidation<T> {\n  halt(\"validatePrune\");\n}\n\nconst validatePrunePure = /** @__PURE__ */ Object.assign<\n  typeof validatePrune,\n  {},\n  {}\n>(\n  validatePrune,\n  /** @__PURE__ */ Namespace.misc.prune(\"validatePrune\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validatePrunePure as validatePrune };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createClone(): never;\n\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createClone<T>(): (input: T) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createClone(): never {\n  halt(\"createClone\");\n}\nconst createClonePure = /** @__PURE__ */ Object.assign<typeof createClone, {}>(\n  createClone,\n  clonePure,\n);\nexport { createClonePure as createClone };\n\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertClone(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertClone<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: unknown) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createAssertClone(): never {\n  halt(\"createAssertClone\");\n}\nconst createAssertClonePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertClone,\n  {}\n>(createAssertClone, assertClonePure);\nexport { createAssertClonePure as createAssertClone };\n\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsClone(): never;\n\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsClone<T>(): (input: unknown) => Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction createIsClone(): never {\n  halt(\"createIsClone\");\n}\nconst createIsClonePure = /** @__PURE__ */ Object.assign<\n  typeof createIsClone,\n  {}\n>(createIsClone, isClonePure);\nexport { createIsClonePure as createIsClone };\n\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateClone(): never;\n\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateClone<T>(): (input: unknown) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateClone(): never {\n  halt(\"createValidateClone\");\n}\nconst createValidateClonePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateClone,\n  {}\n>(createValidateClone, validateClonePure);\nexport { createValidateClonePure as createValidateClone };\n\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPrune(): never;\n\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPrune<T extends object>(): (input: T) => void;\n\n/**\n * @internal\n */\nfunction createPrune<T extends object>(): (input: T) => void {\n  halt(\"createPrune\");\n}\nconst createPrunePure = /** @__PURE__ */ Object.assign<typeof createPrune, {}>(\n  createPrune,\n  prunePure,\n);\nexport { createPrunePure as createPrune };\n\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPrune(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPrune<T extends object>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => T;\n\n/**\n * @internal\n */\nfunction createAssertPrune<T extends object>(): (input: T) => T {\n  halt(\"createAssertPrune\");\n}\nconst createAssertPrunePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertPrune,\n  {}\n>(createAssertPrune, assertPrunePure);\nexport { createAssertPrunePure as createAssertPrune };\n\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPrune(): never;\n\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPrune<T extends object>(): (input: T) => input is T;\n\n/**\n * @internal\n */\nfunction createIsPrune<T extends object>(): (input: T) => input is T {\n  halt(\"createIsPrune\");\n}\nconst createIsPrunePure = /** @__PURE__ */ Object.assign<\n  typeof createIsPrune,\n  {}\n>(createIsPrune, isPrunePure);\nexport { createIsPrunePure as createIsPrune };\n\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePrune(): never;\n\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePrune<T extends object>(): (input: T) => IValidation<T>;\n\n/**\n * @internal\n */\nfunction createValidatePrune<T extends object>(): (input: T) => IValidation<T> {\n  halt(\"createValidatePrune\");\n}\nconst createValidatePrunePure = /** @__PURE__ */ Object.assign<\n  typeof createValidatePrune,\n  {}\n>(createValidatePrune, validatePrunePure);\nexport { createValidatePrunePure as createValidatePrune };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.misc.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAAA,gBAAA;SAAAA,eAAA;;;;;;;;;;;;;;;;;;;AAsDO,SAASC,WAAAA;AACdC,OAAK,UAAA;AACP;AAFgBD;AA8BhB,SAASE,QAAAA;AACPD,OAAK,OAAA;AACP;AAFSC;AAGT,IAAMC,YAA6BC,uBAAOC,OACxCH,OACiBI,gBAAUC,aAAKL,MAAM,OAAA,CAAA;AAqDxC,SAASM,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAGT,IAAME,kBAAmCC,uBAAOC,OAK9CJ,aACiBK,gBAAUC,OAAO,kBAAA,GACjBD,gBAAUE,aAAKC,MAAM,aAAA,CAAA;AA6CxC,SAASC,UAAAA;AACPC,OAAK,SAAA;AACP;AAFSD;AAGT,IAAME,cAA+BC,uBAAOC,OAC1CJ,SACiBK,gBAAUC,GAAE,GACZD,gBAAUE,aAAKC,MAAM,SAAA,CAAA;AA2CxC,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAGT,IAAME,oBAAqCC,uBAAOC,OAKhDJ,eACiBK,gBAAUC,SAAQ,GAClBD,gBAAUE,aAAKC,MAAM,eAAA,CAAA;AAiCxC,SAASC,QAAAA;AACPC,OAAK,OAAA;AACP;AAFSD;AAGT,IAAME,YAA6BC,uBAAOC,OACxCJ,OACiBK,gBAAUC,aAAKN,MAAM,OAAA,CAAA;AAqDxC,SAASO,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAGT,IAAME,kBAAmCC,uBAAOC,OAK9CJ,aACiBK,gBAAUC,OAAO,kBAAA,GACjBD,gBAAUE,aAAKC,MAAM,aAAA,CAAA;AA6CxC,SAASC,UAAAA;AACPC,OAAK,SAAA;AACP;AAFSD;AAGT,IAAME,cAA+BC,uBAAOC,OAC1CJ,SACiBK,gBAAUC,GAAE,GACZD,gBAAUE,aAAKC,MAAM,SAAA,CAAA;AA+CxC,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAIT,IAAME,oBAAqCC,uBAAOC,OAKhDJ,eACiBK,gBAAUC,aAAKC,MAAM,eAAA,GACrBF,gBAAUG,SAAQ,CAAA;AA+BrC,SAASC,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAGT,IAAME,kBAAmCC,uBAAOC,OAC9CJ,aACAK,SAAAA;AAkCF,SAASC,oBAAAA;AACPC,OAAK,mBAAA;AACP;AAFSD;AAGT,IAAME,wBAAyCC,uBAAOC,OAGpDJ,mBAAmBK,eAAAA;AA2BrB,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAGT,IAAME,oBAAqCC,uBAAOC,OAGhDJ,eAAeK,WAAAA;AA2BjB,SAASC,sBAAAA;AACPC,OAAK,qBAAA;AACP;AAFSD;AAGT,IAAME,0BAA2CC,uBAAOC,OAGtDJ,qBAAqBK,iBAAAA;AA2BvB,SAASC,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAGT,IAAME,kBAAmCC,uBAAOC,OAC9CJ,aACAK,SAAAA;AAkCF,SAASC,oBAAAA;AACPC,OAAK,mBAAA;AACP;AAFSD;AAGT,IAAME,wBAAyCC,uBAAOC,OAGpDJ,mBAAmBK,eAAAA;AA2BrB,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAGT,IAAME,oBAAqCC,uBAAOC,OAGhDJ,eAAeK,WAAAA;AA2BjB,SAASC,sBAAAA;AACPC,OAAK,qBAAA;AACP;AAFSD;AAGT,IAAME,0BAA2CC,uBAAOC,OAGtDJ,qBAAqBK,iBAAAA;AAMvB,SAASC,KAAKC,MAAY;AACxB,QAAM,IAAIC,MACR,uBAAuBD,IAAAA,2FAA+F;AAE1H;AAJSD;","names":["misc_exports","literals","halt","clone","clonePure","Object","assign","Namespace","misc","assertClone","halt","assertClonePure","Object","assign","Namespace","assert","misc","clone","isClone","halt","isClonePure","Object","assign","Namespace","is","misc","clone","validateClone","halt","validateClonePure","Object","assign","Namespace","validate","misc","clone","prune","halt","prunePure","Object","assign","Namespace","misc","assertPrune","halt","assertPrunePure","Object","assign","Namespace","assert","misc","prune","isPrune","halt","isPrunePure","Object","assign","Namespace","is","misc","prune","validatePrune","halt","validatePrunePure","Object","assign","Namespace","misc","prune","validate","createClone","halt","createClonePure","Object","assign","clonePure","createAssertClone","halt","createAssertClonePure","Object","assign","assertClonePure","createIsClone","halt","createIsClonePure","Object","assign","isClonePure","createValidateClone","halt","createValidateClonePure","Object","assign","validateClonePure","createPrune","halt","createPrunePure","Object","assign","prunePure","createAssertPrune","halt","createAssertPrunePure","Object","assign","assertPrunePure","createIsPrune","halt","createIsPrunePure","Object","assign","isPrunePure","createValidatePrune","halt","createValidatePrunePure","Object","assign","validatePrunePure","halt","name","Error"]}