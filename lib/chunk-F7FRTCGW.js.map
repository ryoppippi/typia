{"version":3,"sources":["../src/programmers/helpers/RandomJoiner.ts"],"names":["ts","RandomJoiner","array","coalesce","decoder","explore","length","item","generator","factory","createCallExpression","undefined","createArrowFunction","recursive","createConditionalExpression","createGreaterThanEquals","ExpressionFactory","number","createIdentifier","createArrayLiteralExpression","tuple","elements","map","elem","rest","object","obj","properties","regular","filter","p","key","isSoleLiteral","dynamic","literal","createObjectLiteralExpression","str","getSoleLiteral","createPropertyAssignment","Escaper","variable","createStringLiteral","value","createExpressionStatement","dynamicProperty","createBlock","StatementFactory","constant","createAsExpression","TypeFactory","keyword","createIfStatement","createReturnStatement","createBinaryExpression","createElementAccessExpression","createToken","SyntaxKind","EqualsToken"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nexport namespace RandomJoiner {\n  export type Decoder = (meta: Metadata) => ts.Expression;\n\n  export const array =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (explore: IExplore) =>\n    (length: ts.Expression | undefined) =>\n    (item: Metadata): ts.Expression => {\n      const generator: ts.Expression = ts.factory.createCallExpression(\n        coalesce(\"array\"),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            undefined,\n            decoder(item),\n          ),\n          ...(length ? [length] : []),\n        ],\n      );\n      if (explore.recursive === false) return generator;\n      return ts.factory.createConditionalExpression(\n        ts.factory.createGreaterThanEquals(\n          ExpressionFactory.number(5),\n          ts.factory.createIdentifier(\"_depth\"),\n        ),\n        undefined,\n        generator,\n        undefined,\n        ts.factory.createArrayLiteralExpression([]),\n      );\n    };\n\n  export const tuple = (decoder: Decoder) => (elements: Metadata[]) =>\n    ts.factory.createArrayLiteralExpression(\n      elements.map((elem) => decoder(elem.rest ?? elem)),\n      true,\n    );\n\n  export const object =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (obj: MetadataObject): ts.ConciseBody => {\n      if (obj.properties.length === 0) return ts.factory.createIdentifier(\"{}\");\n\n      // LIST UP PROPERTIES\n      const regular = obj.properties.filter((p) => p.key.isSoleLiteral());\n      const dynamic = obj.properties.filter((p) => !p.key.isSoleLiteral());\n\n      // REGULAR OBJECT\n      const literal: ts.ObjectLiteralExpression =\n        ts.factory.createObjectLiteralExpression(\n          regular.map((p) => {\n            const str: string = p.key.getSoleLiteral()!;\n            return ts.factory.createPropertyAssignment(\n              Escaper.variable(str) ? str : ts.factory.createStringLiteral(str),\n              decoder(p.value),\n            );\n          }),\n          true,\n        );\n      if (dynamic.length === 0) return literal;\n\n      const properties: ts.Statement[] = dynamic.map((p) =>\n        ts.factory.createExpressionStatement(\n          dynamicProperty(coalesce)(decoder)(p),\n        ),\n      );\n      return ts.factory.createBlock(\n        [\n          StatementFactory.constant(\n            \"output\",\n            ts.factory.createAsExpression(literal, TypeFactory.keyword(\"any\")),\n          ),\n          ...(obj.recursive\n            ? [\n                ts.factory.createIfStatement(\n                  ts.factory.createGreaterThanEquals(\n                    ExpressionFactory.number(5),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  ),\n                  ts.factory.createBlock(properties, true),\n                ),\n              ]\n            : properties),\n          ts.factory.createReturnStatement(\n            ts.factory.createIdentifier(\"output\"),\n          ),\n        ],\n        true,\n      );\n    };\n\n  const dynamicProperty =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (p: MetadataProperty) =>\n      ts.factory.createCallExpression(coalesce(\"array\"), undefined, [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          undefined,\n          ts.factory.createBinaryExpression(\n            ts.factory.createElementAccessExpression(\n              ts.factory.createIdentifier(\"output\"),\n              decoder(p.key),\n            ),\n            ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n            decoder(p.value),\n          ),\n        ),\n        ts.factory.createCallExpression(coalesce(\"integer\"), undefined, [\n          ExpressionFactory.number(0),\n          ExpressionFactory.number(3),\n        ]),\n      ]);\n}\n\ninterface IExplore {\n  function: boolean;\n  recursive: boolean;\n}\n"]}