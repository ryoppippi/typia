{"version":3,"sources":["../src/transformers/features/reflect/ReflectMetadataTransformer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { LiteralFactory } from \"../../../factories/LiteralFactory\";\nimport { MetadataCollection } from \"../../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../../factories/MetadataFactory\";\n\nimport { IMetadataApplication } from \"../../../schemas/metadata/IMetadataApplication\";\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { IProject } from \"../../IProject\";\nimport { TransformerError } from \"../../TransformerError\";\n\nexport namespace ReflectMetadataTransformer {\n  export const transform =\n    (project: IProject) =>\n    (_modulo: ts.LeftHandSideExpression) =>\n    (expression: ts.CallExpression): ts.Expression => {\n      if (!expression.typeArguments?.length)\n        throw new TransformerError({\n          code: \"typia.metadata\",\n          message: \"no generic argument.\",\n        });\n\n      // VALIDATE TUPLE ARGUMENTS\n      const top: ts.Node = expression.typeArguments[0]!;\n      if (!ts.isTupleTypeNode(top)) return expression;\n      else if (top.elements.some((child) => !ts.isTypeNode(child)))\n        return expression;\n\n      // GET TYPES\n      const types: ts.Type[] = top.elements.map((child) =>\n        project.checker.getTypeFromTypeNode(child as ts.TypeNode),\n      );\n      if (types.some((t) => t.isTypeParameter()))\n        throw new TransformerError({\n          code: \"typia.reflect.metadata\",\n          message: \"non-specified generic argument(s).\",\n        });\n\n      // METADATA\n      const collection: MetadataCollection = new MetadataCollection();\n      const metadatas: Array<Metadata> = types.map((type) => {\n        const result = MetadataFactory.analyze(\n          project.checker,\n          project.context,\n        )({\n          escape: true,\n          constant: true,\n          absorb: true,\n        })(collection)(type);\n        if (result.success === false)\n          throw TransformerError.from(\"typia.reflect.metadata\")(result.errors);\n        return result.data;\n      });\n\n      // CONVERT TO PRIMITIVE TYPE\n      const app: IMetadataApplication = {\n        metadatas: metadatas.map((metadata) => metadata.toJSON()),\n        components: collection.toJSON(),\n      };\n      return LiteralFactory.generate(app);\n    };\n}\n"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAYEC,6BAAAA;8BACFC,YACX,CAACC,YACD,CAACC,YACD,CAACC,eAAAA;AACC,QAAI,CAACA,WAAWC,eAAeC,OAC7B,OAAM,IAAIC,iBAAiB;MACzBC,MAAM;MACNC,SAAS;IACX,CAAA;AAGF,UAAMC,MAAeN,WAAWC,cAAc,CAAA;AAC9C,QAAI,CAACM,GAAGC,gBAAgBF,GAAAA,EAAM,QAAON;aAC5BM,IAAIG,SAASC,KAAK,CAACC,UAAU,CAACJ,GAAGK,WAAWD,KAAAA,CAAAA,EACnD,QAAOX;AAGT,UAAMa,QAAmBP,IAAIG,SAASK,IAAI,CAACH,UACzCb,QAAQiB,QAAQC,oBAAoBL,KAAAA,CAAAA;AAEtC,QAAIE,MAAMH,KAAK,CAACO,MAAMA,EAAEC,gBAAe,CAAA,EACrC,OAAM,IAAIf,iBAAiB;MACzBC,MAAM;MACNC,SAAS;IACX,CAAA;AAGF,UAAMc,aAAiC,IAAIC,mBAAAA;AAC3C,UAAMC,YAA6BR,MAAMC,IAAI,CAACQ,SAAAA;AAC5C,YAAMC,SAASC,gBAAgBC,QAC7B3B,QAAQiB,SACRjB,QAAQ4B,OAAO,EACf;QACAC,QAAQ;QACRC,UAAU;QACVC,QAAQ;MACV,CAAA,EAAGV,UAAAA,EAAYG,IAAAA;AACf,UAAIC,OAAOO,YAAY,MACrB,OAAM3B,iBAAiB4B,KAAK,wBAAA,EAA0BR,OAAOS,MAAM;AACrE,aAAOT,OAAOU;IAChB,CAAA;AAGA,UAAMC,MAA4B;MAChCb,WAAWA,UAAUP,IAAI,CAACqB,aAAaA,SAASC,OAAM,CAAA;MACtDC,YAAYlB,WAAWiB,OAAM;IAC/B;AACA,WAAOE,eAAeC,SAASL,GAAAA;EACjC;AACJ,GAlDiBtC,+BAAAA,6BAAAA,CAAAA,EAAAA;","names":["ts","ReflectMetadataTransformer","transform","project","_modulo","expression","typeArguments","length","TransformerError","code","message","top","ts","isTupleTypeNode","elements","some","child","isTypeNode","types","map","checker","getTypeFromTypeNode","t","isTypeParameter","collection","MetadataCollection","metadatas","type","result","MetadataFactory","analyze","context","escape","constant","absorb","success","from","errors","data","app","metadata","toJSON","components","LiteralFactory","generate"]}