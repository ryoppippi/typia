{"version":3,"sources":["../src/programmers/TypiaProgrammer.ts"],"names":["fs","path","ts","TypiaProgrammer","build","props","input","resolve","output","is_directory","URIError","existsSync","promises","mkdir","recursive","parent","join","options","compilerOptions","parseJsonConfigFileContent","readConfigFile","project","sys","readFile","config","fileExists","readDirectory","useCaseSensitiveFileNames","dirname","program","createProgram","container","gather","diagnostics","result","transform","getSourceFiles","filter","file","isDeclarationFile","fileName","indexOf","ImportTransformer","plugins","find","p","addDiagnostic","diag","push","getCompilerOptions","relative","process","cwd","category","DiagnosticCategory","Warning","Error","Suggestion","Message","line","pos","lines","text","substring","start","split","length","at","console","error","code","messageText","exit","printer","createPrinter","newLine","NewLineKind","LineFeed","transformed","to","replace","content","printFile","writeFile","current","stat","isDirectory","from","readdir","next","is_supported_extension","filename","endsWith"],"mappings":"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","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport ts from \"typescript\";\n\nimport { ImportTransformer } from \"../transformers/ImportTransformer\";\n\nimport transform from \"../transform\";\n\nexport namespace TypiaProgrammer {\n  export interface IProps {\n    input: string;\n    output: string;\n    project: string;\n  }\n\n  export const build = async (props: TypiaProgrammer.IProps): Promise<void> => {\n    props.input = path.resolve(props.input);\n    props.output = path.resolve(props.output);\n\n    if ((await is_directory(props.input)) === false)\n      throw new URIError(\n        \"Error on TypiaGenerator.generate(): input path is not a directory.\",\n      );\n    else if (fs.existsSync(props.output) === false)\n      await fs.promises.mkdir(props.output, { recursive: true });\n    else if ((await is_directory(props.output)) === false) {\n      const parent: string = path.join(props.output, \"..\");\n      if ((await is_directory(parent)) === false)\n        throw new URIError(\n          \"Error on TypiaGenerator.generate(): output path is not a directory.\",\n        );\n      await fs.promises.mkdir(props.output);\n    }\n\n    // CREATE PROGRAM\n    const { options: compilerOptions } = ts.parseJsonConfigFileContent(\n      ts.readConfigFile(props.project, ts.sys.readFile).config,\n      {\n        fileExists: ts.sys.fileExists,\n        readFile: ts.sys.readFile,\n        readDirectory: ts.sys.readDirectory,\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      path.dirname(props.project),\n    );\n\n    const program: ts.Program = ts.createProgram(\n      await (async () => {\n        const container: string[] = [];\n        await gather(props)(container)(props.input)(props.output);\n        return container;\n      })(),\n      compilerOptions,\n    );\n\n    // DO TRANSFORM\n    const diagnostics: ts.Diagnostic[] = [];\n    const result: ts.TransformationResult<ts.SourceFile> = ts.transform(\n      program\n        .getSourceFiles()\n        .filter(\n          (file) =>\n            !file.isDeclarationFile &&\n            path.resolve(file.fileName).indexOf(props.input) !== -1,\n        ),\n      [\n        ImportTransformer.transform(props.input)(props.output),\n        transform(\n          program,\n          ((compilerOptions.plugins as any[]) ?? []).find(\n            (p: any) =>\n              p.transform === \"typia/lib/transform\" ||\n              p.transform === \"../src/transform.ts\",\n          ) ?? {},\n          {\n            addDiagnostic: (diag) => diagnostics.push(diag),\n          },\n        ),\n      ],\n      program.getCompilerOptions(),\n    );\n\n    // TRACE ERRORS\n    for (const diag of diagnostics) {\n      const file: string = diag.file\n        ? path.relative(diag.file.fileName, process.cwd())\n        : \"(unknown file)\";\n      const category: string =\n        diag.category === ts.DiagnosticCategory.Warning\n          ? \"warning\"\n          : diag.category === ts.DiagnosticCategory.Error\n            ? \"error\"\n            : diag.category === ts.DiagnosticCategory.Suggestion\n              ? \"suggestion\"\n              : diag.category === ts.DiagnosticCategory.Message\n                ? \"message\"\n                : \"unkown\";\n      const [line, pos] = diag.file\n        ? (() => {\n            const lines: string[] = diag\n              .file!.text.substring(0, diag.start)\n              .split(\"\\n\");\n            if (lines.length === 0) return [0, 0];\n            return [lines.length, lines.at(-1)!.length + 1];\n          })()\n        : [0, 0];\n      console.error(\n        `${file}:${line}:${pos} - ${category} TS${diag.code}: ${diag.messageText}`,\n      );\n    }\n    if (diagnostics.length) process.exit(-1);\n\n    // ARCHIVE TRANSFORMED FILES\n    const printer: ts.Printer = ts.createPrinter({\n      newLine: ts.NewLineKind.LineFeed,\n    });\n    for (const file of result.transformed) {\n      const to: string = path\n        .resolve(file.fileName)\n        .replace(props.input, props.output);\n\n      const content: string = printer.printFile(file);\n      await fs.promises.writeFile(to, content, \"utf8\");\n    }\n  };\n\n  const is_directory = async (current: string): Promise<boolean> => {\n    const stat: fs.Stats = await fs.promises.stat(current);\n    return stat.isDirectory();\n  };\n\n  const gather =\n    (props: IProps) =>\n    (container: string[]) =>\n    (from: string) =>\n    async (to: string) => {\n      if (from === props.output) return;\n      else if (fs.existsSync(to) === false) await fs.promises.mkdir(to);\n\n      for (const file of await fs.promises.readdir(from)) {\n        const next: string = path.join(from, file);\n        const stat: fs.Stats = await fs.promises.stat(next);\n\n        if (stat.isDirectory()) {\n          await gather(props)(container)(next)(path.join(to, file));\n          continue;\n        } else if (is_supported_extension(file)) container.push(next);\n      }\n    };\n\n  const is_supported_extension = (filename: string): boolean => {\n    return (\n      (filename.endsWith(\".ts\") && !filename.endsWith(\".d.ts\")) ||\n      (filename.endsWith(\".tsx\") && !filename.endsWith(\".d.tsx\"))\n    );\n  };\n}\n"]}