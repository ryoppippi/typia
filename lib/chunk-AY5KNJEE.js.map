{"version":3,"sources":["../src/programmers/json/JsonStringifyProgrammer.ts"],"names":["ts","JsonStringifyProgrammer","write","project","modulo","importer","FunctionImporter","getText","config","configure","FeatureProgrammer","addition","collection","IsProgrammer","write_function_statements","declare","write_array_functions","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","decode","input","meta","explore","any","wrap_required","wrap_functional","createCallExpression","size","isRequired","nullable","createStringLiteral","createConditionalExpression","createStrictEquality","createNull","unions","escaped","push","is","original","natives","check_native","decode_to_json","value","returns","functional","decode_functional","templates","length","ArrayUtil","has","constants","c","AtomicPredicator","template","partial","Metadata","initialize","atomics","MetadataAtomic","decode_atomic","decode_constant_string","values","v","atomic","decode_tuple","decode_array","some","elem","explore_arrays","ExpressionFactory","isArray","native","toLowerCase","sets","isInstanceOf","maps","objects","isObject","checkNull","checkArray","obj","properties","every","prop","key","isSoleLiteral","isParentResolved","_Is_simple","entries","feature_object_entries","decoder","path","createAsExpression","StringifyJoiner","object","explore_objects","wrapper","output","wrap_nullable","iterate","getName","decode_object","PREFIX","array","useLocal","index","argumentsArray","children","elements","rest","createElementAccessExpression","slice","last","at","code","IdentifierFactory","access","number","wrap_metadata_rest_tuple","start","use","OptionPredicator","numeric","options","StringifyPredicator","require_escape","reduce","x","y","createAdd","resolved","union_index","explore_array_like_union_types","UnionExplorer","checker","empty","success","createTrue","failure","expected","create_throw_error","arrow","parameters","e","emplaceUnion","name","join","expression","createStrictInequality","ValueFactory","TYPEOF","createBlock","u","createIfStatement","createReturnStatement","types","createTypeReferenceNode","getFullName","initializer","objector","joiner","unionizer","decode_union_object","exp","generator","JsonMetadataFactory","analyze","method","context","createExpressionStatement","createObjectLiteralExpression","createPropertyAssignment"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { JsonMetadataFactory } from \"../../factories/JsonMetadataFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\nimport { ValueFactory } from \"../../factories/ValueFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { ArrayUtil } from \"../../utils/ArrayUtil\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { AtomicPredicator } from \"../helpers/AtomicPredicator\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"../helpers/OptionPredicator\";\nimport { StringifyJoiner } from \"../helpers/StringifyJoinder\";\nimport { StringifyPredicator } from \"../helpers/StringifyPredicator\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\nimport { check_native } from \"../internal/check_native\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\nimport { feature_object_entries } from \"../internal/feature_object_entries\";\nimport { wrap_metadata_rest_tuple } from \"../internal/wrap_metadata_rest_tuple\";\n\nexport namespace JsonStringifyProgrammer {\n  /* -----------------------------------------------------------\n    WRITER\n  ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) => (modulo: ts.LeftHandSideExpression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const config: FeatureProgrammer.IConfig = configure(project)(importer);\n\n      return FeatureProgrammer.write(project)({\n        ...config,\n        addition: (collection) => [\n          ...IsProgrammer.write_function_statements(project)(importer)(\n            collection,\n          ),\n          ...importer.declare(modulo),\n        ],\n      })(importer);\n    };\n\n  const write_array_functions =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n    DECODERS\n  ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      // ANY TYPE\n      if (meta.any === true)\n        return wrap_required(\n          input,\n          meta,\n          explore,\n        )(\n          wrap_functional(\n            input,\n            meta,\n            explore,\n          )(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"JSON.stringify\"),\n              undefined,\n              [input],\n            ),\n          ),\n        );\n\n      // ONLY NULL OR UNDEFINED\n      const size: number = meta.size();\n      if (\n        size === 0 &&\n        (meta.isRequired() === false || meta.nullable === true)\n      ) {\n        if (meta.isRequired() === false && meta.nullable === true)\n          return explore.from === \"array\"\n            ? ts.factory.createStringLiteral(\"null\")\n            : ts.factory.createConditionalExpression(\n                ts.factory.createStrictEquality(ts.factory.createNull(), input),\n                undefined,\n                ts.factory.createStringLiteral(\"null\"),\n                undefined,\n                ts.factory.createIdentifier(\"undefined\"),\n              );\n        else if (meta.isRequired() === false)\n          return explore.from === \"array\"\n            ? ts.factory.createStringLiteral(\"null\")\n            : ts.factory.createIdentifier(\"undefined\");\n        else return ts.factory.createStringLiteral(\"null\");\n      }\n\n      //----\n      // LIST UP UNION TYPES\n      //----\n      const unions: IUnion[] = [];\n\n      // toJSON() METHOD\n      if (meta.escaped !== null)\n        unions.push({\n          type: \"resolved\",\n          is:\n            meta.escaped.original.size() === 1 &&\n            meta.escaped.original.natives[0] === \"Date\"\n              ? () => check_native(\"Date\")(input)\n              : () => IsProgrammer.decode_to_json(false)(input),\n          value: () =>\n            decode_to_json(project)(config)(importer)(\n              input,\n              meta.escaped!.returns,\n              explore,\n            ),\n        });\n      else if (meta.functional === true)\n        unions.push({\n          type: \"functional\",\n          is: () => IsProgrammer.decode_functional(input),\n          value: () => decode_functional(explore),\n        });\n\n      // TEMPLATES\n      if (\n        meta.templates.length ||\n        ArrayUtil.has(meta.constants, (c) => c.type === \"string\")\n      )\n        if (AtomicPredicator.template(meta)) {\n          const partial = Metadata.initialize();\n          partial.atomics.push(\n            MetadataAtomic.create({ type: \"string\", tags: [] }),\n          ),\n            unions.push({\n              type: \"template literal\",\n              is: () =>\n                IsProgrammer.decode(project)(importer)(input, partial, explore),\n              value: () =>\n                decode_atomic(project)(importer)(input, \"string\", explore),\n            });\n        }\n\n      // CONSTANTS\n      for (const constant of meta.constants)\n        if (AtomicPredicator.constant(meta)(constant.type) === false) continue;\n        else if (constant.type !== \"string\")\n          unions.push({\n            type: \"atomic\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(\n                    MetadataAtomic.create({\n                      type: constant.type,\n                      tags: [],\n                    }),\n                  );\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_atomic(project)(importer)(input, constant.type, explore),\n          });\n        else if (meta.templates.length === 0)\n          unions.push({\n            type: \"const string\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(\n                    MetadataAtomic.create({\n                      type: \"string\",\n                      tags: [],\n                    }),\n                  );\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_constant_string(project)(importer)(\n                input,\n                [...constant.values.map((v) => v.value)] as string[],\n                explore,\n              ),\n          });\n\n      /// ATOMICS\n      for (const a of meta.atomics)\n        if (AtomicPredicator.atomic(meta)(a.type))\n          unions.push({\n            type: \"atomic\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(a);\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_atomic(project)(importer)(input, a.type, explore),\n          });\n\n      // TUPLES\n      for (const tuple of meta.tuples)\n        unions.push({\n          type: \"tuple\",\n          is: () =>\n            IsProgrammer.decode(project)(importer)(\n              input,\n              (() => {\n                const partial = Metadata.initialize();\n                partial.tuples.push(tuple);\n                return partial;\n              })(),\n              explore,\n            ),\n          value: () =>\n            decode_tuple(project)(config)(importer)(input, tuple, explore),\n        });\n\n      // ARRAYS\n      if (meta.arrays.length) {\n        const value: () => ts.Expression =\n          meta.arrays.length === 1\n            ? () =>\n                decode_array(config)(importer)(input, meta.arrays[0]!, {\n                  ...explore,\n                  from: \"array\",\n                })\n            : meta.arrays.some((elem) => elem.type.value.any)\n              ? () =>\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"JSON.stringify\"),\n                    undefined,\n                    [input],\n                  )\n              : () =>\n                  explore_arrays(project)(config)(importer)(\n                    input,\n                    meta.arrays,\n                    {\n                      ...explore,\n                      from: \"array\",\n                    },\n                  );\n\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value,\n        });\n      }\n\n      // BUILT-IN CLASSES\n      if (meta.natives.length)\n        for (const native of meta.natives)\n          unions.push({\n            type: \"object\",\n            is: () => check_native(native)(input),\n            value: () =>\n              AtomicPredicator.native(native)\n                ? decode_atomic(project)(importer)(\n                    input,\n                    native.toLowerCase() as Atomic.Literal,\n                    explore,\n                  )\n                : ts.factory.createStringLiteral(\"{}\"),\n          });\n\n      // SETS\n      if (meta.sets.length)\n        unions.push({\n          type: \"object\",\n          is: () => ExpressionFactory.isInstanceOf(\"Set\")(input),\n          value: () => ts.factory.createStringLiteral(\"{}\"),\n        });\n\n      // MAPS\n      if (meta.maps.length)\n        unions.push({\n          type: \"object\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: () => ts.factory.createStringLiteral(\"{}\"),\n        });\n\n      // OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: meta.objects.some((obj) =>\n                obj.properties.every(\n                  (prop) =>\n                    !prop.key.isSoleLiteral() || !prop.value.isRequired(),\n                ),\n              ),\n            })(input),\n          value: () =>\n            meta.isParentResolved() === false &&\n            meta.objects.length === 1 &&\n            meta.objects[0]!._Is_simple(explore.from === \"top\" ? 0 : 1)\n              ? (() => {\n                  const obj: MetadataObject = meta.objects[0]!;\n                  const entries: IExpressionEntry<ts.Expression>[] =\n                    feature_object_entries({\n                      decoder: () => decode(project)(config)(importer),\n                      trace: false,\n                      path: false,\n                    })(importer)(obj)(\n                      ts.factory.createAsExpression(\n                        input,\n                        TypeFactory.keyword(\"any\"),\n                      ),\n                    );\n                  return StringifyJoiner.object(importer)(\n                    ts.factory.createAsExpression(\n                      input,\n                      TypeFactory.keyword(\"any\"),\n                    ),\n                    entries,\n                  );\n                })()\n              : explore_objects(config)(importer)(input, meta, {\n                  ...explore,\n                  from: \"object\",\n                }),\n        });\n\n      //----\n      // RETURNS\n      //----\n      // CHECK NULL AND UNDEFINED\n      const wrapper = (output: ts.Expression) =>\n        wrap_required(input, meta, explore)(wrap_nullable(input, meta)(output));\n\n      // DIRECT RETURN\n      if (unions.length === 0)\n        return ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"JSON.stringify\"),\n          undefined,\n          [input],\n        );\n      else if (unions.length === 1) return wrapper(unions[0]!.value());\n\n      // RETURN WITH TYPE CHECKING\n      return wrapper(\n        ts.factory.createCallExpression(\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            undefined,\n            iterate(importer, input, unions, meta.getName()),\n          ),\n          undefined,\n          undefined,\n        ),\n      );\n    };\n\n  const decode_object = (importer: FunctionImporter) =>\n    FeatureProgrammer.decode_object({\n      trace: false,\n      path: false,\n      prefix: PREFIX,\n    })(importer);\n\n  const decode_array =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      array.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}a${array.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n              from: \"array\",\n            })(input),\n          )\n        : decode_array_inline(config)(importer)(input, array, explore);\n\n  const decode_array_inline =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      FeatureProgrammer.decode_array(config)(importer)(StringifyJoiner.array)(\n        input,\n        array,\n        explore,\n      );\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n            })(input),\n          )\n        : decode_tuple_inline(project)(config)(importer)(\n            input,\n            tuple.type,\n            explore,\n          );\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const children: ts.Expression[] = tuple.elements\n        .filter((elem) => elem.rest === null)\n        .map((elem, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            elem,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest = (() => {\n        if (tuple.elements.length === 0) return null;\n        const last = tuple.elements.at(-1)!;\n        if (last.rest === null) return null;\n\n        const code = decode(project)(config)(importer)(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"slice\"),\n            undefined,\n            [ExpressionFactory.number(tuple.elements.length - 1)],\n          ),\n          wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n          {\n            ...explore,\n            start: tuple.elements.length - 1,\n          },\n        );\n        return ts.factory.createCallExpression(\n          importer.use(\"rest\"),\n          undefined,\n          [code],\n        );\n      })();\n      return StringifyJoiner.tuple(children, rest);\n    };\n\n  const decode_atomic =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      type: string,\n      explore: FeatureProgrammer.IExplore,\n    ) => {\n      if (type === \"string\")\n        return ts.factory.createCallExpression(\n          importer.use(\"string\"),\n          undefined,\n          [input],\n        );\n      else if (type === \"number\" && OptionPredicator.numeric(project.options))\n        input = ts.factory.createCallExpression(\n          importer.use(\"number\"),\n          undefined,\n          [input],\n        );\n\n      return explore.from !== \"top\"\n        ? input\n        : ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"toString\"),\n            undefined,\n            undefined,\n          );\n    };\n\n  const decode_constant_string =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      values: string[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      if (values.every((v) => !StringifyPredicator.require_escape(v)))\n        return [\n          ts.factory.createStringLiteral('\"'),\n          input,\n          ts.factory.createStringLiteral('\"'),\n        ].reduce((x, y) => ts.factory.createAdd(x, y));\n      else return decode_atomic(project)(importer)(input, \"string\", explore);\n    };\n\n  const decode_to_json =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      resolved: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      return decode(project)(config)(importer)(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"toJSON\"),\n          undefined,\n          [],\n        ),\n        resolved,\n        explore,\n      );\n    };\n\n  const decode_functional = (explore: FeatureProgrammer.IExplore) =>\n    explore.from === \"array\"\n      ? ts.factory.createStringLiteral(\"null\")\n      : ts.factory.createIdentifier(\"undefined\");\n\n  /* -----------------------------------------------------------\n    EXPLORERS\n  ----------------------------------------------------------- */\n  const explore_objects =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      meta.objects.length === 1\n        ? decode_object(importer)(input, meta.objects[0]!, explore)\n        : ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${PREFIX}u${meta.union_index!}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)(explore)(input),\n          );\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: MetadataArray[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: decode_array(config)(importer),\n          empty: ts.factory.createStringLiteral(\"[]\"),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: FeatureProgrammer.IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (\n      input: ts.Expression,\n      elements: T[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: FeatureProgrammer.IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.emplaceUnion(\n            config.prefix,\n            elements.map((e) => e.type.name).join(\" | \"),\n            () =>\n              arrow(\n                FeatureProgrammer.parameterDeclarations(config)(\n                  TypeFactory.keyword(\"any\"),\n                )(ts.factory.createIdentifier(\"input\")),\n              )({\n                ...explore,\n                postfix: \"\",\n              })(ts.factory.createIdentifier(\"input\")),\n          ),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  /* -----------------------------------------------------------\n    RETURN SCRIPTS\n  ----------------------------------------------------------- */\n  const wrap_required = (\n    input: ts.Expression,\n    meta: Metadata,\n    explore: FeatureProgrammer.IExplore,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.isRequired() === true && meta.any === false)\n      return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(\n          ts.factory.createIdentifier(\"undefined\"),\n          input,\n        ),\n        undefined,\n        expression,\n        undefined,\n        explore.from === \"array\"\n          ? ts.factory.createStringLiteral(\"null\")\n          : ts.factory.createIdentifier(\"undefined\"),\n      );\n  };\n\n  const wrap_nullable = (\n    input: ts.Expression,\n    meta: Metadata,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.nullable === false) return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(ts.factory.createNull(), input),\n        undefined,\n        expression,\n        undefined,\n        ts.factory.createStringLiteral(\"null\"),\n      );\n  };\n\n  const wrap_functional = (\n    input: ts.Expression,\n    meta: Metadata,\n    explore: FeatureProgrammer.IExplore,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.functional === false) return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(\n          ts.factory.createStringLiteral(\"function\"),\n          ValueFactory.TYPEOF(input),\n        ),\n        undefined,\n        expression,\n        undefined,\n        decode_functional(explore),\n      );\n  };\n\n  const iterate = (\n    importer: FunctionImporter,\n    input: ts.Expression,\n    unions: IUnion[],\n    expected: string,\n  ) =>\n    ts.factory.createBlock(\n      [\n        ...unions.map((u) =>\n          ts.factory.createIfStatement(\n            u.is(),\n            ts.factory.createReturnStatement(u.value()),\n          ),\n        ),\n        create_throw_error(importer)(expected)(input),\n      ],\n      true,\n    );\n\n  /* -----------------------------------------------------------\n    CONFIGURATIONS\n  ----------------------------------------------------------- */\n  const PREFIX = \"$s\";\n\n  const configure =\n    (project: IProject) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => {\n      const config: FeatureProgrammer.IConfig = {\n        types: {\n          input: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          output: () => TypeFactory.keyword(\"string\"),\n        },\n        prefix: PREFIX,\n        trace: false,\n        path: false,\n        initializer,\n        decoder: () => decode(project)(config)(importer),\n        objector: {\n          checker: () => (input, meta, explore) =>\n            IsProgrammer.decode(project)(importer)(input, meta, explore),\n          decoder: () => decode_object(importer),\n          joiner: StringifyJoiner.object(importer),\n          unionizer: decode_union_object(\n            IsProgrammer.decode_object(project)(importer),\n          )(decode_object(importer))((exp) => exp)((value, expected) =>\n            create_throw_error(importer)(expected)(value),\n          ),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        },\n        generator: {\n          arrays: () => write_array_functions(config)(importer),\n          tuples: () => write_tuple_functions(project)(config)(importer),\n        },\n      };\n      return config;\n    };\n\n  const initializer: FeatureProgrammer.IConfig[\"initializer\"] =\n    (project) => (importer) => (type) =>\n      JsonMetadataFactory.analyze(`typia.json.${importer.method}`)(\n        project.checker,\n        project.context,\n      )(type);\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n\ninterface IUnion {\n  type: string;\n  is: () => ts.Expression;\n  value: () => ts.Expression;\n}\n"]}