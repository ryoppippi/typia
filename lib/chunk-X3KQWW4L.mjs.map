{"version":3,"sources":["../src/programmers/protobuf/ProtobufEncodeProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { NumericRangeFactory } from \"../../factories/NumericRangeFactory\";\nimport { ProtobufFactory } from \"../../factories/ProtobufFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ProtobufAtomic } from \"../../typings/ProtobufAtomic\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { ProtobufUtil } from \"../helpers/ProtobufUtil\";\nimport { ProtobufWire } from \"../helpers/ProtobufWire\";\nimport { UnionPredicator } from \"../helpers/UnionPredicator\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\n\nexport namespace ProtobufEncodeProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      const importer = new FunctionImporter(modulo.getText());\n      const collection = new MetadataCollection();\n      const meta: Metadata = ProtobufFactory.metadata(modulo.getText())(\n        project.checker,\n        project.context,\n      )(collection)(type);\n\n      const callEncoder = (writer: string) => (factory: ts.NewExpression) =>\n        StatementFactory.constant(\n          writer,\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"encoder\"),\n            undefined,\n            [factory],\n          ),\n        );\n\n      const block: ts.Statement[] = [\n        StatementFactory.constant(\n          \"encoder\",\n          write_encoder(project)(importer)(collection)(meta),\n        ),\n        callEncoder(\"sizer\")(\n          ts.factory.createNewExpression(importer.use(\"Sizer\"), undefined, []),\n        ),\n        callEncoder(\"writer\")(\n          ts.factory.createNewExpression(importer.use(\"Writer\"), undefined, [\n            ts.factory.createIdentifier(\"sizer\"),\n          ]),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"buffer\"),\n            undefined,\n            undefined,\n          ),\n        ),\n      ];\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ),\n        ],\n        ts.factory.createTypeReferenceNode(\"Uint8Array\"),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo, false), ...block],\n          true,\n        ),\n      );\n    };\n\n  const write_encoder =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection) =>\n    (meta: Metadata): ts.ArrowFunction => {\n      const functors = collection\n        .objects()\n        .filter((obj) => ProtobufUtil.isStaticObject(obj))\n        .map((obj) =>\n          StatementFactory.constant(\n            `${PREFIX}o${obj.index}`,\n            write_object_function(project)(importer)(\n              ts.factory.createIdentifier(\"input\"),\n              obj,\n              {\n                source: \"function\",\n                from: \"object\",\n                tracable: false,\n                postfix: \"\",\n              },\n            ),\n          ),\n        );\n      const main = decode(project)(importer)(null)(\n        ts.factory.createIdentifier(\"input\"),\n        meta,\n        {\n          source: \"top\",\n          from: \"top\",\n          tracable: false,\n          postfix: \"\",\n        },\n      );\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"writer\")],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...importer.declareUnions(),\n            ...functors,\n            ...IsProgrammer.write_function_statements(project)(importer)(\n              collection,\n            ),\n            ...main.statements,\n            ts.factory.createReturnStatement(\n              ts.factory.createIdentifier(\"writer\"),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const write_object_function =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      obj: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.ArrowFunction => {\n      let index: number = 1;\n      const body: ts.Statement[] = obj.properties\n        .map((p) => {\n          const block = decode(project)(importer)(index)(\n            IdentifierFactory.access(input)(p.key.getSoleLiteral()!),\n            p.value,\n            explore,\n          );\n          index += ProtobufUtil.size(p.value);\n          return [\n            ts.factory.createExpressionStatement(\n              ts.factory.createIdentifier(\n                `// property \"${p.key.getSoleLiteral()!}\"`,\n              ),\n            ),\n            ...block.statements,\n          ];\n        })\n        .flat();\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\")],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(body, true),\n      );\n    };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const wrapper: (block: ts.Block) => ts.Block =\n        meta.isRequired() && meta.nullable === false\n          ? (block) => block\n          : meta.isRequired() === false && meta.nullable === true\n            ? (block) =>\n                ts.factory.createBlock(\n                  [\n                    ts.factory.createIfStatement(\n                      ts.factory.createLogicalAnd(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createIdentifier(\"undefined\"),\n                          input,\n                        ),\n                        ts.factory.createStrictInequality(\n                          ts.factory.createNull(),\n                          input,\n                        ),\n                      ),\n                      block,\n                    ),\n                  ],\n                  true,\n                )\n            : meta.isRequired() === false\n              ? (block) =>\n                  ts.factory.createBlock(\n                    [\n                      ts.factory.createIfStatement(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createIdentifier(\"undefined\"),\n                          input,\n                        ),\n                        block,\n                      ),\n                    ],\n                    true,\n                  )\n              : (block) =>\n                  ts.factory.createBlock(\n                    [\n                      ts.factory.createIfStatement(\n                        ts.factory.createStrictInequality(\n                          ts.factory.createNull(),\n                          input,\n                        ),\n                        block,\n                      ),\n                    ],\n                    true,\n                  );\n\n      // STARTS FROM ATOMIC TYPES\n      const unions: IUnion[] = [];\n      const numbers = ProtobufUtil.getNumbers(meta);\n      const bigints = ProtobufUtil.getBigints(meta);\n\n      for (const atom of ProtobufUtil.getAtomics(meta))\n        if (atom === \"bool\")\n          unions.push({\n            type: \"bool\",\n            is: () =>\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"boolean\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n            value: (index) => decode_bool(index)(input),\n          });\n        else if (\n          atom === \"int32\" ||\n          atom === \"uint32\" ||\n          atom === \"float\" ||\n          atom === \"double\"\n        )\n          unions.push(decode_number(numbers)(atom)(input));\n        else if (atom === \"int64\" || atom === \"uint64\")\n          if (numbers.some((n) => n === atom))\n            unions.push(decode_number(numbers)(atom)(input));\n          else unions.push(decode_bigint(bigints)(atom)(input));\n        else if (atom === \"string\")\n          unions.push({\n            type: \"string\",\n            is: () =>\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"string\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n            value: (index) => decode_bytes(\"string\")(index!)(input),\n          });\n\n      // CONSIDER BYTES\n      if (meta.natives.length)\n        unions.push({\n          type: \"bytes\",\n          is: () => ExpressionFactory.isInstanceOf(\"Uint8Array\")(input),\n          value: (index) => decode_bytes(\"bytes\")(index!)(input),\n        });\n\n      // CONSIDER ARRAYS\n      if (meta.arrays.length)\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value: (index) =>\n            decode_array(project)(importer)(index!)(input, meta.arrays[0]!, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // CONSIDER MAPS\n      if (meta.maps.length)\n        unions.push({\n          type: \"map\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: (index) =>\n            decode_map(project)(importer)(index!)(input, meta.maps[0]!, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // CONSIDER OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: false,\n            })(input),\n          value: (index) =>\n            explore_objects(project)(importer)(0)(index)(input, meta.objects, {\n              ...explore,\n              from: \"object\",\n            }),\n        });\n\n      // RETURNS\n      if (unions.length === 1) return wrapper(unions[0]!.value(index));\n      else\n        return wrapper(iterate(importer)(index)(unions)(meta.getName())(input));\n    };\n\n  const iterate =\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (unions: IUnion[]) =>\n    (expected: string) =>\n    (input: ts.Expression) =>\n      ts.factory.createBlock(\n        [\n          unions\n            .map((u, i) =>\n              ts.factory.createIfStatement(\n                u.is(),\n                u.value(index ? index + i : null),\n                i === unions.length - 1\n                  ? create_throw_error(importer)(expected)(input)\n                  : undefined,\n              ),\n            )\n            .reverse()\n            .reduce((a, b) =>\n              ts.factory.createIfStatement(b.expression, b.thenStatement, a),\n            ),\n        ],\n        true,\n      );\n\n  const decode_map =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      input: ts.Expression,\n      map: Metadata.Entry,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const each: ts.Statement[] = [\n        ts.factory.createExpressionStatement(\n          decode_tag(ProtobufWire.LEN)(index),\n        ),\n        ts.factory.createExpressionStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"fork\"),\n            undefined,\n            undefined,\n          ),\n        ),\n        ...decode(project)(importer)(1)(\n          ts.factory.createIdentifier(\"key\"),\n          map.key,\n          explore,\n        ).statements,\n        ...decode(project)(importer)(2)(\n          ts.factory.createIdentifier(\"value\"),\n          map.value,\n          explore,\n        ).statements,\n        ts.factory.createExpressionStatement(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(\"ldelim\"),\n            undefined,\n            undefined,\n          ),\n        ),\n      ];\n      return ts.factory.createBlock(\n        [\n          ts.factory.createForOfStatement(\n            undefined,\n            StatementFactory.entry(\"key\")(\"value\"),\n            input,\n            ts.factory.createBlock(each),\n          ),\n        ],\n        true,\n      );\n    };\n\n  const decode_object =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      object: MetadataObject,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const top: MetadataProperty = object.properties[0]!;\n      if (top.key.isSoleLiteral() === false)\n        return decode_map(project)(importer)(index!)(\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Object.entries\"),\n            [],\n            [input],\n          ),\n          MetadataProperty.create({\n            ...top,\n            key: (() => {\n              const key: Metadata = Metadata.initialize();\n              key.atomics.push(\n                MetadataAtomic.create({\n                  type: \"string\",\n                  tags: [],\n                }),\n              );\n              return key;\n            })(),\n          }),\n          explore,\n        );\n      return ts.factory.createBlock(\n        [\n          ts.factory.createIdentifier(\n            `//${index !== null ? ` ${index} -> ` : \"\"}${object.name}`,\n          ),\n          ...(index !== null\n            ? [\n                decode_tag(ProtobufWire.LEN)(index),\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(WRITER())(\"fork\"),\n                  undefined,\n                  undefined,\n                ),\n              ]\n            : []),\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${PREFIX}o${object.index}`),\n            ),\n            [],\n            [input],\n          ),\n          ...(index !== null\n            ? [\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(WRITER())(\"ldelim\"),\n                  undefined,\n                  undefined,\n                ),\n              ]\n            : []),\n        ].map((expr) => ts.factory.createExpressionStatement(expr)),\n        true,\n      );\n    };\n\n  const decode_array =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const wire = get_standalone_wire(array.type.value);\n      const forLoop = (index: number | null) =>\n        ts.factory.createForOfStatement(\n          undefined,\n          ts.factory.createVariableDeclarationList(\n            [ts.factory.createVariableDeclaration(\"elem\")],\n            ts.NodeFlags.Const,\n          ),\n          input,\n          decode(project)(importer)(index)(\n            ts.factory.createIdentifier(\"elem\"),\n            array.type.value,\n            explore,\n          ),\n        );\n      const length = (block: ts.Block) =>\n        ts.factory.createBlock(\n          [\n            ts.factory.createIfStatement(\n              ts.factory.createStrictInequality(\n                ExpressionFactory.number(0),\n                IdentifierFactory.access(input)(\"length\"),\n              ),\n              block,\n            ),\n          ],\n          true,\n        );\n\n      if (wire === ProtobufWire.LEN)\n        return length(ts.factory.createBlock([forLoop(index)], true));\n      return length(\n        ts.factory.createBlock(\n          [\n            ts.factory.createExpressionStatement(\n              decode_tag(ProtobufWire.LEN)(index),\n            ),\n            ts.factory.createExpressionStatement(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(WRITER())(\"fork\"),\n                undefined,\n                undefined,\n              ),\n            ),\n            forLoop(null),\n            ts.factory.createExpressionStatement(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(WRITER())(\"ldelim\"),\n                undefined,\n                undefined,\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const decode_bool = (index: number | null) => (input: ts.Expression) =>\n    ts.factory.createBlock(\n      [\n        ...(index !== null ? [decode_tag(ProtobufWire.VARIANT)(index)] : []),\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(WRITER())(\"bool\"),\n          undefined,\n          [input],\n        ),\n      ].map((exp) => ts.factory.createExpressionStatement(exp)),\n      true,\n    );\n\n  const decode_number =\n    (candidates: ProtobufAtomic.Numeric[]) =>\n    (type: ProtobufAtomic.Numeric) =>\n    (input: ts.Expression): IUnion => ({\n      type,\n      is: () =>\n        candidates.length === 1\n          ? ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"number\"),\n              ts.factory.createTypeOfExpression(input),\n            )\n          : ts.factory.createLogicalAnd(\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"number\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n              NumericRangeFactory.number(type)(input),\n            ),\n      value: (index) =>\n        ts.factory.createBlock(\n          [\n            ...(index !== null\n              ? [decode_tag(get_numeric_wire(type))(index)]\n              : []),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(WRITER())(type),\n              undefined,\n              [input],\n            ),\n          ].map((exp) => ts.factory.createExpressionStatement(exp)),\n          true,\n        ),\n    });\n\n  const decode_bigint =\n    (candidates: ProtobufAtomic.BigNumeric[]) =>\n    (type: ProtobufAtomic.BigNumeric) =>\n    (input: ts.Expression): IUnion => ({\n      type,\n      is: () =>\n        candidates.length === 1\n          ? ts.factory.createStrictEquality(\n              ts.factory.createStringLiteral(\"bigint\"),\n              ts.factory.createTypeOfExpression(input),\n            )\n          : ts.factory.createLogicalAnd(\n              ts.factory.createStrictEquality(\n                ts.factory.createStringLiteral(\"bigint\"),\n                ts.factory.createTypeOfExpression(input),\n              ),\n              NumericRangeFactory.bigint(type)(input),\n            ),\n      value: (index) =>\n        ts.factory.createBlock(\n          [\n            ...(index !== null\n              ? [decode_tag(ProtobufWire.VARIANT)(index)]\n              : []),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(WRITER())(type),\n              undefined,\n              [input],\n            ),\n          ].map((exp) => ts.factory.createExpressionStatement(exp)),\n          true,\n        ),\n    });\n\n  const decode_bytes =\n    (method: \"bytes\" | \"string\") =>\n    (index: number) =>\n    (input: ts.Expression): ts.Block =>\n      ts.factory.createBlock(\n        [\n          decode_tag(ProtobufWire.LEN)(index),\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(WRITER())(method),\n            undefined,\n            [input],\n          ),\n        ].map((expr) => ts.factory.createExpressionStatement(expr)),\n        true,\n      );\n\n  const decode_tag =\n    (wire: ProtobufWire) =>\n    (index: number): ts.CallExpression =>\n      ts.factory.createCallExpression(\n        IdentifierFactory.access(WRITER())(\"uint32\"),\n        undefined,\n        [ExpressionFactory.number((index << 3) | wire)],\n      );\n\n  const get_standalone_wire = (meta: Metadata): ProtobufWire => {\n    if (\n      meta.arrays.length ||\n      meta.objects.length ||\n      meta.maps.length ||\n      meta.natives.length\n    )\n      return ProtobufWire.LEN;\n\n    const v = ProtobufUtil.getAtomics(meta)[0]!;\n    if (v === \"string\") return ProtobufWire.LEN;\n    else if (\n      v === \"bool\" ||\n      v === \"int32\" ||\n      v === \"uint32\" ||\n      v === \"int64\" ||\n      v === \"uint64\"\n    )\n      return ProtobufWire.VARIANT;\n    else if (v === \"float\") return ProtobufWire.I32;\n    return ProtobufWire.I64;\n  };\n\n  const get_numeric_wire = (type: ProtobufAtomic.Numeric) =>\n    type === \"double\"\n      ? ProtobufWire.I64\n      : type === \"float\"\n        ? ProtobufWire.I32\n        : ProtobufWire.VARIANT;\n\n  /* -----------------------------------------------------------\n        EXPLORERS\n    ----------------------------------------------------------- */\n  const explore_objects =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (level: number) =>\n    (index: number | null) =>\n    (\n      input: ts.Expression,\n      targets: MetadataObject[],\n      explore: FeatureProgrammer.IExplore,\n      indexes?: Map<MetadataObject, number>,\n    ): ts.Block => {\n      if (targets.length === 1)\n        return decode_object(project)(importer)(\n          indexes ? indexes.get(targets[0]!)! : index,\n        )(input, targets[0]!, explore);\n\n      const expected: string = `(${targets.map((t) => t.name).join(\" | \")})`;\n\n      // POSSIBLE TO SPECIALIZE?\n      const specList = UnionPredicator.object(targets);\n      indexes ??= new Map(targets.map((t, i) => [t, index! + i]));\n\n      if (specList.length === 0) {\n        const condition: ts.Expression = decode_union_object(\n          IsProgrammer.decode_object(project)(importer),\n        )((i, o, e) =>\n          ExpressionFactory.selfCall(\n            decode_object(project)(importer)(indexes!.get(o)!)(i, o, e),\n          ),\n        )((expr) => expr)((value, expected) =>\n          create_throw_error(importer)(expected)(value),\n        )(input, targets, explore);\n        return StatementFactory.block(condition);\n      }\n      const remained: MetadataObject[] = targets.filter(\n        (t) => specList.find((s) => s.object === t) === undefined,\n      );\n\n      // DO SPECIALIZE\n      const condition: ts.IfStatement = specList\n        .filter((spec) => spec.property.key.getSoleLiteral() !== null)\n        .map((spec, i, array) => {\n          const key: string = spec.property.key.getSoleLiteral()!;\n          const accessor: ts.Expression = IdentifierFactory.access(input)(key);\n          const pred: ts.Expression = spec.neighbour\n            ? IsProgrammer.decode(project)(importer)(\n                accessor,\n                spec.property.value,\n                {\n                  ...explore,\n                  tracable: false,\n                  postfix: IdentifierFactory.postfix(key),\n                },\n              )\n            : ExpressionFactory.isRequired(accessor);\n          return ts.factory.createIfStatement(\n            pred,\n            ts.factory.createExpressionStatement(\n              ExpressionFactory.selfCall(\n                decode_object(project)(importer)(indexes!.get(spec.object)!)(\n                  input,\n                  spec.object,\n                  explore,\n                ),\n              ),\n            ),\n            i === array.length - 1\n              ? remained.length\n                ? ts.factory.createExpressionStatement(\n                    ExpressionFactory.selfCall(\n                      explore_objects(project)(importer)(level + 1)(index)(\n                        input,\n                        remained,\n                        explore,\n                        indexes!,\n                      ),\n                    ),\n                  )\n                : create_throw_error(importer)(expected)(input)\n              : undefined,\n          );\n        })\n        .reverse()\n        .reduce((a, b) =>\n          ts.factory.createIfStatement(b.expression, b.thenStatement, a),\n        );\n\n      // RETURNS WITH CONDITIONS\n      return ts.factory.createBlock([condition], true);\n    };\n\n  /* -----------------------------------------------------------\n        CONFIGURATIONS\n    ----------------------------------------------------------- */\n  const PREFIX = \"$pe\";\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n\nconst WRITER = () => ts.factory.createIdentifier(\"writer\");\n\ninterface IUnion {\n  type: string;\n  is: () => ts.Expression;\n  value: (index: number | null) => ts.Block;\n}\n"],"mappings":"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","names":["ts","ProtobufEncodeProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","meta","ProtobufFactory","metadata","checker","context","callEncoder","writer","factory","StatementFactory","constant","ts","createCallExpression","createIdentifier","undefined","block","write_encoder","createNewExpression","use","createReturnStatement","IdentifierFactory","access","WRITER","createArrowFunction","parameter","createTypeReferenceNode","TypeFactory","getFullName","createBlock","declare","functors","objects","filter","obj","ProtobufUtil","isStaticObject","map","PREFIX","index","write_object_function","source","from","tracable","postfix","main","decode","keyword","declareUnions","IsProgrammer","write_function_statements","statements","input","explore","body","properties","p","key","getSoleLiteral","value","size","createExpressionStatement","flat","wrapper","isRequired","nullable","createIfStatement","createLogicalAnd","createStrictInequality","createNull","unions","numbers","getNumbers","bigints","getBigints","atom","getAtomics","push","is","createStrictEquality","createStringLiteral","createTypeOfExpression","decode_bool","decode_number","some","n","decode_bigint","decode_bytes","natives","length","ExpressionFactory","isInstanceOf","arrays","isArray","decode_array","maps","decode_map","isObject","checkNull","checkArray","explore_objects","iterate","getName","expected","u","i","create_throw_error","reverse","reduce","a","b","expression","thenStatement","each","decode_tag","ProtobufWire","LEN","createForOfStatement","entry","decode_object","object","top","isSoleLiteral","MetadataProperty","create","Metadata","initialize","atomics","MetadataAtomic","tags","useLocal","expr","array","wire","get_standalone_wire","forLoop","createVariableDeclarationList","createVariableDeclaration","NodeFlags","Const","number","VARIANT","exp","candidates","NumericRangeFactory","get_numeric_wire","bigint","method","v","I32","I64","level","targets","indexes","get","t","join","specList","UnionPredicator","Map","condition","decode_union_object","o","e","selfCall","remained","find","s","spec","property","accessor","pred","neighbour","createObjectLiteralExpression","createPropertyAssignment"]}