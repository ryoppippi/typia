{"version":3,"sources":["../src/http.ts"],"sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { Atomic } from \"./typings/Atomic\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    HTTP\n      - FORM-DATA\n      - QUERY\n      - HEADERS\n      - PARAMETER\n      - FACTORY FUNCTIONS\n==============================================================\n    FORM-DATA\n----------------------------------------------------------- */\n/**\n * Form data decoder.\n *\n * `typia.http.formData()` is a function decoding `FormData` instance, with\n * automatic type casting to the expected type. When roperty type be defined\n * as `boolean` or `Blob` type, `typia.http.formData()` will cast the value to\n * the expected type when decoding.\n *\n * By the way, as `FormData` is not enough to express complex data structures,\n * `typia.http.formData()` function has some limitations. If target type `T` is\n * not following those restrictions, compilation errors would be occured.\n *\n * 1. Type `T` must be an object type\n * 2. Do not allow dynamic property\n * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array types are allowed\n * 4. By the way, union type never be not allowed\n *\n * Also, `typia.http.formData()` function does not perform validation about the\n * decoded value. Therefore, if you can't sure that input data is following the\n * `T` type, it would better to call one of below functions intead.\n *\n * @template T Expected type of decoded value\n * @param input FormData instance\n * @returns Decoded form FormData\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction formData<T extends object>(input: FormData): Resolved<T>;\n\n/**\n * @internal\n */\nfunction formData(): never {\n  halt(\"formData\");\n}\nconst formDataPure = /** @__PURE__ */ Object.assign<typeof formData, {}>(\n  formData,\n  /** @__PURE__ */ Namespace.http.formData(),\n);\nexport { formDataPure as formData };\n\n/**\n * Form data decoder with type assertion.\n *\n * `typia.http.assertFormData()` is a function decoding `FormData` instance, with\n * automatic type casting to the expected type. When roperty type be defined\n * as `boolean` or `Blob` type, `typia.http.assertFormData()` will cast the value\n * to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.assertFormData()` performs type assertion to\n * the decoded value by combining with {@link assert} function. Therefore, when\n * the decoded value is not following the `T` type, {@link TypeGuardError} or\n * custom error generated by *errorFactory* would be thrown.\n *\n * By the way, as `FormData` is not enough to express complex data structures,\n * `typia.http.assertFormData()` function has some limitations. If target type `T`\n * is not following those restrictions, compilation errors would be occured.\n *\n * 1. Type `T` must be an object type\n * 2. Do not allow dynamic property\n * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array types are allowed\n * 4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input FormData instance\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded form FormData\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertFormData<T extends object>(\n  input: FormData,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertFormData(): never {\n  halt(\"assertFormData\");\n}\nconst assertFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof assertFormData,\n  {},\n  {}\n>(\n  assertFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.assert(\"http.assertFormData\"),\n);\nexport { assertFormDataPure as assertFormData };\n\n/**\n * Form data decoder with type checking.\n *\n * `typia.http.isFormData()` is a function decoding `FormData` instance, with\n * automatic type casting to the expected type. When roperty type be defined\n * as `boolean` or `Blob` type, `typia.http.isFormData()` will cast the value\n * to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.isFormData()` performs type checking to the\n * decoded value by combining with {@link is} function. Therefore, when the\n * decoded value is not following the `T` type, `null` value would be returned.\n *\n * By the way, as `FormData` is not enough to express complex data structures,\n * `typia.http.isFormData()` function has some limitations. If target type `T` is\n * not following those restrictions, compilation errors would be occured.\n *\n * 1. Type `T` must be an object type\n * 2. Do not allow dynamic property\n * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array types are allowed\n * 4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input FormData instance\n * @returns Decoded form FormData or `null` value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isFormData<T extends object>(input: FormData): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isFormData(): never {\n  halt(\"isFormData\");\n}\nconst isFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof isFormData,\n  {},\n  {}\n>(\n  isFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isFormDataPure as isFormData };\n\n/**\n * Form data decoder with type validation.\n *\n * `typia.http.validateFormData()` is a function decoding `FormData` instance,\n * with automatic type casting to the expected type. When roperty type be defined\n * as `boolean` or `Blob` type, `typia.http.validateFormData()` will cast the\n * value to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.validateFormData()` performs type validation\n * to the decoded value by combining with {@link validate} function. Therefore,\n * when the decoded value is not following the `T` type,\n * {@link IValidation.IFailure} would be returned. Otherwise,\n * x@xxxx IValidation.ISuccess} would be returned.\n *\n * By the way, as `FormData` is not enough to express complex data structures,\n * `typia.http.validateFormData()` function has some limitations. If target type\n * `T` is not following those restrictions, compilation errors would be occured.\n *\n * 1. Type `T` must be an object type\n * 2. Do not allow dynamic property\n * 3. Only `boolean`, `bigint`, `number`, `string`, `Blob`, `File` or their array types are allowed\n * 4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input FormData instance\n * @returns Validation result with decoded form FormData\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateFormData<T extends object>(\n  input: FormData,\n): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateFormData(): never {\n  halt(\"validateFormData\");\n}\nconst validateFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof validateFormData,\n  {},\n  {}\n>(\n  validateFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateFormDataPure as validateFormData };\n\n/* -----------------------------------------------------------\n    QUERY\n----------------------------------------------------------- */\n/**\n * URL query decoder.\n *\n * `typia.http.query()` is a function decoding a query string or an `URLSearchParams`\n * instance, with automatic type casting to the expected type. When property type be\n * defined as `boolean` or `number` type, `typia.http.query()` will cast the value to\n * the expected type when decoding.\n *\n * By the way, as URL query is not enough to express complex data structures,\n * `typia.http.query()` function has some limitations. If target type `T` is not\n * following those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  4. By the way, union type never be not allowed\n *\n * Also, `typia.http.query()` function does not perform validation about the decoded\n * value. Therefore, if you can't sure that input data is following the `T` type,\n * it would better to call one of below functions intead.\n *\n *  - {@link assertQuery}\n *  - {@link isQuery}\n *  - {@link validateQuery}\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Decoded query object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction query<T extends object>(input: string | URLSearchParams): Resolved<T>;\n\n/**\n * @internal\n */\nfunction query(): never {\n  halt(\"query\");\n}\nconst queryPure = /** @__PURE__ */ Object.assign<typeof query, {}>(\n  query,\n  /** @__PURE__ */ Namespace.http.query(),\n);\nexport { queryPure as query };\n\n/**\n * URL query decoder with type assertion.\n *\n * `typia.http.assertQuery()` is a function decoding a query string or an\n * `URLSearchParams` instance, with automatic type casting to the expected type.\n * When property type be defined as `boolean` or `number` type,\n * `typia.http.assertQuery()` will cast the value to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.assertQuery()` performs type assertion to the\n * decoded value by combining with {@link assert} function. Therefore, when the\n * decoded value is not following the `T` type, {@link TypeGuardError} or custom\n * error generated by *errorFactory* would be thrown.\n *\n * By the way, as URL query is not enough to express complex data structures,\n * `typia.http.assertQuery()` function has some limitations. If target type `T` is\n * notfollowing those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded query object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertQuery<T extends object>(\n  input: string | URLSearchParams,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertQuery(): never {\n  halt(\"assertQuery\");\n}\nconst assertQueryPure = /** @__PURE__ */ Object.assign<\n  typeof assertQuery,\n  {},\n  {}\n>(\n  assertQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.assert(\"http.assertQuery\"),\n);\nexport { assertQueryPure as assertQuery };\n\n/**\n * URL query decoder with type checking.\n *\n * `typia.http.isQuery()` is a function decoding a query string or an\n * `URLSearchParams` instance, with automatic type casting to the expected type.\n * When property type be defined as `boolean` or `number` type,\n * `typia.http.isQuery()` will cast the value to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.isQuery()` performs type checking to the\n * decoded value by combining with {@link is} function. Therefore, when the\n * decoded value is not following the `T` type, `null` value would be returned.\n *\n * By the way, as URL query is not enough to express complex data structures,\n * `typia.http.isQuery()` function has some limitations. If target type `T` is\n * notfollowing those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Decoded query object or `null` value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isQuery<T extends object>(\n  input: string | URLSearchParams,\n): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isQuery(): never {\n  halt(\"isQuery\");\n}\n\nconst isQueryPure = /** @__PURE__ */ Object.assign<typeof isQuery, {}, {}>(\n  isQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isQueryPure as isQuery };\n\n/**\n * URL query decoder with type validation.\n *\n * `typia.http.validateQuery()` is a function decoding a query string or an\n * `URLSearchParams` instance, with automatic type casting to the expected type.\n * When property type be defined as `boolean` or `number` type,\n * `typia.http.validateQuery()` will cast the value to the expected type when decoding.\n *\n * Also, after decoding, `typia.http.validateQuery()` performs type validation to the\n * decoded value by combining with {@link validate} function. Therefore, when the\n * decoded value is not following the `T` type, {@link IValidation.IFailure} would\n * be returned. Otherwise, {@link IValidation.ISuccess} would be returned.\n *\n * By the way, as URL query is not enough to express complex data structures,\n * `typia.http.validateQuery()` function has some limitations. If target type `T` is\n * notfollowing those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  4. By the way, union type never be not allowed\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Validation result with decoded query object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateQuery<T extends object>(\n  input: string | URLSearchParams,\n): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateQuery(): never {\n  halt(\"validateQuery\");\n}\nconst validateQueryPure = /** @__PURE__ */ Object.assign<\n  typeof validateQuery,\n  {},\n  {}\n>(\n  validateQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateQueryPure as validateQuery };\n\n/* -----------------------------------------------------------\n    HEADERS\n----------------------------------------------------------- */\n/**\n * Headers decoder (for express and fastify).\n *\n * `typia.http.headers()` is a function decoding an header instance, with automatic\n * type casting to the expected type. When property type be defined as `boolean` or\n * `number` type, `typia.http.headers()` will cast the value to the expected type.\n *\n * By the way, as HTTP headers are not enough to express complex data structures,\n * `typia.http.headers()` function has some limitations. If target type `T` is not\n * following those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Property key must be lower case\n *  4. Property value cannot be `null`, but `undefined` is possible\n *  5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  6. By the way, union type never be not allowed\n *  7. Property `set-cookie` must be array type\n *  8. Those properties cannot be array type\n *    - age\n *    - authorization\n *    - content-length\n *    - content-type\n *    - etag\n *    - expires\n *    - from\n *    - host\n *    - if-modified-since\n *    - if-unmodified-since\n *    - last-modified\n *    - location\n *    - max-forwards\n *    - proxy-authorization\n *    - referer\n *    - retry-after\n *    - server\n *    - user-agent\n *\n * Also, `typia.http.headers()` function does not perform validation about the decoded\n * value. Therefore, if you can't sure that input data is following the `T` type,\n * it would better to call one of below functions intead.\n *\n *  - {@link assertHeaders}\n *  - {@link isHeaders}\n *  - {@link validateHeaders}\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Decoded headers object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction headers<T extends object>(\n  input: Record<string, string | string[] | undefined>,\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction headers(): never {\n  halt(\"headers\");\n}\n\nconst headersPure = /** @__PURE__ */ Object.assign<typeof headers, {}>(\n  headers,\n  /** @__PURE__ */ Namespace.http.headers(),\n);\nexport { headersPure as headers };\n\n/**\n * Headers decoder with type assertion (for express and fastify).\n *\n * `typia.http.assertHeaders()` is a function decoding an header instance, with\n * automatic type casting to the expected type. When property type be defined as\n * `boolean` or `number` type, `typia.http.headers()` will cast the value to the\n * expected type.\n *\n * Also, after decoding, `typia.http.assertHeaders()` performs type assertion to the\n * decoded value by combining with {@link assert} function. Therefore, when the\n * decoded value is not following the `T` type, {@link TypeGuardError} or custom\n * error generated by *errorFactory* would be thrown.\n *\n * By the way, as HTTP headers are not enough to express complex data structures,\n * `typia.http.headers()` function has some limitations. If target type `T` is not\n * following those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Property key must be lower case\n *  4. Property value cannot be `null`, but `undefined` is possible\n *  5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  6. By the way, union type never be not allowed\n *  7. Property `set-cookie` must be array type\n *  8. Those properties cannot be array type\n *    - age\n *    - authorization\n *    - content-length\n *    - content-type\n *    - etag\n *    - expires\n *    - from\n *    - host\n *    - if-modified-since\n *    - if-unmodified-since\n *    - last-modified\n *    - location\n *    - max-forwards\n *    - proxy-authorization\n *    - referer\n *    - retry-after\n *    - server\n *    - user-agent\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded headers object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertHeaders<T extends object>(\n  input: Record<string, string | string[] | undefined>,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertHeaders(): never {\n  halt(\"assertHeaders\");\n}\n\nconst assertHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof assertHeaders,\n  {},\n  {}\n>(\n  assertHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.assert(\"http.assertHeaders\"),\n);\nexport { assertHeadersPure as assertHeaders };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Headers decoder with type checking (for express and fastify).\n *\n * `typia.http.isHeaders()` is a function decoding an header instance, with\n * automatic type casting to the expected type. When property type be defined as\n * `boolean` or `number` type, `typia.http.headers()` will cast the value to the\n * expected type.\n *\n * Also, after decoding, `typia.http.isHeaders()` performs type checking to the\n * decoded value by combining with {@link is} function. Therefore, when the\n * decoded value is not following the `T` type, `null` value would be returned.\n *\n * By the way, as HTTP headers are not enough to express complex data structures,\n * `typia.http.headers()` function has some limitations. If target type `T` is not\n * following those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Property key must be lower case\n *  4. Property value cannot be `null`, but `undefined` is possible\n *  5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  6. By the way, union type never be not allowed\n *  7. Property `set-cookie` must be array type\n *  8. Those properties cannot be array type\n *    - age\n *    - authorization\n *    - content-length\n *    - content-type\n *    - etag\n *    - expires\n *    - from\n *    - host\n *    - if-modified-since\n *    - if-unmodified-since\n *    - last-modified\n *    - location\n *    - max-forwards\n *    - proxy-authorization\n *    - referer\n *    - retry-after\n *    - server\n *    - user-agent\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Decoded headers object or `null` value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isHeaders<T extends object>(\n  input: Record<string, string | string[] | undefined>,\n): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isHeaders(): never {\n  halt(\"isHeaders\");\n}\nconst isHeadersPure = /** @__PURE__ */ Object.assign<typeof isHeaders, {}, {}>(\n  isHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isHeadersPure as isHeaders };\n\n/**\n * Headers decoder with type validation (for express and fastify).\n *\n * `typia.http.validateHeaders()` is a function decoding an header instance, with\n * automatic type casting to the expected type. When property type be defined as\n * `boolean` or `number` type, `typia.http.headers()` will cast the value to the\n * expected type.\n *\n * Also, after decoding, `typia.http.validateHeaders()` performs type assertion to the\n * decoded value by combining with {@link validate} function. Therefore, when the\n * decoded value is not following the `T` type, {@link IValidation.IError} would be\n * returned. Otherwise, {@link IValidation.ISuccess} be returned.\n *\n * By the way, as HTTP headers are not enough to express complex data structures,\n * `typia.http.headers()` function has some limitations. If target type `T` is not\n * following those restrictions, compilation errors would be occured.\n *\n *  1. Type `T` must be an object type\n *  2. Do not allow dynamic property\n *  3. Property key must be lower case\n *  4. Property value cannot be `null`, but `undefined` is possible\n *  5. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed\n *  6. By the way, union type never be not allowed\n *  7. Property `set-cookie` must be array type\n *  8. Those properties cannot be array type\n *    - age\n *    - authorization\n *    - content-length\n *    - content-type\n *    - etag\n *    - expires\n *    - from\n *    - host\n *    - if-modified-since\n *    - if-unmodified-since\n *    - last-modified\n *    - location\n *    - max-forwards\n *    - proxy-authorization\n *    - referer\n *    - retry-after\n *    - server\n *    - user-agent\n *\n * @template T Expected type of decoded value\n * @param input Query string or URLSearchParams instance\n * @returns Decoded headers object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateHeaders<T extends object>(\n  input: Record<string, string | string[] | undefined>,\n): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateHeaders(): never {\n  halt(\"validateHeaders\");\n}\n\nconst validateHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof validateHeaders,\n  {},\n  {}\n>(\n  validateHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateHeadersPure as validateHeaders };\n\n/* -----------------------------------------------------------\n    PARAMETER\n----------------------------------------------------------- */\n/**\n * URL path parameter decoder.\n *\n * `typia.http.parameter()` is a function decoding a path parameter, with automatic\n * type casting to the expected type. When type `T` has beeen defined as `boolean` or\n * `number` type, `typia.http.parameter()` will cast the value to the expected type.\n *\n * Also, `typia.http.parameter()` performs type assertion to the decoded value by\n * combining with {@link assert} function. Therefore, when the decoded value is not\n * following the `T` type, {@link TypeGuardError} would be thrown.\n *\n * @template T Expected type of decoded value\n * @param input Path parameter string\n * @returns Decoded path parameter value\n */\nfunction parameter<T extends Atomic.Type | null>(input: string): Resolved<T>;\n\n/**\n * @internal\n */\nfunction parameter(): never {\n  halt(\"parameter\");\n}\n\nconst parameterPure = /** @__PURE__ */ Object.assign<typeof parameter, {}, {}>(\n  parameter,\n  /** @__PURE__ */ Namespace.http.parameter(),\n  /** @__PURE__ */ Namespace.assert(\"http.parameter\"),\n);\nexport { parameterPure as parameter };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link formdata} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the formdata object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createFormData(): never;\n\n/**\n * Creates a reusable {@link formdata} function.\n *\n * @template T The type of the formdata object\n * @returns A reusable `formdata` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createFormData<T extends object>(): (input: FormData) => T;\n\n/**\n * @internal\n */\nfunction createFormData<T>(): (input: FormData) => T {\n  halt(\"createFormData\");\n}\n\nconst createFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof createFormData,\n  {}\n>(createFormData, /** @__PURE__ */ Namespace.http.formData());\nexport { createFormDataPure as createFormData };\n\n/**\n * Creates a reusable {@link assertFormData} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the formdata object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertFormData(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertFormData} function.\n *\n * @template T The type of the formdata object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertFormData` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertFormData<T extends object>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: FormData) => T;\n\n/**\n * @internal\n */\nfunction createAssertFormData<T>(): (input: FormData) => T {\n  halt(\"createAssertFormData\");\n}\n\nconst createAssertFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertFormData,\n  {},\n  {}\n>(\n  createAssertFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.assert(\"http.createAssertFormData\"),\n);\nexport { createAssertFormDataPure as createAssertFormData };\n\n/**\n * Creates a reusable {@link isFormData} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the formdata object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsFormData(): never;\n\n/**\n * Creates a reusable {@link isFormData} function.\n *\n * @template T The type of the formdata object\n * @returns A reusable `isFormData` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsFormData<T extends object>(): (input: FormData) => T | null;\n\n/**\n * @internal\n */\nfunction createIsFormData<T>(): (input: FormData) => T | null {\n  halt(\"createIsFormData\");\n}\n\nconst createIsFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof createIsFormData,\n  {},\n  {}\n>(\n  createIsFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsFormDataPure as createIsFormData };\n\n/**\n * Creates a reusable {@link validateFormData} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the formdata object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateFormData(): never;\n\n/**\n * Creates a reusable {@link validateFormData} function.\n *\n * @template T The type of the formdata object\n * @returns A reusable `validateFormData` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateFormData<T extends object>(): (\n  input: FormData,\n) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateFormData<T>(): (\n  input: FormData,\n) => IValidation<Resolved<T>> {\n  halt(\"createValidateFormData\");\n}\n\nconst createValidateFormDataPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateFormData,\n  {},\n  {}\n>(\n  createValidateFormData,\n  /** @__PURE__ */ Namespace.http.formData(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateFormDataPure as createValidateFormData };\n\n/**\n * Creates a reusable {@link query} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the query object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createQuery(): never;\n\n/**\n * Creates a reusable {@link query} function.\n *\n * @template T The type of the query object\n * @returns A reusable `query` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createQuery<T extends object>(): (\n  input: string | URLSearchParams,\n) => T;\n\n/**\n * @internal\n */\nfunction createQuery<T>(): (input: string | URLSearchParams) => T {\n  halt(\"createQuery\");\n}\n\nconst createQueryPure = /** @__PURE__ */ Object.assign<typeof createQuery, {}>(\n  createQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n);\nexport { createQueryPure as createQuery };\n\n/**\n * Creates a reusable {@link assertQuery} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the query object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertQuery(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertQuery} function.\n *\n * @template T The type of the query object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertQuery` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertQuery<T extends object>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: string | URLSearchParams) => T;\n\n/**\n * @internal\n */\nfunction createAssertQuery<T>(): (input: string | URLSearchParams) => T {\n  halt(\"createAssertQuery\");\n}\n\nconst createAssertQueryPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertQuery,\n  {},\n  {}\n>(\n  createAssertQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.assert(\"http.createAssertQuery\"),\n);\nexport { createAssertQueryPure as createAssertQuery };\n\n/**\n * Creates a reusable {@link isQuery} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the query object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsQuery(): never;\n\n/**\n * Creates a reusable {@link isQuery} function.\n *\n * @template T The type of the query object\n * @returns A reusable `isQuery` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsQuery<T extends object>(): (\n  input: string | URLSearchParams,\n) => T | null;\n\n/**\n * @internal\n */\nfunction createIsQuery<T>(): (input: string | URLSearchParams) => T | null {\n  halt(\"createIsQuery\");\n}\n\nconst createIsQueryPure = /** @__PURE__ */ Object.assign<\n  typeof createIsQuery,\n  {},\n  {}\n>(\n  createIsQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsQueryPure as createIsQuery };\n\n/**\n * Creates a reusable {@link validateQuery} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the query object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateQuery(): never;\n\n/**\n * Creates a reusable {@link validateQuery} function.\n *\n * @template T The type of the query object\n * @returns A reusable `validateQuery` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateQuery<T extends object>(): (\n  input: string | URLSearchParams,\n) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateQuery<T>(): (\n  input: string | URLSearchParams,\n) => IValidation<Resolved<T>> {\n  halt(\"createValidateQuery\");\n}\n\nconst createValidateQueryPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateQuery,\n  {},\n  {}\n>(\n  createValidateQuery,\n  /** @__PURE__ */ Namespace.http.query(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateQueryPure as createValidateQuery };\n\n/**\n * Creates a reusable {@link headers} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the headers object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createHeaders(): never;\n\n/**\n * Creates a reusable {@link headers} function.\n *\n * @template T The type of the headers object\n * @returns A reusable `headers` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createHeaders<T extends object>(): (\n  input: Record<string, string | string[] | undefined>,\n) => T;\n\n/**\n * @internal\n */\nfunction createHeaders<T>(): (\n  input: Record<string, string | string[] | undefined>,\n) => T {\n  halt(\"createHeaders\");\n}\n\nconst createHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof createHeaders,\n  {}\n>(createHeaders, /** @__PURE__ */ Namespace.http.headers());\nexport { createHeadersPure as createHeaders };\n\n/**\n * Creates a reusable {@link assertHeaders} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the headers object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertHeaders(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertHeaders} function.\n *\n * @template T The type of the headers object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertHeaders` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertHeaders<T extends object>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: Record<string, string | string[] | undefined>) => T;\n\n/**\n * @internal\n */\nfunction createAssertHeaders<T>(): (\n  input: Record<string, string | string[] | undefined>,\n) => T {\n  halt(\"createAssertHeaders\");\n}\n\nconst createAssertHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertHeaders,\n  {},\n  {}\n>(\n  createAssertHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.assert(\"http.createAssertHeaders\"),\n);\nexport { createAssertHeadersPure as createAssertHeaders };\n\n/**\n * Creates a reusable {@link isHeaders} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the headers object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsHeaders(): never;\n\n/**\n * Creates a reusable {@link isHeaders} function.\n *\n * @template T The type of the headers object\n * @returns A reusable `isHeaders` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsHeaders<T extends object>(): (\n  input: Record<string, string | string[] | undefined>,\n) => T | null;\n\n/**\n * @internal\n */\nfunction createIsHeaders<T>(): (\n  input: Record<string, string | string[] | undefined>,\n) => T | null {\n  halt(\"createIsHeaders\");\n}\n\nconst createIsHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof createIsHeaders,\n  {},\n  {}\n>(\n  createIsHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsHeadersPure as createIsHeaders };\n\n/**\n * Creates a reusable {@link validateHeaders} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the headers object\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateHeaders(): never;\n\n/**\n * Creates a reusable {@link validateHeaders} function.\n *\n * @template T The type of the headers object\n * @returns A reusable `validateHeaders` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateHeaders<T extends object>(): (\n  input: Record<string, string | string[] | undefined>,\n) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateHeaders<T>(): (\n  input: Record<string, string | string[] | undefined>,\n) => IValidation<Resolved<T>> {\n  halt(\"createValidateHeaders\");\n}\n\nconst createValidateHeadersPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateHeaders,\n  {},\n  {}\n>(\n  createValidateHeaders,\n  /** @__PURE__ */ Namespace.http.headers(),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateHeadersPure as createValidateHeaders };\n\n/**\n * Creates a reusable {@link parameter} function.\n *\n * @danger You must configure the generic argument `T`\n * @template T The type of the parameter value\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createParameter(): never;\n\n/**\n * Creates a reusable {@link parameter} function.\n *\n * @template T The type of the parameter value\n * @returns A reusable `parameter` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createParameter<T extends Atomic.Type | null>(): (input: string) => T;\n\n/**\n * @internal\n */\nfunction createParameter<T extends Atomic.Type | null>(): (input: string) => T {\n  halt(\"createParameter\");\n}\n\nconst createParameterPure = /** @__PURE__ */ Object.assign<\n  typeof createParameter,\n  {},\n  {}\n>(\n  createParameter,\n  /** @__PURE__ */ Namespace.http.parameter(),\n  /** @__PURE__ */ Namespace.assert(\"http.createParameter\"),\n);\nexport { createParameterPure as createParameter };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.http.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAAA,gBAAA;SAAAA,eAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,SAASC,WAAAA;AACPC,OAAK,UAAA;AACP;AAFSD;AAGT,IAAME,eAAgCC,uBAAOC,OAC3CJ,UACiBK,gBAAUC,aAAKN,SAAQ,CAAA;AAyC1C,SAASO,iBAAAA;AACPC,OAAK,gBAAA;AACP;AAFSD;AAGT,IAAME,qBAAsCC,uBAAOC,OAKjDJ,gBACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,OAAO,qBAAA,CAAA;AAoCpC,SAASC,aAAAA;AACPC,OAAK,YAAA;AACP;AAFSD;AAGT,IAAME,iBAAkCC,uBAAOC,OAK7CJ,YACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,GAAE,CAAA;AAwC/B,SAASC,mBAAAA;AACPC,OAAK,kBAAA;AACP;AAFSD;AAGT,IAAME,uBAAwCC,uBAAOC,OAKnDJ,kBACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,SAAQ,CAAA;AA2CrC,SAASC,QAAAA;AACPC,OAAK,OAAA;AACP;AAFSD;AAGT,IAAME,YAA6BC,uBAAOC,OACxCJ,OACiBK,gBAAUC,aAAKN,MAAK,CAAA;AAyCvC,SAASO,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAGT,IAAME,kBAAmCC,uBAAOC,OAK9CJ,aACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,OAAO,kBAAA,CAAA;AAsCpC,SAASC,UAAAA;AACPC,OAAK,SAAA;AACP;AAFSD;AAIT,IAAME,cAA+BC,uBAAOC,OAC1CJ,SACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,GAAE,CAAA;AAuC/B,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAGT,IAAME,oBAAqCC,uBAAOC,OAKhDJ,eACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,SAAQ,CAAA;AAkErC,SAASC,UAAAA;AACPC,OAAK,SAAA;AACP;AAFSD;AAIT,IAAME,cAA+BC,uBAAOC,OAC1CJ,SACiBK,gBAAUC,aAAKN,QAAO,CAAA;AA+DzC,SAASO,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAIT,IAAME,oBAAqCC,uBAAOC,OAKhDJ,eACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,OAAO,oBAAA,CAAA;AA8DpC,SAASC,YAAAA;AACPC,OAAK,WAAA;AACP;AAFSD;AAGT,IAAME,gBAAiCC,uBAAOC,OAC5CJ,WACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,GAAE,CAAA;AA6D/B,SAASC,kBAAAA;AACPC,OAAK,iBAAA;AACP;AAFSD;AAIT,IAAME,sBAAuCC,uBAAOC,OAKlDJ,iBACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,SAAQ,CAAA;AA2BrC,SAASC,YAAAA;AACPC,OAAK,WAAA;AACP;AAFSD;AAIT,IAAME,gBAAiCC,uBAAOC,OAC5CJ,WACiBK,gBAAUC,aAAKN,UAAS,GACxBK,gBAAUE,OAAO,gBAAA,CAAA;AA+BpC,SAASC,iBAAAA;AACPC,OAAK,gBAAA;AACP;AAFSD;AAIT,IAAME,qBAAsCC,uBAAOC,OAGjDJ,gBAAiCK,gBAAUC,aAAKC,SAAQ,CAAA;AAiC1D,SAASC,uBAAAA;AACPC,OAAK,sBAAA;AACP;AAFSD;AAIT,IAAME,2BAA4CC,uBAAOC,OAKvDJ,sBACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,OAAO,2BAAA,CAAA;AA4BpC,SAASC,mBAAAA;AACPC,OAAK,kBAAA;AACP;AAFSD;AAIT,IAAME,uBAAwCC,uBAAOC,OAKnDJ,kBACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,GAAE,CAAA;AA8B/B,SAASC,yBAAAA;AAGPC,OAAK,wBAAA;AACP;AAJSD;AAMT,IAAME,6BAA8CC,uBAAOC,OAKzDJ,wBACiBK,gBAAUC,aAAKC,SAAQ,GACvBF,gBAAUG,SAAQ,CAAA;AA8BrC,SAASC,cAAAA;AACPC,OAAK,aAAA;AACP;AAFSD;AAIT,IAAME,kBAAmCC,uBAAOC,OAC9CJ,aACiBK,gBAAUC,aAAKC,MAAK,CAAA;AAkCvC,SAASC,oBAAAA;AACPC,OAAK,mBAAA;AACP;AAFSD;AAIT,IAAME,wBAAyCC,uBAAOC,OAKpDJ,mBACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,OAAO,wBAAA,CAAA;AA8BpC,SAASC,gBAAAA;AACPC,OAAK,eAAA;AACP;AAFSD;AAIT,IAAME,oBAAqCC,uBAAOC,OAKhDJ,eACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,GAAE,CAAA;AA8B/B,SAASC,sBAAAA;AAGPC,OAAK,qBAAA;AACP;AAJSD;AAMT,IAAME,0BAA2CC,uBAAOC,OAKtDJ,qBACiBK,gBAAUC,aAAKC,MAAK,GACpBF,gBAAUG,SAAQ,CAAA;AA8BrC,SAASC,gBAAAA;AAGPC,OAAK,eAAA;AACP;AAJSD;AAMT,IAAME,oBAAqCC,uBAAOC,OAGhDJ,eAAgCK,gBAAUC,aAAKC,QAAO,CAAA;AAiCxD,SAASC,sBAAAA;AAGPC,OAAK,qBAAA;AACP;AAJSD;AAMT,IAAME,0BAA2CC,uBAAOC,OAKtDJ,qBACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,OAAO,0BAAA,CAAA;AA8BpC,SAASC,kBAAAA;AAGPC,OAAK,iBAAA;AACP;AAJSD;AAMT,IAAME,sBAAuCC,uBAAOC,OAKlDJ,iBACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,GAAE,CAAA;AA8B/B,SAASC,wBAAAA;AAGPC,OAAK,uBAAA;AACP;AAJSD;AAMT,IAAME,4BAA6CC,uBAAOC,OAKxDJ,uBACiBK,gBAAUC,aAAKC,QAAO,GACtBF,gBAAUG,SAAQ,CAAA;AA4BrC,SAASC,kBAAAA;AACPC,OAAK,iBAAA;AACP;AAFSD;AAIT,IAAME,sBAAuCC,uBAAOC,OAKlDJ,iBACiBK,gBAAUC,aAAKC,UAAS,GACxBF,gBAAUG,OAAO,sBAAA,CAAA;AAOpC,SAASC,KAAKC,MAAY;AACxB,QAAM,IAAIC,MACR,uBAAuBD,IAAAA,2FAA+F;AAE1H;AAJSD;","names":["http_exports","formData","halt","formDataPure","Object","assign","Namespace","http","assertFormData","halt","assertFormDataPure","Object","assign","Namespace","http","formData","assert","isFormData","halt","isFormDataPure","Object","assign","Namespace","http","formData","is","validateFormData","halt","validateFormDataPure","Object","assign","Namespace","http","formData","validate","query","halt","queryPure","Object","assign","Namespace","http","assertQuery","halt","assertQueryPure","Object","assign","Namespace","http","query","assert","isQuery","halt","isQueryPure","Object","assign","Namespace","http","query","is","validateQuery","halt","validateQueryPure","Object","assign","Namespace","http","query","validate","headers","halt","headersPure","Object","assign","Namespace","http","assertHeaders","halt","assertHeadersPure","Object","assign","Namespace","http","headers","assert","isHeaders","halt","isHeadersPure","Object","assign","Namespace","http","headers","is","validateHeaders","halt","validateHeadersPure","Object","assign","Namespace","http","headers","validate","parameter","halt","parameterPure","Object","assign","Namespace","http","assert","createFormData","halt","createFormDataPure","Object","assign","Namespace","http","formData","createAssertFormData","halt","createAssertFormDataPure","Object","assign","Namespace","http","formData","assert","createIsFormData","halt","createIsFormDataPure","Object","assign","Namespace","http","formData","is","createValidateFormData","halt","createValidateFormDataPure","Object","assign","Namespace","http","formData","validate","createQuery","halt","createQueryPure","Object","assign","Namespace","http","query","createAssertQuery","halt","createAssertQueryPure","Object","assign","Namespace","http","query","assert","createIsQuery","halt","createIsQueryPure","Object","assign","Namespace","http","query","is","createValidateQuery","halt","createValidateQueryPure","Object","assign","Namespace","http","query","validate","createHeaders","halt","createHeadersPure","Object","assign","Namespace","http","headers","createAssertHeaders","halt","createAssertHeadersPure","Object","assign","Namespace","http","headers","assert","createIsHeaders","halt","createIsHeadersPure","Object","assign","Namespace","http","headers","is","createValidateHeaders","halt","createValidateHeadersPure","Object","assign","Namespace","http","headers","validate","createParameter","halt","createParameterPure","Object","assign","Namespace","http","parameter","assert","halt","name","Error"]}