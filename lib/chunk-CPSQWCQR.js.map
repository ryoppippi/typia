{"version":3,"sources":["../src/programmers/functional/FunctionalIsParametersProgrammer.ts","../src/programmers/functional/FunctionalIsFunctionProgrammer.ts","../src/programmers/functional/FunctionalIsReturnProgrammer.ts"],"names":["ts","FunctionalIsReturnProgrammer","write","project","modulo","equals","expression","declaration","async","statements","writeStatements","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","FunctionalIsFunctionProgrammer","getReturnTypeNode","createBlock","type","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","name","getText","StringUtil","escapeDuplicate","StatementFactory","constant","createAwaitExpression","createReturnStatement","createConditionalExpression","IsProgrammer","createNull","FunctionalIsParametersProgrammer","typeArguments","createTypeReferenceNode","createUnionTypeNode","createIfStatement","createStrictEquality","createFalse","getTypeFromTypeNode","TypeFactory","keyword","flat"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionalIsFunctionProgrammer } from \"./FunctionalIsFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalIsParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalIsFunctionProgrammer.getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...writeStatements(project)(modulo)(equals)(declaration),\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                expression,\n                undefined,\n                declaration.parameters.map((p) =>\n                  ts.factory.createIdentifier(p.name.getText()),\n                ),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (declaration: ts.FunctionDeclaration): ts.Statement[] =>\n      declaration.parameters\n        .map((p) => [\n          ts.factory.createIfStatement(\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createCallExpression(\n                IsProgrammer.write(project)(modulo)(equals)(\n                  project.checker.getTypeFromTypeNode(\n                    p.type ?? TypeFactory.keyword(\"any\"),\n                  ),\n                ),\n                undefined,\n                [ts.factory.createIdentifier(p.name.getText())],\n              ),\n            ),\n            ts.factory.createReturnStatement(ts.factory.createNull()),\n          ),\n        ])\n        .flat();\n}\n","import ts from \"typescript\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionalIsParametersProgrammer } from \"./FunctionalIsParametersProgrammer\";\nimport { FunctionalIsReturnProgrammer } from \"./FunctionalIsReturnProgrammer\";\n\nexport namespace FunctionalIsFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } =\n        FunctionalIsReturnProgrammer.writeStatements(project)(modulo)(equals)(\n          expression,\n          declaration,\n        );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...FunctionalIsParametersProgrammer.writeStatements(project)(\n              modulo,\n            )(equals)(declaration),\n            ...statements,\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const getReturnTypeNode = (\n    declaration: ts.FunctionDeclaration,\n    async: boolean,\n  ): ts.TypeNode | undefined =>\n    declaration.type\n      ? async\n        ? !!(declaration.type! as ts.TypeReferenceNode).typeArguments?.[0]\n          ? ts.factory.createTypeReferenceNode(\"Promise\", [\n              ts.factory.createUnionTypeNode([\n                (declaration.type! as ts.TypeReferenceNode).typeArguments![0]!,\n                ts.factory.createTypeReferenceNode(\"null\"),\n              ]),\n            ])\n          : undefined\n        : ts.factory.createUnionTypeNode([\n            declaration.type,\n            ts.factory.createTypeReferenceNode(\"null\"),\n          ])\n      : undefined;\n}\n","import ts from \"typescript\";\n\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionalIsFunctionProgrammer } from \"./FunctionalIsFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalIsReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } = writeStatements(project)(modulo)(equals)(\n        expression,\n        declaration,\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalIsFunctionProgrammer.getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(statements, true),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): {\n      async: boolean;\n      statements: ts.Statement[];\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n\n      const name: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"result\");\n      const statements: ts.Statement[] = [\n        StatementFactory.constant(\n          name,\n          async ? ts.factory.createAwaitExpression(caller) : caller,\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createConditionalExpression(\n            ts.factory.createCallExpression(\n              IsProgrammer.write(project)(modulo)(equals)(type),\n              undefined,\n              [ts.factory.createIdentifier(name)],\n            ),\n            undefined,\n            ts.factory.createIdentifier(name),\n            undefined,\n            ts.factory.createNull(),\n          ),\n        ),\n      ];\n      return { async, statements };\n    };\n}\n"]}