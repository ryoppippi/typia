{"version":3,"sources":["../src/programmers/helpers/StringifyJoinder.ts"],"names":["ts","StringifyJoiner","object","importer","_input","entries","length","factory","createStringLiteral","regular","filter","entry","key","isSoleLiteral","dynamic","expressions","stringify_regular_properties","stringify_dynamic_properties","map","r","getSoleLiteral","filtered","meta","isRequired","createCallExpression","use","undefined","TemplateFactory","generate","array","input","arrow","createPropertyAccessExpression","IdentifierFactory","access","createIdentifier","tuple","children","rest","every","child","isStringLiteral","text","join","elements","forEach","i","push"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,QAAQ;;UAUEC,kBAAAA;mBACFC,SACX,CAACC,aACD,CACEC,QACAC,YAAAA;AAGA,QAAIA,QAAQC,WAAW,EAAG,QAAON,GAAGO,QAAQC,oBAAoB,IAAA;AAGhE,UAAMC,UAA6CJ,QAAQK,OACzD,CAACC,UAAUA,MAAMC,IAAIC,cAAa,CAAA;AAEpC,UAAMC,UAA6CT,QAAQK,OACzD,CAACC,UAAU,CAACA,MAAMC,IAAIC,cAAa,CAAA;AAErC,UAAME,cAA+B;SAChCC,6BAA6BP,SAASK,OAAAA;SACrCA,QAAQR,SACR;QACEW,6BACEH,SACAL,QAAQS,IAAI,CAACC,MAAMA,EAAEP,IAAIQ,eAAc,CAAA,CAAA;UAG3C,CAAA;;AAIN,UAAMC,WACHZ,QAAQH,UACPG,QAAQA,QAAQH,SAAS,CAAA,EAAIgB,KAAKC,WAAU,KAC5CT,QAAQR,WAAW,KACpBG,QAAQH,WAAW,KAAKQ,QAAQR,SAC7BS,cACA;MACEf,GAAGO,QAAQiB,qBAAqBrB,SAASsB,IAAI,MAAA,GAASC,QAAW;QAC/DC,gBAAgBC,SAASb,WAAAA;OAC1B;;AAIT,WAAOY,gBAAgBC,SAAS;MAC9B5B,GAAGO,QAAQC,oBAAoB,GAAG;SAC/Ba;MACHrB,GAAGO,QAAQC,oBAAoB,GAAG;KACnC;EACH;mBAEWqB,QAAQ,CACnBC,OACAC,UAEAJ,gBAAgBC,SAAS;IACvB5B,GAAGO,QAAQC,oBAAoB,GAAG;IAClCR,GAAGO,QAAQiB,qBACTxB,GAAGO,QAAQyB,+BACThC,GAAGO,QAAQiB,qBACTS,kBAAkBC,OAAOJ,KAAAA,EAAO,KAAA,GAChCJ,QACA;MAACK;KAAM,GAET/B,GAAGO,QAAQ4B,iBAAiB,MAAA,CAAA,GAE9BT,QACA;MAAC1B,GAAGO,QAAQC,oBAAoB,GAAG;KAAE;IAEvCR,GAAGO,QAAQC,oBAAoB,GAAG;GACnC;mBAEU4B,QAAQ,CACnBC,UACAC,SAAAA;AAEA,QAAID,SAAS/B,WAAW,EAAG,QAAON,GAAGO,QAAQC,oBAAoB,IAAA;AACjE,QAAI8B,SAAS,QAAQD,SAASE,MAAM,CAACC,UAAUxC,GAAGyC,gBAAgBD,KAAAA,CAAAA,EAChE,QAAOxC,GAAGO,QAAQC,oBAChB,MACE6B,SAASnB,IAAI,CAACsB,UAAWA,MAA2BE,IAAI,EAAEC,KAAK,GAAA,IAC/D,GAAA;AAGN,UAAMC,WAA4B;MAAC5C,GAAGO,QAAQC,oBAAoB,GAAG;;AACrE6B,aAASQ,QAAQ,CAACL,OAAOM,MAAAA;AACvBF,eAASG,KAAKP,KAAAA;AACd,UAAIM,MAAMT,SAAS/B,SAAS,EAC1BsC,UAASG,KAAK/C,GAAGO,QAAQC,oBAAoB,GAAG,CAAA;IACpD,CAAA;AACA,QAAI8B,SAAS,KAAMM,UAASG,KAAKT,IAAAA;AAEjCM,aAASG,KAAK/C,GAAGO,QAAQC,oBAAoB,GAAG,CAAA;AAChD,WAAOmB,gBAAgBC,SAASgB,QAAAA;EAClC;AACF,GA9FiB3C,oBAAAA,kBAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { TemplateFactory } from \"../../factories/TemplateFactory\";\n\nimport { stringify_dynamic_properties } from \"../internal/stringify_dynamic_properties\";\nimport { stringify_regular_properties } from \"../internal/stringify_regular_properties\";\nimport { FunctionImporter } from \"./FunctionImporter\";\nimport { IExpressionEntry } from \"./IExpressionEntry\";\n\nexport namespace StringifyJoiner {\n  export const object =\n    (importer: FunctionImporter) =>\n    (\n      _input: ts.Expression,\n      entries: IExpressionEntry<ts.Expression>[],\n    ): ts.Expression => {\n      // CHECK AND SORT ENTRIES\n      if (entries.length === 0) return ts.factory.createStringLiteral(\"{}\");\n\n      // PROPERTIES\n      const regular: IExpressionEntry<ts.Expression>[] = entries.filter(\n        (entry) => entry.key.isSoleLiteral(),\n      );\n      const dynamic: IExpressionEntry<ts.Expression>[] = entries.filter(\n        (entry) => !entry.key.isSoleLiteral(),\n      );\n      const expressions: ts.Expression[] = [\n        ...stringify_regular_properties(regular, dynamic),\n        ...(dynamic.length\n          ? [\n              stringify_dynamic_properties(\n                dynamic,\n                regular.map((r) => r.key.getSoleLiteral()!),\n              ),\n            ]\n          : []),\n      ];\n\n      // POP LAST COMMA, IF REQUIRED\n      const filtered: ts.Expression[] =\n        (regular.length &&\n          regular[regular.length - 1]!.meta.isRequired() &&\n          dynamic.length === 0) ||\n        (regular.length === 0 && dynamic.length)\n          ? expressions\n          : [\n              ts.factory.createCallExpression(importer.use(\"tail\"), undefined, [\n                TemplateFactory.generate(expressions),\n              ]),\n            ];\n\n      // RETURNS WITH OBJECT BRACKET\n      return TemplateFactory.generate([\n        ts.factory.createStringLiteral(`{`),\n        ...filtered,\n        ts.factory.createStringLiteral(`}`),\n      ]);\n    };\n\n  export const array = (\n    input: ts.Expression,\n    arrow: ts.ArrowFunction,\n  ): ts.Expression =>\n    TemplateFactory.generate([\n      ts.factory.createStringLiteral(`[`),\n      ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"map\"),\n            undefined,\n            [arrow],\n          ),\n          ts.factory.createIdentifier(\"join\"),\n        ),\n        undefined,\n        [ts.factory.createStringLiteral(`,`)],\n      ),\n      ts.factory.createStringLiteral(`]`),\n    ]);\n\n  export const tuple = (\n    children: ts.Expression[],\n    rest: ts.Expression | null,\n  ): ts.Expression => {\n    if (children.length === 0) return ts.factory.createStringLiteral(\"[]\");\n    if (rest === null && children.every((child) => ts.isStringLiteral(child)))\n      return ts.factory.createStringLiteral(\n        \"[\" +\n          children.map((child) => (child as ts.StringLiteral).text).join(\",\") +\n          \"]\",\n      );\n\n    const elements: ts.Expression[] = [ts.factory.createStringLiteral(`[`)];\n    children.forEach((child, i) => {\n      elements.push(child);\n      if (i !== children.length - 1)\n        elements.push(ts.factory.createStringLiteral(`,`));\n    });\n    if (rest !== null) elements.push(rest);\n\n    elements.push(ts.factory.createStringLiteral(`]`));\n    return TemplateFactory.generate(elements);\n  };\n}\n"]}