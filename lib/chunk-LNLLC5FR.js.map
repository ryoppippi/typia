{"version":3,"sources":["../src/factories/internal/metadata/iterate_metadata_sort.ts"],"names":["iterate_metadata_sort","collection","meta","visited","Set","array","arrays","iterate","value","tuple","tuples","element","elements","object","objects","property","properties","has","add","map","maps","set","sets","escaped","returns","rest","length","sort","x","y","MetadataObject","covers","union_index","getUnionIndex","Metadata","type","xt","initialize","yt","push","constant","constants","values","a","b","_b"],"mappings":";;;;;;;;;;;AAKO,IAAMA,wBACX,wBAACC,eAAmC,CAACC,SAAAA;AACnC,QAAMC,UAAyB,oBAAIC,IAAAA;AACnC,aAAWC,SAASJ,WAAWK,OAAM,EACnCC,SAAQJ,OAAAA,EAASF,UAAAA,EAAYI,MAAMG,KAAK;AAC1C,aAAWC,SAASR,WAAWS,OAAM,EACnC,YAAWC,WAAWF,MAAMG,SAC1BL,SAAQJ,OAAAA,EAASF,UAAAA,EAAYU,OAAAA;AACjC,aAAWE,UAAUZ,WAAWa,QAAO,EACrC,YAAWC,YAAYF,OAAOG,WAC5BT,SAAQJ,OAAAA,EAASF,UAAAA,EAAYc,SAASP,KAAK;AAC/CD,UAAQJ,OAAAA,EAASF,UAAAA,EAAYC,IAAAA;AAC/B,GAXA;AAaF,IAAMK,UACJ,wBAACJ,YACD,CAACF,eACD,CAACC,SAAAA;AACC,MAAIC,QAAQc,IAAIf,IAAAA,EAAO;AACvBC,UAAQe,IAAIhB,IAAAA;AAGZ,aAAWiB,OAAOjB,KAAKkB,KAAMb,SAAQJ,OAAAA,EAASF,UAAAA,EAAYkB,IAAIX,KAAK;AACnE,aAAWa,OAAOnB,KAAKoB,KAAMf,SAAQJ,OAAAA,EAASF,UAAAA,EAAYoB,GAAAA;AAC1D,MAAInB,KAAKqB,YAAY,KACnBhB,SAAQJ,OAAAA,EAASF,UAAAA,EAAYC,KAAKqB,QAAQC,OAAO;AACnD,MAAItB,KAAKuB,SAAS,KAAMlB,SAAQJ,OAAAA,EAASF,UAAAA,EAAYC,KAAKuB,IAAI;AAG9D,MAAIvB,KAAKY,QAAQY,SAAS,GAAG;AAC3BxB,SAAKY,QAAQa,KAAK,CAACC,GAAGC,MACpBC,eAAeC,OAAOH,GAAGC,CAAAA,IAAK,KAAKC,eAAeC,OAAOF,GAAGD,CAAAA,IAAK,IAAI,CAAA;AAEvE1B,SAAK8B,cAAc/B,WAAWgC,cAAc/B,IAAAA;EAC9C;AAGA,MAAIA,KAAKI,OAAOoB,SAAS,EACvBxB,MAAKI,OAAOqB,KAAK,CAACC,GAAGC,MACnBK,SAASH,OAAOH,EAAEO,KAAK3B,OAAOqB,EAAEM,KAAK3B,KAAK,IACtC,KACA0B,SAASH,OAAOF,EAAEM,KAAK3B,OAAOoB,EAAEO,KAAK3B,KAAK,IACxC,IACA,CAAA;AAEV,MAAIN,KAAKQ,OAAOgB,SAAS,EACvBxB,MAAKQ,OAAOiB,KAAK,CAACC,GAAGC,MAAAA;AACnB,UAAMO,KAAKF,SAASG,WAAU;AAC9B,UAAMC,KAAKJ,SAASG,WAAU;AAE9BD,OAAG1B,OAAO6B,KAAKX,CAAAA;AACfU,OAAG5B,OAAO6B,KAAKV,CAAAA;AAEf,WAAOK,SAASH,OAAOK,IAAIE,EAAAA,IAAM,KAAKJ,SAASH,OAAOO,IAAIF,EAAAA,IAAM,IAAI;EACtE,CAAA;AAGF,aAAWI,YAAYtC,KAAKuC,UAC1B,KAAID,SAASL,SAAS,SAAUK,UAASE,OAAOf,KAAI;WAC3Ca,SAASL,SAAS,SACzBK,UAASE,OAAOf,KACd,CAACgB,GAAGC,MAAOD,EAAEnC,QAAoBoC,EAAEpC,KAAK;WAEnCgC,SAASL,SAAS,SACzBK,UAASE,OAAOf,KAAK,CAACgB,GAAGC,MACtBD,EAAEnC,QAAoBoC,EAAEpC,QAAmB,KAAK,CAAA;MAEhDgC,UAASE,OAAOf,KAAK,CAACgB,GAAGE,OAAQF,EAAEnC,UAAU,QAAQ,KAAK,CAAA;AACnE,GArDA","sourcesContent":["import { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../../schemas/metadata/MetadataObject\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\n\nexport const iterate_metadata_sort =\n  (collection: MetadataCollection) => (meta: Metadata) => {\n    const visited: Set<Metadata> = new Set();\n    for (const array of collection.arrays())\n      iterate(visited)(collection)(array.value);\n    for (const tuple of collection.tuples())\n      for (const element of tuple.elements)\n        iterate(visited)(collection)(element);\n    for (const object of collection.objects())\n      for (const property of object.properties)\n        iterate(visited)(collection)(property.value);\n    iterate(visited)(collection)(meta);\n  };\n\nconst iterate =\n  (visited: Set<Metadata>) =>\n  (collection: MetadataCollection) =>\n  (meta: Metadata) => {\n    if (visited.has(meta)) return;\n    visited.add(meta);\n\n    // ITERATE CHILDREN\n    for (const map of meta.maps) iterate(visited)(collection)(map.value);\n    for (const set of meta.sets) iterate(visited)(collection)(set);\n    if (meta.escaped !== null)\n      iterate(visited)(collection)(meta.escaped.returns);\n    if (meta.rest !== null) iterate(visited)(collection)(meta.rest);\n\n    // SORT OBJECTS\n    if (meta.objects.length > 1) {\n      meta.objects.sort((x, y) =>\n        MetadataObject.covers(x, y) ? -1 : MetadataObject.covers(y, x) ? 1 : 0,\n      );\n      meta.union_index = collection.getUnionIndex(meta);\n    }\n\n    // SORT ARRAYS AND TUPLES\n    if (meta.arrays.length > 1)\n      meta.arrays.sort((x, y) =>\n        Metadata.covers(x.type.value, y.type.value)\n          ? -1\n          : Metadata.covers(y.type.value, x.type.value)\n            ? 1\n            : 0,\n      );\n    if (meta.tuples.length > 1)\n      meta.tuples.sort((x, y) => {\n        const xt = Metadata.initialize();\n        const yt = Metadata.initialize();\n\n        xt.tuples.push(x);\n        yt.tuples.push(y);\n\n        return Metadata.covers(xt, yt) ? -1 : Metadata.covers(yt, xt) ? 1 : 0;\n      });\n\n    // SORT CONSTANT VALUES\n    for (const constant of meta.constants)\n      if (constant.type === \"string\") constant.values.sort();\n      else if (constant.type === \"number\")\n        constant.values.sort(\n          (a, b) => (a.value as number) - (b.value as number),\n        );\n      else if (constant.type === \"bigint\")\n        constant.values.sort((a, b) =>\n          (a.value as bigint) < (b.value as bigint) ? -1 : 1,\n        );\n      else constant.values.sort((a, _b) => (a.value === false ? -1 : 1));\n  };\n"]}