{"version":3,"sources":["../src/programmers/RandomProgrammer.ts"],"names":["ts","RandomProgrammer","write","project","modulo","init","importer","FunctionImporter","getText","type","name","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","meta","output","natives","some","n","push","success","TransformerError","from","method","errors","functions","objects","write_object_functions","arrays","write_array_functions","tuples","write_tuple_functions","decode","function","recursive","data","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createToken","SyntaxKind","QuestionToken","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","createReturnStatement","map","obj","i","StatementFactory","PREFIX","object","keyword","String","ExpressionFactory","number","RandomJoiner","COALESCE","filter","a","array","createTrue","value","tuple","elements","explore","expressions","any","isRequired","functional","nullable","createNull","constants","values","decode_atomic","template","templates","decode_template","atomic","atomics","decode_boolean","decode_number","decode_string","decode_bigint","escaped","returns","decode_array","decode_tuple","o","decode_object","native","decode_native","set","sets","decode_set","maps","decode_map","length","createCallExpression","use","createArrayLiteralExpression","expr","toString","bigint","Number","TemplateFactory","generate","tags","find","t","kind","multiply","random_custom","RandomRanger","transform","setter","args","val","minimum","maximum","gap","emendFormat","tail","lengths","len","useLocal","index","createAdd","createConditionalExpression","createLogicalAnd","createLessThan","createNewExpression","MetadataArray","create","MetadataArrayType","nullables","getName","key","Metadata","initialize","MetadataTupleType","of_map","MetadataTuple","MetadataAtomic","decode_native_date","decode_native_byte_array","decode_native_array_buffer","decode_native_data_view","decode_native_blob","decode_native_file","BigInt64Array","MIN_VALUE","MAX_VALUE","literal","createTemplateExpression","createTemplateHead","createTemplateSpan","createNumericLiteral","createTemplateMiddle","createTemplateTail","access","selfCall","createExpressionStatement","coalesce","Escaper","variable","createPropertyAccessChain","QuestionDotToken","createElementAccessChain","split","str","toUpperCase","substring","join"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../factories/MetadataFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TemplateFactory } from \"../factories/TemplateFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../schemas/metadata/MetadataArrayType\";\nimport { MetadataAtomic } from \"../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../transformers/IProject\";\nimport { TransformerError } from \"../transformers/TransformerError\";\n\nimport { Escaper } from \"../utils/Escaper\";\n\nimport { Format } from \"../tags\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { RandomJoiner } from \"./helpers/RandomJoiner\";\nimport { RandomRanger } from \"./helpers/RandomRanger\";\nimport { random_custom } from \"./internal/random_custom\";\n\nexport namespace RandomProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (init?: ts.Expression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      return (type: ts.Type, name?: string) => {\n        // INITIALIZE METADATA\n        const collection: MetadataCollection = new MetadataCollection();\n        const result = MetadataFactory.analyze(\n          project.checker,\n          project.context,\n        )({\n          escape: false,\n          constant: true,\n          absorb: true,\n          validate: (meta) => {\n            const output: string[] = [];\n            if (meta.natives.some((n) => n === \"WeakSet\"))\n              output.push(`WeakSet is not supported.`);\n            else if (meta.natives.some((n) => n === \"WeakMap\"))\n              output.push(`WeakMap is not supported.`);\n            return output;\n          },\n        })(collection)(type);\n        if (result.success === false)\n          throw TransformerError.from(`typia.${importer.method}`)(\n            result.errors,\n          );\n\n        // GENERATE FUNCTION\n        const functions = {\n          objects: write_object_functions(importer)(collection),\n          arrays: write_array_functions(importer)(collection),\n          tuples: write_tuple_functions(importer)(collection),\n        };\n\n        const output: ts.Expression = decode(importer)({\n          function: false,\n          recursive: false,\n        })(result.data);\n\n        return ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            IdentifierFactory.parameter(\n              \"generator\",\n              ts.factory.createTypeReferenceNode(\n                \"Partial<typia.IRandomGenerator>\",\n              ),\n              init ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n            ),\n          ],\n          ts.factory.createImportTypeNode(\n            ts.factory.createLiteralTypeNode(\n              ts.factory.createStringLiteral(\"typia\"),\n            ),\n            undefined,\n            ts.factory.createIdentifier(\"Resolved\"),\n            [\n              ts.factory.createTypeReferenceNode(\n                name ?? TypeFactory.getFullName(project.checker)(type),\n              ),\n            ],\n            false,\n          ),\n          undefined,\n          ts.factory.createBlock(\n            [\n              ...importer.declare(modulo),\n              ...functions.objects,\n              ...functions.arrays,\n              ...functions.tuples,\n              ts.factory.createReturnStatement(output),\n            ],\n            true,\n          ),\n        );\n      };\n    };\n\n  const write_object_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection.objects().map((obj, i) =>\n        StatementFactory.constant(\n          PREFIX.object(i),\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              IdentifierFactory.parameter(\n                \"_recursive\",\n                TypeFactory.keyword(\"boolean\"),\n                ts.factory.createIdentifier(String(obj.recursive)),\n              ),\n              IdentifierFactory.parameter(\n                \"_depth\",\n                TypeFactory.keyword(\"number\"),\n                ExpressionFactory.number(0),\n              ),\n            ],\n            TypeFactory.keyword(\"any\"),\n            undefined,\n            RandomJoiner.object(COALESCE(importer))(\n              decode(importer)({\n                recursive: obj.recursive,\n                function: true,\n              }),\n            )(obj),\n          ),\n        ),\n      );\n\n  const write_array_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((array, i) =>\n          StatementFactory.constant(\n            PREFIX.array(i),\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"length\",\n                  TypeFactory.keyword(\"number\"),\n                ),\n                IdentifierFactory.parameter(\n                  \"_recursive\",\n                  TypeFactory.keyword(\"boolean\"),\n                  ts.factory.createTrue(),\n                ),\n                IdentifierFactory.parameter(\n                  \"_depth\",\n                  TypeFactory.keyword(\"number\"),\n                  ExpressionFactory.number(0),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              RandomJoiner.array(COALESCE(importer))(\n                decode(importer)({\n                  recursive: true,\n                  function: true,\n                }),\n              )({\n                recursive: true,\n                function: true,\n              })(ts.factory.createIdentifier(\"length\"))(array.value),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((a) => a.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            PREFIX.tuple(i),\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              [\n                IdentifierFactory.parameter(\n                  \"_recursive\",\n                  TypeFactory.keyword(\"boolean\"),\n                  ts.factory.createTrue(),\n                ),\n                IdentifierFactory.parameter(\n                  \"_depth\",\n                  TypeFactory.keyword(\"number\"),\n                  ExpressionFactory.number(0),\n                ),\n              ],\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              RandomJoiner.tuple(\n                decode(importer)({\n                  function: true,\n                  recursive: true,\n                }),\n              )(tuple.elements),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (meta: Metadata): ts.Expression => {\n      const expressions: ts.Expression[] = [];\n      if (meta.any)\n        expressions.push(ts.factory.createStringLiteral(\"any type used...\"));\n\n      // NULL COALESCING\n      if (meta.isRequired() === false || meta.functional === true)\n        expressions.push(ts.factory.createIdentifier(\"undefined\"));\n      if (meta.nullable === true) expressions.push(ts.factory.createNull());\n\n      // CONSTANT TYPES\n      for (const constant of meta.constants)\n        for (const { value } of constant.values)\n          expressions.push(decode_atomic(value));\n\n      // ATOMIC VARIABLES\n      for (const template of meta.templates)\n        expressions.push(decode_template(importer)(explore)(template));\n      for (const atomic of meta.atomics)\n        if (atomic.type === \"boolean\")\n          expressions.push(decode_boolean(importer));\n        else if (atomic.type === \"number\")\n          expressions.push(...decode_number(importer)(atomic));\n        else if (atomic.type === \"string\")\n          expressions.push(...decode_string(importer)(atomic));\n        else if (atomic.type === \"bigint\")\n          expressions.push(...decode_bigint(importer)(atomic));\n\n      // INSTANCE TYPES\n      if (meta.escaped)\n        expressions.push(decode(importer)(explore)(meta.escaped.returns));\n      for (const array of meta.arrays)\n        expressions.push(...decode_array(importer)(explore)(array));\n      for (const tuple of meta.tuples)\n        expressions.push(decode_tuple(importer)(explore)(tuple));\n      for (const o of meta.objects)\n        expressions.push(decode_object(importer)(explore)(o));\n      for (const native of meta.natives)\n        expressions.push(decode_native(importer)(native));\n      for (const set of meta.sets)\n        expressions.push(decode_set(importer)(explore)(set));\n      for (const map of meta.maps)\n        expressions.push(decode_map(importer)(explore)(map));\n\n      // PICK UP A TYPE\n      if (expressions.length === 1) return expressions[0]!;\n      return ts.factory.createCallExpression(\n        ts.factory.createCallExpression(importer.use(\"pick\"), undefined, [\n          ts.factory.createArrayLiteralExpression(\n            expressions.map((expr) =>\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                undefined,\n                undefined,\n                expr,\n              ),\n            ),\n            true,\n          ),\n        ]),\n        undefined,\n        undefined,\n      );\n    };\n\n  const decode_boolean = (importer: FunctionImporter) =>\n    ts.factory.createCallExpression(\n      COALESCE(importer)(\"boolean\"),\n      undefined,\n      undefined,\n    );\n\n  const decode_atomic = (value: Atomic) =>\n    typeof value === \"boolean\"\n      ? ts.factory.createIdentifier(value.toString())\n      : typeof value === \"number\"\n        ? ExpressionFactory.number(value)\n        : typeof value === \"string\"\n          ? ts.factory.createStringLiteral(value)\n          : ExpressionFactory.bigint(Number(value));\n\n  const decode_template =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (template: Metadata[]) =>\n      TemplateFactory.generate(\n        template.map((meta) => decode(importer)(explore)(meta)),\n      );\n\n  const decode_number =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) => {\n        const type = tags.find(\n          (t) =>\n            t.kind === \"type\" && (t.value === \"int32\" || t.value === \"int64\"),\n        )\n          ? \"int\"\n          : tags.find(\n                (t) =>\n                  t.kind === \"type\" &&\n                  (t.value === \"uint32\" || t.value === \"uint64\"),\n              )\n            ? \"uint\"\n            : \"double\";\n        const multiply = tags.find((t) => t.kind === \"multipleOf\");\n        return random_custom(COALESCE(importer))(\"number\")(tags)(\n          RandomRanger.number({\n            type,\n            transform: (value) => ExpressionFactory.number(value),\n            setter: (args) =>\n              ts.factory.createCallExpression(\n                type !== \"double\" || multiply !== undefined\n                  ? COALESCE(importer)(\"integer\")\n                  : COALESCE(importer)(\"number\"),\n                undefined,\n                args.map((val) => ExpressionFactory.number(val)),\n              ),\n          })({\n            minimum: 0,\n            maximum: 100,\n            gap: 10,\n          })(tags),\n        );\n      });\n\n  const decode_bigint =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) =>\n        random_custom(COALESCE(importer))(\"bigint\")(tags)(\n          RandomRanger.number({\n            type: tags.find(\n              (t) =>\n                t.kind === \"type\" &&\n                (t.value === \"uint\" || t.value === \"uint64\"),\n            )\n              ? \"uint\"\n              : \"int\",\n            transform: (value) => ExpressionFactory.bigint(value),\n            setter: (args) =>\n              ts.factory.createCallExpression(\n                COALESCE(importer)(\"bigint\"),\n                undefined,\n                args.map((value) => ExpressionFactory.bigint(value)),\n              ),\n          })({\n            minimum: 0,\n            maximum: 100,\n            gap: 10,\n          })(tags),\n        ),\n      );\n\n  const decode_string =\n    (importer: FunctionImporter) =>\n    (atomic: MetadataAtomic): ts.Expression[] =>\n      (atomic.tags.length ? atomic.tags : [[]]).map((tags) =>\n        random_custom(COALESCE(importer))(\"string\")(tags)(\n          (() => {\n            for (const t of tags)\n              if (t.kind === \"format\")\n                return ts.factory.createCallExpression(\n                  COALESCE(importer)(emendFormat(t.value)),\n                  undefined,\n                  undefined,\n                );\n              else if (t.kind === \"pattern\")\n                return ts.factory.createCallExpression(\n                  COALESCE(importer)(\"pattern\"),\n                  undefined,\n                  [ts.factory.createIdentifier(`/${t.value}/`)],\n                );\n\n            const tail = RandomRanger.length(COALESCE(importer))({\n              minimum: 5,\n              maximum: 25,\n              gap: 5,\n            })({\n              minimum: \"minLength\",\n              maximum: \"maxLength\",\n            })(tags);\n            return ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              tail ? [tail] : undefined,\n            );\n          })(),\n        ),\n      );\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (array: MetadataArray): ts.Expression[] => {\n      const lengths: Array<ts.Expression | undefined> = (\n        array.tags.length ? array.tags : [[]]\n      ).map((tags) =>\n        RandomRanger.length(COALESCE(importer))({\n          minimum: 0,\n          maximum: 3,\n          gap: 3,\n        })({\n          minimum: \"minItems\",\n          maximum: \"maxItems\",\n        })(tags),\n      );\n      if (array.type.recursive)\n        return lengths.map((len) =>\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(PREFIX.array(array.type.index!)),\n            ),\n            undefined,\n            [\n              len ?? COALESCE(importer)(\"length\"),\n              ts.factory.createTrue(),\n              explore.recursive\n                ? ts.factory.createAdd(\n                    ExpressionFactory.number(1),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  )\n                : ExpressionFactory.number(0),\n            ],\n          ),\n        );\n      return lengths.map((len) => {\n        const expr: ts.Expression = RandomJoiner.array(COALESCE(importer))(\n          decode(importer)(explore),\n        )(explore)(len)(array.type.value);\n        return explore.recursive\n          ? ts.factory.createConditionalExpression(\n              ts.factory.createLogicalAnd(\n                ts.factory.createIdentifier(\"_recursive\"),\n                ts.factory.createLessThan(\n                  ExpressionFactory.number(5),\n                  ts.factory.createIdentifier(\"_depth\"),\n                ),\n              ),\n              undefined,\n              ts.factory.createIdentifier(\"[]\"),\n              undefined,\n              expr,\n            )\n          : expr;\n      });\n    };\n\n  const decode_tuple =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (tuple: MetadataTuple): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(PREFIX.tuple(tuple.type.index!)),\n            ),\n            undefined,\n            [\n              ts.factory.createTrue(),\n              explore.recursive\n                ? ts.factory.createAdd(\n                    ExpressionFactory.number(1),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  )\n                : ExpressionFactory.number(0),\n            ],\n          )\n        : RandomJoiner.tuple(decode(importer)(explore))(tuple.type.elements);\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (object: MetadataObject) =>\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(PREFIX.object(object.index)),\n        ),\n        undefined,\n        explore.function\n          ? [\n              explore.recursive\n                ? ts.factory.createTrue()\n                : ts.factory.createIdentifier(\"_recursive\"),\n              ts.factory.createConditionalExpression(\n                ts.factory.createIdentifier(\"_recursive\"),\n                undefined,\n                ts.factory.createAdd(\n                  ExpressionFactory.number(1),\n                  ts.factory.createIdentifier(\"_depth\"),\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"_depth\"),\n              ),\n            ]\n          : undefined,\n      );\n\n  /* -----------------------------------------------------------\n        NATIVE CLASSES\n    ----------------------------------------------------------- */\n  const decode_set =\n    (importer: FunctionImporter) => (explore: IExplore) => (meta: Metadata) =>\n      ts.factory.createNewExpression(\n        ts.factory.createIdentifier(\"Set\"),\n        undefined,\n        [\n          decode_array(importer)(explore)(\n            MetadataArray.create({\n              tags: [],\n              type: MetadataArrayType.create({\n                value: meta,\n                recursive: false,\n                index: null,\n                nullables: [],\n                name: `Set<${meta.getName()}>`,\n              }),\n            }),\n          )[0]!,\n        ],\n      );\n\n  const decode_map =\n    (importer: FunctionImporter) =>\n    (explore: IExplore) =>\n    (map: Metadata.Entry) =>\n      ts.factory.createNewExpression(\n        ts.factory.createIdentifier(\"Map\"),\n        undefined,\n        [\n          decode_array(importer)(explore)(\n            MetadataArray.create({\n              tags: [],\n              type: MetadataArrayType.create({\n                name: `Map<${map.key.getName()}, ${map.value.getName()}>`,\n                index: null,\n                recursive: false,\n                nullables: [],\n                value: Metadata.create({\n                  ...Metadata.initialize(),\n                  tuples: [\n                    (() => {\n                      const type = MetadataTupleType.create({\n                        name: `[${map.key.getName()}, ${map.value.getName()}]`,\n                        index: null,\n                        recursive: false,\n                        nullables: [],\n                        elements: [map.key, map.value],\n                      });\n                      type.of_map = true;\n                      return MetadataTuple.create({\n                        type,\n                        tags: [],\n                      });\n                    })(),\n                  ],\n                }),\n              }),\n            }),\n          )[0]!,\n        ],\n      );\n\n  const decode_native =\n    (importer: FunctionImporter) =>\n    (type: string): ts.Expression => {\n      if (type === \"Boolean\") return decode_boolean(importer);\n      else if (type === \"Number\")\n        return decode_number(importer)(\n          MetadataAtomic.create({\n            type: \"number\",\n            tags: [],\n          }),\n        )[0]!;\n      else if (type === \"String\")\n        return decode_string(importer)(\n          MetadataAtomic.create({\n            type: \"string\",\n            tags: [],\n          }),\n        )[0]!;\n      else if (type === \"Date\") return decode_native_date(importer);\n      else if (\n        type === \"Uint8Array\" ||\n        type === \"Uint8ClampedArray\" ||\n        type === \"Uint16Array\" ||\n        type === \"Uint32Array\" ||\n        type === \"BigUint64Array\" ||\n        type === \"Int8Array\" ||\n        type === \"Int16Array\" ||\n        type === \"Int32Array\" ||\n        type === \"BigInt64Array\" ||\n        type === \"Float32Array\" ||\n        type === \"Float64Array\"\n      )\n        return decode_native_byte_array(importer)(type);\n      else if (type === \"ArrayBuffer\" || type === \"SharedArrayBuffer\")\n        return decode_native_array_buffer(importer)(type);\n      else if (type === \"DataView\") return decode_native_data_view(importer);\n      else if (type === \"Blob\") return decode_native_blob(importer);\n      else if (type === \"File\") return decode_native_file(importer);\n      else\n        return ts.factory.createNewExpression(\n          ts.factory.createIdentifier(type),\n          undefined,\n          [],\n        );\n    };\n\n  const decode_native_date = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"Date\"),\n      undefined,\n      [\n        ts.factory.createCallExpression(\n          COALESCE(importer)(\"datetime\"),\n          undefined,\n          [],\n        ),\n      ],\n    );\n\n  const decode_native_byte_array =\n    (importer: FunctionImporter) =>\n    (\n      type:\n        | \"Uint8Array\"\n        | \"Uint8ClampedArray\"\n        | \"Uint16Array\"\n        | \"Uint32Array\"\n        | \"BigUint64Array\"\n        | \"Int8Array\"\n        | \"Int16Array\"\n        | \"Int32Array\"\n        | \"BigInt64Array\"\n        | \"Float32Array\"\n        | \"Float64Array\",\n    ): ts.Expression => {\n      new BigInt64Array();\n      const [minimum, maximum]: [number, number] = (() => {\n        if (type === \"Uint8Array\" || type === \"Uint8ClampedArray\")\n          return [0, 255];\n        else if (type === \"Uint16Array\") return [0, 65535];\n        else if (type === \"Uint32Array\") return [0, 4294967295];\n        else if (type === \"BigUint64Array\") return [0, 18446744073709551615];\n        else if (type === \"Int8Array\") return [-128, 127];\n        else if (type === \"Int16Array\") return [-32768, 32767];\n        else if (type === \"Int32Array\") return [-2147483648, 2147483647];\n        else if (type === \"BigInt64Array\")\n          return [-9223372036854775808, 9223372036854775807];\n        else if (type === \"Float32Array\")\n          return [-1.175494351e38, 3.4028235e38];\n        return [Number.MIN_VALUE, Number.MAX_VALUE];\n      })();\n      const literal =\n        type === \"BigInt64Array\" || type === \"BigUint64Array\"\n          ? ExpressionFactory.bigint\n          : ExpressionFactory.number;\n      return ts.factory.createNewExpression(\n        ts.factory.createIdentifier(type),\n        [],\n        [\n          ts.factory.createCallExpression(\n            COALESCE(importer)(\"array\"),\n            undefined,\n            [\n              ts.factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                TypeFactory.keyword(\"any\"),\n                undefined,\n                ts.factory.createCallExpression(\n                  COALESCE(importer)(\n                    type === \"Float32Array\" || type === \"Float64Array\"\n                      ? \"number\"\n                      : type === \"BigInt64Array\" || type === \"BigUint64Array\"\n                        ? \"bigint\"\n                        : \"integer\",\n                  ),\n                  undefined,\n                  [literal(minimum), literal(maximum)],\n                ),\n              ),\n            ],\n          ),\n        ],\n      );\n    };\n\n  const decode_native_blob = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"Blob\"),\n      undefined,\n      [\n        ts.factory.createArrayLiteralExpression(\n          [decode_native_byte_array(importer)(\"Uint8Array\")],\n          true,\n        ),\n      ],\n    );\n\n  const decode_native_file = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"File\"),\n      undefined,\n      [\n        ts.factory.createArrayLiteralExpression(\n          [decode_native_byte_array(importer)(\"Uint8Array\")],\n          true,\n        ),\n        ts.factory.createTemplateExpression(ts.factory.createTemplateHead(\"\"), [\n          ts.factory.createTemplateSpan(\n            ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              [ts.factory.createNumericLiteral(8)],\n            ),\n            ts.factory.createTemplateMiddle(\".\"),\n          ),\n          ts.factory.createTemplateSpan(\n            ts.factory.createCallExpression(\n              COALESCE(importer)(\"string\"),\n              undefined,\n              [ts.factory.createNumericLiteral(3)],\n            ),\n            ts.factory.createTemplateTail(\"\"),\n          ),\n        ]),\n      ],\n    );\n\n  const decode_native_array_buffer =\n    (importer: FunctionImporter) =>\n    (type: \"ArrayBuffer\" | \"SharedArrayBuffer\"): ts.Expression =>\n      type === \"ArrayBuffer\"\n        ? IdentifierFactory.access(\n            decode_native_byte_array(importer)(\"Uint8Array\"),\n          )(\"buffer\")\n        : ExpressionFactory.selfCall(\n            ts.factory.createBlock(\n              [\n                StatementFactory.constant(\n                  \"length\",\n                  ts.factory.createCallExpression(\n                    COALESCE(importer)(\"integer\"),\n                    undefined,\n                    [],\n                  ),\n                ),\n                StatementFactory.constant(\n                  \"buffer\",\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"SharedArrayBuffer\"),\n                    [],\n                    [ts.factory.createIdentifier(\"length\")],\n                  ),\n                ),\n                StatementFactory.constant(\n                  \"bytes\",\n                  ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    [],\n                    [ts.factory.createIdentifier(\"buffer\")],\n                  ),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(\n                      ts.factory.createIdentifier(\"bytes\"),\n                    )(\"set\"),\n                    undefined,\n                    [\n                      ts.factory.createCallExpression(\n                        COALESCE(importer)(\"array\"),\n                        undefined,\n                        [\n                          ts.factory.createArrowFunction(\n                            undefined,\n                            undefined,\n                            [],\n                            TypeFactory.keyword(\"any\"),\n                            undefined,\n                            ts.factory.createCallExpression(\n                              COALESCE(importer)(\"integer\"),\n                              undefined,\n                              [\n                                ExpressionFactory.number(0),\n                                ExpressionFactory.number(255),\n                              ],\n                            ),\n                          ),\n                          ts.factory.createIdentifier(\"length\"),\n                        ],\n                      ),\n                      ExpressionFactory.number(0),\n                    ],\n                  ),\n                ),\n                ts.factory.createReturnStatement(\n                  ts.factory.createIdentifier(\"buffer\"),\n                ),\n              ],\n              true,\n            ),\n          );\n\n  const decode_native_data_view = (importer: FunctionImporter) =>\n    ts.factory.createNewExpression(\n      ts.factory.createIdentifier(\"DataView\"),\n      [],\n      [\n        IdentifierFactory.access(\n          decode_native_byte_array(importer)(\"Uint8Array\"),\n        )(\"buffer\"),\n      ],\n    );\n}\n\ntype Atomic = boolean | number | string | bigint;\ninterface IExplore {\n  function: boolean;\n  recursive: boolean;\n}\n\nconst PREFIX = {\n  object: (i: number) => `$ro${i}`,\n  array: (i: number) => `$ra${i}`,\n  tuple: (i: number) => `$rt${i}`,\n};\n\nconst COALESCE = (importer: FunctionImporter) => (name: string) =>\n  ExpressionFactory.coalesce(\n    Escaper.variable(name)\n      ? ts.factory.createPropertyAccessChain(\n          ts.factory.createIdentifier(\"generator\"),\n          ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n          ts.factory.createIdentifier(name),\n        )\n      : ts.factory.createElementAccessChain(\n          ts.factory.createIdentifier(\"generator\"),\n          ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n          ts.factory.createStringLiteral(name),\n        ),\n  )(IdentifierFactory.access(importer.use(\"generator\"))(name));\n\nconst emendFormat = (key: keyof Format.Validator) =>\n  key === \"date-time\"\n    ? \"datetime\"\n    : key\n        .split(\"-\")\n        .map((str, i) =>\n          i === 0 || str.length === 0\n            ? str\n            : str[0]!.toUpperCase() + str.substring(1),\n        )\n        .join(\"\");\n"]}