{"version":3,"sources":["../src/transformers/ImportTransformer.ts"],"sourcesContent":["import path from \"path\";\nimport ts from \"typescript\";\n\nexport namespace ImportTransformer {\n  export const transform =\n    (from: string) =>\n    (to: string) =>\n    (context: ts.TransformationContext) =>\n    (file: ts.SourceFile) =>\n      transform_file(from)(to)(context)(file);\n\n  const transform_file =\n    (top: string) =>\n    (to: string) =>\n    (context: ts.TransformationContext) =>\n    (file: ts.SourceFile): ts.SourceFile => {\n      if (file.isDeclarationFile) return file;\n\n      const from: string = get_directory_path(\n        path.resolve(file.getSourceFile().fileName),\n      );\n      to = from.replace(top, to);\n\n      return ts.visitEachChild(\n        file,\n        (node) => transform_node(top)(from)(to)(node),\n        context,\n      );\n    };\n\n  const transform_node =\n    (top: string) => (from: string) => (to: string) => (node: ts.Node) => {\n      if (\n        !ts.isImportDeclaration(node) ||\n        !ts.isStringLiteral(node.moduleSpecifier)\n      )\n        return node;\n\n      const text: string = node.moduleSpecifier.text;\n      if (text[0] !== \".\") return node;\n\n      const location: string = path.resolve(from, text);\n      if (location.indexOf(top) === 0) return node;\n\n      const replaced: string = (() => {\n        const simple: string = path\n          .relative(to, location)\n          .split(path.sep)\n          .join(\"/\");\n        return simple[0] === \".\" ? simple : `./${simple}`;\n      })();\n\n      return ts.factory.createImportDeclaration(\n        undefined,\n        node.importClause,\n        ts.factory.createStringLiteral(replaced),\n        node.assertClause,\n      );\n    };\n}\n\nconst get_directory_path = (file: string): string => {\n  const splitted: string[] = path.resolve(file).split(path.sep);\n  splitted.pop();\n  return path.resolve(splitted.join(path.sep));\n};\n"],"mappings":";;;;;AAAA,OAAOA,UAAU;AACjB,OAAOC,QAAQ;;UAEEC,oBAAAA;qBACFC,YACX,CAACC,SACD,CAACC,OACD,CAACC,YACD,CAACC,SACCC,eAAeJ,IAAAA,EAAMC,EAAAA,EAAIC,OAAAA,EAASC,IAAAA;AAEtC,QAAMC,iBACJ,wBAACC,QACD,CAACJ,OACD,CAACC,YACD,CAACC,SAAAA;AACC,QAAIA,KAAKG,kBAAmB,QAAOH;AAEnC,UAAMH,OAAeO,mBACnBC,KAAKC,QAAQN,KAAKO,cAAa,EAAGC,QAAQ,CAAA;AAE5CV,SAAKD,KAAKY,QAAQP,KAAKJ,EAAAA;AAEvB,WAAOY,GAAGC,eACRX,MACA,CAACY,SAASC,eAAeX,GAAAA,EAAKL,IAAAA,EAAMC,EAAAA,EAAIc,IAAAA,GACxCb,OAAAA;EAEJ,GAhBA;AAkBF,QAAMc,iBACJ,wBAACX,QAAgB,CAACL,SAAiB,CAACC,OAAe,CAACc,SAAAA;AAClD,QACE,CAACF,GAAGI,oBAAoBF,IAAAA,KACxB,CAACF,GAAGK,gBAAgBH,KAAKI,eAAe,EAExC,QAAOJ;AAET,UAAMK,OAAeL,KAAKI,gBAAgBC;AAC1C,QAAIA,KAAK,CAAA,MAAO,IAAK,QAAOL;AAE5B,UAAMM,WAAmBb,KAAKC,QAAQT,MAAMoB,IAAAA;AAC5C,QAAIC,SAASC,QAAQjB,GAAAA,MAAS,EAAG,QAAOU;AAExC,UAAMQ,YAAoB,MAAA;AACxB,YAAMC,SAAiBhB,KACpBiB,SAASxB,IAAIoB,QAAAA,EACbK,MAAMlB,KAAKmB,GAAG,EACdC,KAAK,GAAA;AACR,aAAOJ,OAAO,CAAA,MAAO,MAAMA,SAAS,KAAKA,MAAAA;IAC3C,GAAA;AAEA,WAAOX,GAAGgB,QAAQC,wBAChBC,QACAhB,KAAKiB,cACLnB,GAAGgB,QAAQI,oBAAoBV,QAAAA,GAC/BR,KAAKmB,YAAY;EAErB,GA3BA;AA4BJ,GAxDiBpC,sBAAAA,oBAAAA,CAAAA,EAAAA;AA0DjB,IAAMS,qBAAqB,wBAACJ,SAAAA;AAC1B,QAAMgC,WAAqB3B,KAAKC,QAAQN,IAAAA,EAAMuB,MAAMlB,KAAKmB,GAAG;AAC5DQ,WAASC,IAAG;AACZ,SAAO5B,KAAKC,QAAQ0B,SAASP,KAAKpB,KAAKmB,GAAG,CAAA;AAC5C,GAJ2B;","names":["path","ts","ImportTransformer","transform","from","to","context","file","transform_file","top","isDeclarationFile","get_directory_path","path","resolve","getSourceFile","fileName","replace","ts","visitEachChild","node","transform_node","isImportDeclaration","isStringLiteral","moduleSpecifier","text","location","indexOf","replaced","simple","relative","split","sep","join","factory","createImportDeclaration","undefined","importClause","createStringLiteral","assertClause","splitted","pop"]}