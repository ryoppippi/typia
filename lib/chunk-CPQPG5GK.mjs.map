{"version":3,"sources":["../src/programmers/json/JsonStringifyProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { JsonMetadataFactory } from \"../../factories/JsonMetadataFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\nimport { ValueFactory } from \"../../factories/ValueFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { ArrayUtil } from \"../../utils/ArrayUtil\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { AtomicPredicator } from \"../helpers/AtomicPredicator\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\nimport { OptionPredicator } from \"../helpers/OptionPredicator\";\nimport { StringifyJoiner } from \"../helpers/StringifyJoinder\";\nimport { StringifyPredicator } from \"../helpers/StringifyPredicator\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\nimport { check_native } from \"../internal/check_native\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\nimport { feature_object_entries } from \"../internal/feature_object_entries\";\nimport { wrap_metadata_rest_tuple } from \"../internal/wrap_metadata_rest_tuple\";\n\nexport namespace JsonStringifyProgrammer {\n  /* -----------------------------------------------------------\n    WRITER\n  ----------------------------------------------------------- */\n  export const write =\n    (project: IProject) => (modulo: ts.LeftHandSideExpression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const config: FeatureProgrammer.IConfig = configure(project)(importer);\n\n      return FeatureProgrammer.write(project)({\n        ...config,\n        addition: (collection) => [\n          ...IsProgrammer.write_function_statements(project)(importer)(\n            collection,\n          ),\n          ...importer.declare(modulo),\n        ],\n      })(importer);\n    };\n\n  const write_array_functions =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n    DECODERS\n  ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      // ANY TYPE\n      if (meta.any === true)\n        return wrap_required(\n          input,\n          meta,\n          explore,\n        )(\n          wrap_functional(\n            input,\n            meta,\n            explore,\n          )(\n            ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"JSON.stringify\"),\n              undefined,\n              [input],\n            ),\n          ),\n        );\n\n      // ONLY NULL OR UNDEFINED\n      const size: number = meta.size();\n      if (\n        size === 0 &&\n        (meta.isRequired() === false || meta.nullable === true)\n      ) {\n        if (meta.isRequired() === false && meta.nullable === true)\n          return explore.from === \"array\"\n            ? ts.factory.createStringLiteral(\"null\")\n            : ts.factory.createConditionalExpression(\n                ts.factory.createStrictEquality(ts.factory.createNull(), input),\n                undefined,\n                ts.factory.createStringLiteral(\"null\"),\n                undefined,\n                ts.factory.createIdentifier(\"undefined\"),\n              );\n        else if (meta.isRequired() === false)\n          return explore.from === \"array\"\n            ? ts.factory.createStringLiteral(\"null\")\n            : ts.factory.createIdentifier(\"undefined\");\n        else return ts.factory.createStringLiteral(\"null\");\n      }\n\n      //----\n      // LIST UP UNION TYPES\n      //----\n      const unions: IUnion[] = [];\n\n      // toJSON() METHOD\n      if (meta.escaped !== null)\n        unions.push({\n          type: \"resolved\",\n          is:\n            meta.escaped.original.size() === 1 &&\n            meta.escaped.original.natives[0] === \"Date\"\n              ? () => check_native(\"Date\")(input)\n              : () => IsProgrammer.decode_to_json(false)(input),\n          value: () =>\n            decode_to_json(project)(config)(importer)(\n              input,\n              meta.escaped!.returns,\n              explore,\n            ),\n        });\n      else if (meta.functional === true)\n        unions.push({\n          type: \"functional\",\n          is: () => IsProgrammer.decode_functional(input),\n          value: () => decode_functional(explore),\n        });\n\n      // TEMPLATES\n      if (\n        meta.templates.length ||\n        ArrayUtil.has(meta.constants, (c) => c.type === \"string\")\n      )\n        if (AtomicPredicator.template(meta)) {\n          const partial = Metadata.initialize();\n          partial.atomics.push(\n            MetadataAtomic.create({ type: \"string\", tags: [] }),\n          ),\n            unions.push({\n              type: \"template literal\",\n              is: () =>\n                IsProgrammer.decode(project)(importer)(input, partial, explore),\n              value: () =>\n                decode_atomic(project)(importer)(input, \"string\", explore),\n            });\n        }\n\n      // CONSTANTS\n      for (const constant of meta.constants)\n        if (AtomicPredicator.constant(meta)(constant.type) === false) continue;\n        else if (constant.type !== \"string\")\n          unions.push({\n            type: \"atomic\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(\n                    MetadataAtomic.create({\n                      type: constant.type,\n                      tags: [],\n                    }),\n                  );\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_atomic(project)(importer)(input, constant.type, explore),\n          });\n        else if (meta.templates.length === 0)\n          unions.push({\n            type: \"const string\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(\n                    MetadataAtomic.create({\n                      type: \"string\",\n                      tags: [],\n                    }),\n                  );\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_constant_string(project)(importer)(\n                input,\n                [...constant.values.map((v) => v.value)] as string[],\n                explore,\n              ),\n          });\n\n      /// ATOMICS\n      for (const a of meta.atomics)\n        if (AtomicPredicator.atomic(meta)(a.type))\n          unions.push({\n            type: \"atomic\",\n            is: () =>\n              IsProgrammer.decode(project)(importer)(\n                input,\n                (() => {\n                  const partial = Metadata.initialize();\n                  partial.atomics.push(a);\n                  return partial;\n                })(),\n                explore,\n              ),\n            value: () =>\n              decode_atomic(project)(importer)(input, a.type, explore),\n          });\n\n      // TUPLES\n      for (const tuple of meta.tuples)\n        unions.push({\n          type: \"tuple\",\n          is: () =>\n            IsProgrammer.decode(project)(importer)(\n              input,\n              (() => {\n                const partial = Metadata.initialize();\n                partial.tuples.push(tuple);\n                return partial;\n              })(),\n              explore,\n            ),\n          value: () =>\n            decode_tuple(project)(config)(importer)(input, tuple, explore),\n        });\n\n      // ARRAYS\n      if (meta.arrays.length) {\n        const value: () => ts.Expression =\n          meta.arrays.length === 1\n            ? () =>\n                decode_array(config)(importer)(input, meta.arrays[0]!, {\n                  ...explore,\n                  from: \"array\",\n                })\n            : meta.arrays.some((elem) => elem.type.value.any)\n              ? () =>\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"JSON.stringify\"),\n                    undefined,\n                    [input],\n                  )\n              : () =>\n                  explore_arrays(project)(config)(importer)(\n                    input,\n                    meta.arrays,\n                    {\n                      ...explore,\n                      from: \"array\",\n                    },\n                  );\n\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value,\n        });\n      }\n\n      // BUILT-IN CLASSES\n      if (meta.natives.length)\n        for (const native of meta.natives)\n          unions.push({\n            type: \"object\",\n            is: () => check_native(native)(input),\n            value: () =>\n              AtomicPredicator.native(native)\n                ? decode_atomic(project)(importer)(\n                    input,\n                    native.toLowerCase() as Atomic.Literal,\n                    explore,\n                  )\n                : ts.factory.createStringLiteral(\"{}\"),\n          });\n\n      // SETS\n      if (meta.sets.length)\n        unions.push({\n          type: \"object\",\n          is: () => ExpressionFactory.isInstanceOf(\"Set\")(input),\n          value: () => ts.factory.createStringLiteral(\"{}\"),\n        });\n\n      // MAPS\n      if (meta.maps.length)\n        unions.push({\n          type: \"object\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: () => ts.factory.createStringLiteral(\"{}\"),\n        });\n\n      // OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: meta.objects.some((obj) =>\n                obj.properties.every(\n                  (prop) =>\n                    !prop.key.isSoleLiteral() || !prop.value.isRequired(),\n                ),\n              ),\n            })(input),\n          value: () =>\n            meta.isParentResolved() === false &&\n            meta.objects.length === 1 &&\n            meta.objects[0]!._Is_simple(explore.from === \"top\" ? 0 : 1)\n              ? (() => {\n                  const obj: MetadataObject = meta.objects[0]!;\n                  const entries: IExpressionEntry<ts.Expression>[] =\n                    feature_object_entries({\n                      decoder: () => decode(project)(config)(importer),\n                      trace: false,\n                      path: false,\n                    })(importer)(obj)(\n                      ts.factory.createAsExpression(\n                        input,\n                        TypeFactory.keyword(\"any\"),\n                      ),\n                    );\n                  return StringifyJoiner.object(importer)(\n                    ts.factory.createAsExpression(\n                      input,\n                      TypeFactory.keyword(\"any\"),\n                    ),\n                    entries,\n                  );\n                })()\n              : explore_objects(config)(importer)(input, meta, {\n                  ...explore,\n                  from: \"object\",\n                }),\n        });\n\n      //----\n      // RETURNS\n      //----\n      // CHECK NULL AND UNDEFINED\n      const wrapper = (output: ts.Expression) =>\n        wrap_required(input, meta, explore)(wrap_nullable(input, meta)(output));\n\n      // DIRECT RETURN\n      if (unions.length === 0)\n        return ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"JSON.stringify\"),\n          undefined,\n          [input],\n        );\n      else if (unions.length === 1) return wrapper(unions[0]!.value());\n\n      // RETURN WITH TYPE CHECKING\n      return wrapper(\n        ts.factory.createCallExpression(\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            undefined,\n            iterate(importer, input, unions, meta.getName()),\n          ),\n          undefined,\n          undefined,\n        ),\n      );\n    };\n\n  const decode_object = (importer: FunctionImporter) =>\n    FeatureProgrammer.decode_object({\n      trace: false,\n      path: false,\n      prefix: PREFIX,\n    })(importer);\n\n  const decode_array =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      array.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}a${array.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n              from: \"array\",\n            })(input),\n          )\n        : decode_array_inline(config)(importer)(input, array, explore);\n\n  const decode_array_inline =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      FeatureProgrammer.decode_array(config)(importer)(StringifyJoiner.array)(\n        input,\n        array,\n        explore,\n      );\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n            })(input),\n          )\n        : decode_tuple_inline(project)(config)(importer)(\n            input,\n            tuple.type,\n            explore,\n          );\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const children: ts.Expression[] = tuple.elements\n        .filter((elem) => elem.rest === null)\n        .map((elem, index) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            elem,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest = (() => {\n        if (tuple.elements.length === 0) return null;\n        const last = tuple.elements.at(-1)!;\n        if (last.rest === null) return null;\n\n        const code = decode(project)(config)(importer)(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"slice\"),\n            undefined,\n            [ExpressionFactory.number(tuple.elements.length - 1)],\n          ),\n          wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n          {\n            ...explore,\n            start: tuple.elements.length - 1,\n          },\n        );\n        return ts.factory.createCallExpression(\n          importer.use(\"rest\"),\n          undefined,\n          [code],\n        );\n      })();\n      return StringifyJoiner.tuple(children, rest);\n    };\n\n  const decode_atomic =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      type: string,\n      explore: FeatureProgrammer.IExplore,\n    ) => {\n      if (type === \"string\")\n        return ts.factory.createCallExpression(\n          importer.use(\"string\"),\n          undefined,\n          [input],\n        );\n      else if (type === \"number\" && OptionPredicator.numeric(project.options))\n        input = ts.factory.createCallExpression(\n          importer.use(\"number\"),\n          undefined,\n          [input],\n        );\n\n      return explore.from !== \"top\"\n        ? input\n        : ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"toString\"),\n            undefined,\n            undefined,\n          );\n    };\n\n  const decode_constant_string =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      values: string[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      if (values.every((v) => !StringifyPredicator.require_escape(v)))\n        return [\n          ts.factory.createStringLiteral('\"'),\n          input,\n          ts.factory.createStringLiteral('\"'),\n        ].reduce((x, y) => ts.factory.createAdd(x, y));\n      else return decode_atomic(project)(importer)(input, \"string\", explore);\n    };\n\n  const decode_to_json =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      resolved: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      return decode(project)(config)(importer)(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"toJSON\"),\n          undefined,\n          [],\n        ),\n        resolved,\n        explore,\n      );\n    };\n\n  const decode_functional = (explore: FeatureProgrammer.IExplore) =>\n    explore.from === \"array\"\n      ? ts.factory.createStringLiteral(\"null\")\n      : ts.factory.createIdentifier(\"undefined\");\n\n  /* -----------------------------------------------------------\n    EXPLORERS\n  ----------------------------------------------------------- */\n  const explore_objects =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      meta.objects.length === 1\n        ? decode_object(importer)(input, meta.objects[0]!, explore)\n        : ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${PREFIX}u${meta.union_index!}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)(explore)(input),\n          );\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: MetadataArray[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: decode_array(config)(importer),\n          empty: ts.factory.createStringLiteral(\"[]\"),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: FeatureProgrammer.IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (\n      input: ts.Expression,\n      elements: T[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: FeatureProgrammer.IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.emplaceUnion(\n            config.prefix,\n            elements.map((e) => e.type.name).join(\" | \"),\n            () =>\n              arrow(\n                FeatureProgrammer.parameterDeclarations(config)(\n                  TypeFactory.keyword(\"any\"),\n                )(ts.factory.createIdentifier(\"input\")),\n              )({\n                ...explore,\n                postfix: \"\",\n              })(ts.factory.createIdentifier(\"input\")),\n          ),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  /* -----------------------------------------------------------\n    RETURN SCRIPTS\n  ----------------------------------------------------------- */\n  const wrap_required = (\n    input: ts.Expression,\n    meta: Metadata,\n    explore: FeatureProgrammer.IExplore,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.isRequired() === true && meta.any === false)\n      return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(\n          ts.factory.createIdentifier(\"undefined\"),\n          input,\n        ),\n        undefined,\n        expression,\n        undefined,\n        explore.from === \"array\"\n          ? ts.factory.createStringLiteral(\"null\")\n          : ts.factory.createIdentifier(\"undefined\"),\n      );\n  };\n\n  const wrap_nullable = (\n    input: ts.Expression,\n    meta: Metadata,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.nullable === false) return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(ts.factory.createNull(), input),\n        undefined,\n        expression,\n        undefined,\n        ts.factory.createStringLiteral(\"null\"),\n      );\n  };\n\n  const wrap_functional = (\n    input: ts.Expression,\n    meta: Metadata,\n    explore: FeatureProgrammer.IExplore,\n  ): ((expression: ts.Expression) => ts.Expression) => {\n    if (meta.functional === false) return (expression) => expression;\n    return (expression) =>\n      ts.factory.createConditionalExpression(\n        ts.factory.createStrictInequality(\n          ts.factory.createStringLiteral(\"function\"),\n          ValueFactory.TYPEOF(input),\n        ),\n        undefined,\n        expression,\n        undefined,\n        decode_functional(explore),\n      );\n  };\n\n  const iterate = (\n    importer: FunctionImporter,\n    input: ts.Expression,\n    unions: IUnion[],\n    expected: string,\n  ) =>\n    ts.factory.createBlock(\n      [\n        ...unions.map((u) =>\n          ts.factory.createIfStatement(\n            u.is(),\n            ts.factory.createReturnStatement(u.value()),\n          ),\n        ),\n        create_throw_error(importer)(expected)(input),\n      ],\n      true,\n    );\n\n  /* -----------------------------------------------------------\n    CONFIGURATIONS\n  ----------------------------------------------------------- */\n  const PREFIX = \"$s\";\n\n  const configure =\n    (project: IProject) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => {\n      const config: FeatureProgrammer.IConfig = {\n        types: {\n          input: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          output: () => TypeFactory.keyword(\"string\"),\n        },\n        prefix: PREFIX,\n        trace: false,\n        path: false,\n        initializer,\n        decoder: () => decode(project)(config)(importer),\n        objector: {\n          checker: () => (input, meta, explore) =>\n            IsProgrammer.decode(project)(importer)(input, meta, explore),\n          decoder: () => decode_object(importer),\n          joiner: StringifyJoiner.object(importer),\n          unionizer: decode_union_object(\n            IsProgrammer.decode_object(project)(importer),\n          )(decode_object(importer))((exp) => exp)((value, expected) =>\n            create_throw_error(importer)(expected)(value),\n          ),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        },\n        generator: {\n          arrays: () => write_array_functions(config)(importer),\n          tuples: () => write_tuple_functions(project)(config)(importer),\n        },\n      };\n      return config;\n    };\n\n  const initializer: FeatureProgrammer.IConfig[\"initializer\"] =\n    (project) => (importer) => (type) =>\n      JsonMetadataFactory.analyze(`typia.json.${importer.method}`)(\n        project.checker,\n        project.context,\n      )(type);\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n\ninterface IUnion {\n  type: string;\n  is: () => ts.Expression;\n  value: () => ts.Expression;\n}\n"],"mappings":"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","names":["ts","JsonStringifyProgrammer","write","project","modulo","importer","FunctionImporter","getText","config","configure","FeatureProgrammer","addition","collection","IsProgrammer","write_function_statements","declare","write_array_functions","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","ts","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","decode","input","meta","explore","any","wrap_required","wrap_functional","createCallExpression","size","isRequired","nullable","createStringLiteral","createConditionalExpression","createStrictEquality","createNull","unions","escaped","push","is","original","natives","check_native","decode_to_json","value","returns","functional","decode_functional","templates","length","ArrayUtil","has","constants","c","AtomicPredicator","template","partial","Metadata","initialize","atomics","MetadataAtomic","decode_atomic","decode_constant_string","values","v","atomic","decode_tuple","decode_array","some","elem","explore_arrays","ExpressionFactory","isArray","native","toLowerCase","sets","isInstanceOf","maps","objects","isObject","checkNull","checkArray","obj","properties","every","prop","key","isSoleLiteral","isParentResolved","_Is_simple","entries","feature_object_entries","decoder","path","createAsExpression","StringifyJoiner","object","explore_objects","wrapper","output","wrap_nullable","iterate","getName","decode_object","PREFIX","array","useLocal","index","argumentsArray","children","elements","rest","createElementAccessExpression","slice","last","at","code","IdentifierFactory","access","number","wrap_metadata_rest_tuple","start","use","OptionPredicator","numeric","options","StringifyPredicator","require_escape","reduce","x","y","createAdd","resolved","union_index","explore_array_like_union_types","UnionExplorer","checker","empty","success","createTrue","failure","expected","create_throw_error","arrow","parameters","e","emplaceUnion","name","join","expression","createStrictInequality","ValueFactory","TYPEOF","createBlock","u","createIfStatement","createReturnStatement","types","createTypeReferenceNode","getFullName","initializer","objector","joiner","unionizer","decode_union_object","exp","generator","JsonMetadataFactory","analyze","method","context","createExpressionStatement","createObjectLiteralExpression","createPropertyAssignment"]}