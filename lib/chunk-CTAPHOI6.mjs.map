{"version":3,"sources":["../src/factories/internal/metadata/iterate_metadata_alias.ts","../src/factories/internal/metadata/emplace_metadata_array_type.ts","../src/factories/internal/metadata/iterate_metadata_array.ts","../src/factories/internal/metadata/iterate_metadata_escape.ts","../src/factories/internal/metadata/iterate_metadata_intersection.ts","../src/factories/internal/metadata/iterate_metadata_map.ts","../src/factories/internal/metadata/iterate_metadata_object.ts","../src/factories/internal/metadata/emplace_metadata_object.ts","../src/factories/internal/metadata/iterate_metadata_set.ts","../src/factories/internal/metadata/iterate_metadata_template.ts","../src/factories/internal/metadata/emplace_metadata_tuple.ts","../src/factories/internal/metadata/iterate_metadata_tuple.ts","../src/factories/internal/metadata/iterate_metadata_union.ts","../src/factories/internal/metadata/iterate_metadata.ts","../src/factories/internal/metadata/explore_metadata.ts","../src/factories/internal/metadata/emplace_metadata_alias.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAlias } from \"../../../schemas/metadata/MetadataAlias\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_alias } from \"./emplace_metadata_alias\";\n\nexport const iterate_metadata_alias =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (options.absorb !== false || type.aliasSymbol === undefined)\n      return false;\n\n    const node: ts.Declaration | undefined = type.aliasSymbol.declarations?.[0];\n    if (node === undefined) return false;\n\n    // CONSTRUCT DEFINITION\n    const alias: MetadataAlias = emplace_metadata_alias(checker)(options)(\n      collection,\n    )(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(meta.aliases, alias, (elem) => elem.name === alias.name);\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../../schemas/metadata/MetadataArrayType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_array_type =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.Type,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataArrayType => {\n    // CHECK EXISTENCE\n    const [array, newbie, setValue] = collection.emplaceArray(checker, type);\n    ArrayUtil.add(array.nullables, nullable);\n    if (newbie === false) return array;\n\n    // CONSTRUCT VALUE TYPE\n    const value: Metadata = explore_metadata(checker)(options)(collection)(\n      errors,\n    )(type.getNumberIndexType()!, {\n      ...explore,\n      escaped: false,\n      aliased: false,\n    });\n    setValue(value);\n\n    return array;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../../../schemas/metadata/MetadataArrayType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_array_type } from \"./emplace_metadata_array_type\";\n\nexport const iterate_metadata_array =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (checker.isArrayType(type) === false) {\n      const array: ts.Type | null = find_array_extended(checker)(new Map())(\n        type,\n      );\n      if (array !== null)\n        return iterate_metadata_array(checker)(options)(collection)(errors)(\n          meta,\n          array,\n          explore,\n        );\n      return false;\n    }\n\n    const arrayType: MetadataArrayType = emplace_metadata_array_type(checker)(\n      options,\n    )(collection)(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(\n      meta.arrays,\n      MetadataArray.create({\n        type: arrayType,\n        tags: [],\n      }),\n      (elem) => elem.type.name === arrayType.name,\n    );\n    return true;\n  };\n\nconst find_array_extended =\n  (checker: ts.TypeChecker) =>\n  (memory: Map<ts.Type, ts.Type | null>) =>\n  (type: ts.Type): ts.Type | null => {\n    const cached = memory.get(type);\n    if (cached !== undefined) return null;\n\n    memory.set(type, null);\n    const res: ts.Type | null = (() => {\n      if (type.isClassOrInterface() === false) return null;\n      for (const t of type.resolvedBaseTypes ?? [])\n        if (checker.isArrayType(t)) return t;\n        else {\n          const res: ts.Type | null = find_array_extended(checker)(memory)(t);\n          if (res !== null) return res;\n        }\n      return null;\n    })();\n    memory.set(type, res);\n    return res;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataEscaped } from \"../../../schemas/metadata/MetadataEscaped\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const iterate_metadata_escape =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (options.escape === false || explore.escaped === true) return false;\n\n    const escaped: ts.Type | null =\n      TypeFactory.getReturnType(checker)(type)(\"toJSON\");\n    if (escaped === null) return false;\n\n    if (meta.escaped === null) {\n      Writable(meta).escaped = MetadataEscaped.create({\n        original: Metadata.initialize(),\n        returns: Metadata.initialize(),\n      });\n    }\n    iterate_metadata(checker)(options)(collection)(errors)(\n      meta.escaped!.original,\n      type,\n      {\n        ...explore,\n        escaped: true,\n      },\n    );\n    iterate_metadata(checker)(options)(collection)(errors)(\n      meta.escaped!.returns,\n      escaped,\n      {\n        ...explore,\n        escaped: true,\n      },\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { IMetadataTypeTag } from \"../../../schemas/metadata/IMetadataTypeTag\";\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAtomic } from \"../../../schemas/metadata/MetadataAtomic\";\nimport { MetadataConstant } from \"../../../schemas/metadata/MetadataConstant\";\nimport { MetadataConstantValue } from \"../../../schemas/metadata/MetadataConstantValue\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataTypeTagFactory } from \"../../MetadataTypeTagFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\nimport { iterate_metadata } from \"./iterate_metadata\";\nimport { iterate_metadata_array } from \"./iterate_metadata_array\";\n\nexport const iterate_metadata_intersection =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!type.isIntersection()) return false;\n    else if (\n      type.types.every(\n        (child) =>\n          (child.getFlags() & ts.TypeFlags.Object) !== 0 &&\n          !checker.isArrayType(child) &&\n          !checker.isTupleType(child),\n      )\n    )\n      return false;\n\n    // COSTRUCT FAKE METADATA LIST\n    const fakeCollection: MetadataCollection = new MetadataCollection();\n    const fakeErrors: MetadataFactory.IError[] = [];\n    const children: Metadata[] = [\n      ...new Map(\n        type.types.map((t) => {\n          const m: Metadata = explore_metadata(checker)({\n            ...options,\n            absorb: true,\n          })(fakeCollection)(fakeErrors)(t, {\n            ...explore,\n            aliased: false,\n          });\n          return [m.getName(), m] as const;\n        }),\n      ).values(),\n    ];\n    if (fakeErrors.length) {\n      errors.push(...fakeErrors);\n      return true;\n    }\n\n    // ONLY ONE CHILD AFTER REMOVING DUPLICATES\n    if (children.length === 1) {\n      iterate_metadata(checker)(options)(collection)(errors)(\n        meta,\n        type.types[0]!,\n        explore,\n      );\n      return true;\n    } else if (children.every((c) => c.objects.length === c.size()))\n      return false;\n\n    // VALIDATE EACH TYPES\n    const individuals: (readonly [Metadata, number])[] = children\n      .map((child, i) => [child, i] as const)\n      .filter(\n        ([c]) =>\n          c.size() === 1 &&\n          (c.atomics.length === 1 ||\n            (c.constants.length === 1 && c.constants[0]!.values.length === 1) ||\n            c.arrays.length === 1),\n      );\n    if (individuals.length !== 1) return false;\n\n    const objects: Metadata[] = children.filter(\n      (c) =>\n        c.nullable === false &&\n        c.isRequired() === true &&\n        c.objects.length &&\n        c.objects.length === c.size() &&\n        c.objects.every((o) => o.properties.every((p) => p.value.optional)),\n    );\n    const arrays: Set<string> = new Set(\n      individuals.map(([c]) => c.arrays.map((a) => a.type.name)).flat(),\n    );\n    const atomics: Set<\"boolean\" | \"bigint\" | \"number\" | \"string\"> = new Set(\n      individuals.map(([c]) => [...c.atomics.map((a) => a.type)]).flat(),\n    );\n    const constants: Metadata[] = individuals\n      .filter((i) => i[0].constants.length === 1)\n      .map(([c]) => c);\n\n    // ESCAPE WHEN ONLY CONSTANT TYPES EXIST\n    if (\n      atomics.size + constants.length + arrays.size > 1 ||\n      individuals.length + objects.length !== children.length\n    ) {\n      errors.push({\n        name: children.map((c) => c.getName()).join(\" & \"),\n        explore: { ...explore },\n        messages: [\"nonsensible intersection\"],\n      });\n      return true;\n    }\n\n    // RE-GENERATE TYPE\n    const target: \"boolean\" | \"bigint\" | \"number\" | \"string\" | \"array\" =\n      arrays.size\n        ? \"array\"\n        : atomics.size\n          ? atomics.values().next().value\n          : constants[0]!.constants[0]!.type;\n    if (target === \"array\") {\n      const name: string = arrays.values().next().value;\n      if (!meta.arrays.some((a) => a.type.name === name)) {\n        iterate_metadata_array(checker)(options)(collection)(errors)(\n          meta,\n          type.types[individuals.find((i) => i[0].arrays.length === 1)![1]]!,\n          {\n            ...explore,\n            aliased: false,\n            escaped: false,\n          },\n        );\n      }\n    } else if (atomics.size)\n      ArrayUtil.add(\n        meta.atomics,\n        MetadataAtomic.create({\n          type: atomics.values().next().value as \"string\",\n          tags: [],\n        }),\n        (a, b) => a.type === b.type,\n      );\n    else\n      ArrayUtil.take(\n        ArrayUtil.take(\n          meta.constants,\n          (o) => o.type === target,\n          () =>\n            MetadataConstant.create({\n              type: target,\n              values: [],\n            }),\n        ).values,\n        (o) => o.value === constants[0]!.constants[0]!.values[0]!.value,\n        () =>\n          MetadataConstantValue.create({\n            value: constants[0]!.constants[0]!.values[0]!.value,\n            tags: [],\n          }),\n      );\n\n    // ASSIGN TAGS\n    if (objects.length) {\n      const tags: IMetadataTypeTag[] = MetadataTypeTagFactory.analyze(errors)(\n        target,\n      )(objects.map((om) => om.objects).flat(), explore);\n      if (tags.length)\n        if (target === \"array\") meta.arrays.at(-1)!.tags.push(tags);\n        else if (atomics.size)\n          meta.atomics.find((a) => a.type === target)!.tags.push(tags);\n        else {\n          const constant: MetadataConstant = meta.constants.find(\n            (c) => c.type === target,\n          )!;\n          const value: MetadataConstantValue = constant.values.find(\n            (v) => v.value === constants[0]!.constants[0]!.values[0]!.value,\n          )!;\n          value.tags ??= [];\n          value.tags.push(tags);\n        }\n    }\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_map =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    type = checker.getApparentType(type);\n\n    const name = TypeFactory.getFullName(checker)(type, type.getSymbol());\n    const generic = type.aliasSymbol\n      ? type.aliasTypeArguments\n      : checker.getTypeArguments(type as ts.TypeReference);\n    if (name.substring(0, 4) !== \"Map<\" || generic?.length !== 2) return false;\n\n    const key: ts.Type = generic[0]!;\n    const value: ts.Type = generic[1]!;\n\n    ArrayUtil.set(\n      meta.maps,\n      {\n        key: explore_metadata(checker)(options)(collection)(errors)(key, {\n          ...explore,\n          escaped: false,\n          aliased: false,\n        }),\n        value: explore_metadata(checker)(options)(collection)(errors)(value, {\n          ...explore,\n          escaped: false,\n          aliased: false,\n        }),\n      },\n      (elem) => `Map<${elem.key.getName()}, ${elem.value.getName()}>`,\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../../schemas/metadata/MetadataObject\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_object } from \"./emplace_metadata_object\";\n\nexport const iterate_metadata_object =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (meta: Metadata, type: ts.Type, ensure: boolean = false): boolean => {\n    if (ensure === false) {\n      const filter = (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n      if (\n        !filter(ts.TypeFlags.Object) &&\n        !type.isIntersection() &&\n        (type as any).intrinsicName !== \"object\"\n      )\n        return false;\n    }\n\n    const obj: MetadataObject = emplace_metadata_object(checker)(options)(\n      collection,\n    )(errors)(type, meta.nullable);\n    ArrayUtil.add(meta.objects, obj, (elem) => elem.name === obj.name);\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../../schemas/metadata/MetadataProperty\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { CommentFactory } from \"../../CommentFactory\";\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataHelper } from \"./MetadataHelper\";\nimport { explore_metadata } from \"./explore_metadata\";\nimport { iterate_metadata_coalesce } from \"./iterate_metadata_coalesce\";\n\nexport const emplace_metadata_object =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (parent: ts.Type, nullable: boolean): MetadataObject => {\n    // EMPLACE OBJECT\n    const [obj, newbie] = collection.emplace(checker, parent);\n    ArrayUtil.add(obj.nullables, nullable, (elem) => elem === nullable);\n\n    if (newbie === false) return obj;\n\n    // PREPARE ASSETS\n    const isClass: boolean = parent.isClass();\n    const pred: (node: ts.Declaration) => boolean = isClass\n      ? (node) => {\n          const kind: ts.SyntaxKind | undefined = node\n            .getChildren()[0]\n            ?.getChildren()[0]?.kind;\n          return (\n            kind !== ts.SyntaxKind.PrivateKeyword &&\n            kind !== ts.SyntaxKind.ProtectedKeyword &&\n            isProperty(node)\n          );\n        }\n      : (node) => isProperty(node);\n\n    const insert =\n      (key: Metadata) =>\n      (value: Metadata) =>\n      (\n        symbol: ts.Symbol | undefined,\n        filter?: (doc: ts.JSDocTagInfo) => boolean,\n      ): MetadataProperty => {\n        // COMMENTS AND TAGS\n        const description: string | null = symbol\n          ? CommentFactory.description(symbol) ?? null\n          : null;\n        const jsDocTags: ts.JSDocTagInfo[] = (\n          symbol?.getJsDocTags() ?? []\n        ).filter(filter ?? (() => true));\n\n        // THE PROPERTY\n        const property = MetadataProperty.create({\n          key,\n          value,\n          description,\n          jsDocTags,\n        });\n        obj.properties.push(property);\n        return property;\n      };\n\n    //----\n    // REGULAR PROPERTIES\n    //----\n    for (const prop of parent.getApparentProperties()) {\n      // CHECK INTERNAL TAG\n      if (\n        (prop.getJsDocTags(checker) ?? []).find(\n          (tag) => tag.name === \"internal\",\n        ) !== undefined\n      )\n        continue;\n\n      // CHECK NODE IS A FORMAL PROPERTY\n      const [node, type] = (() => {\n        const node = prop.getDeclarations()?.[0] as\n          | ts.PropertyDeclaration\n          | undefined;\n        const type: ts.Type | undefined = node\n          ? checker.getTypeOfSymbolAtLocation(prop, node)\n          : checker.getTypeOfPropertyOfType(parent, prop.name);\n        return [node, type];\n      })();\n      if ((node && pred(node) === false) || type === undefined) continue;\n\n      // GET EXACT TYPE\n      const key: Metadata = MetadataHelper.literal_to_metadata(prop.name);\n      const value: Metadata = explore_metadata(checker)(options)(collection)(\n        errors,\n      )(type, {\n        top: false,\n        object: obj,\n        property: prop.name,\n        nested: null,\n        escaped: false,\n        aliased: false,\n      });\n      Writable(value).optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n      insert(key)(value)(prop);\n    }\n\n    //----\n    // DYNAMIC PROPERTIES\n    //----\n    for (const index of checker.getIndexInfosOfType(parent)) {\n      // GET EXACT TYPE\n      const analyzer = (type: ts.Type) => (property: {} | null) =>\n        explore_metadata(checker)(options)(collection)(errors)(type, {\n          top: false,\n          object: obj,\n          property,\n          nested: null,\n          escaped: false,\n          aliased: false,\n        });\n      const key: Metadata = analyzer(index.keyType)(null);\n      const value: Metadata = analyzer(index.type)({});\n\n      if (\n        key.atomics.length +\n          key.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0) +\n          key.templates.length +\n          key.natives.filter(\n            (type) =>\n              type === \"Boolean\" ||\n              type === \"BigInt\" ||\n              type === \"Number\" ||\n              type === \"String\",\n          ).length !==\n        key.size()\n      )\n        errors.push({\n          name: key.getName(),\n          explore: {\n            top: false,\n            object: obj,\n            property: \"[key]\",\n            nested: null,\n            escaped: false,\n            aliased: false,\n          },\n          messages: [],\n        });\n\n      // INSERT WITH REQUIRED CONFIGURATION\n      insert(key)(value)(\n        index.declaration?.parent\n          ? checker.getSymbolAtLocation(index.declaration.parent)\n          : undefined,\n        (doc) => doc.name !== \"default\",\n      );\n    }\n    return obj;\n  };\n\nconst isProperty = (node: ts.Declaration) =>\n  ts.isParameter(node) ||\n  ts.isPropertyDeclaration(node) ||\n  ts.isPropertyAssignment(node) ||\n  ts.isPropertySignature(node) ||\n  ts.isTypeLiteralNode(node);\n\nconst iterate_optional_coalesce = (meta: Metadata, type: ts.Type): void => {\n  if (type.isUnionOrIntersection())\n    type.types.forEach((child) => iterate_optional_coalesce(meta, child));\n  else iterate_metadata_coalesce(meta, type);\n};\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_set =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    type = checker.getApparentType(type);\n\n    const name = TypeFactory.getFullName(checker)(type, type.getSymbol());\n    const generic = type.aliasSymbol\n      ? type.aliasTypeArguments\n      : checker.getTypeArguments(type as ts.TypeReference);\n    if (name.substring(0, 4) !== \"Set<\" || generic?.length !== 1) return false;\n\n    const key: ts.Type = generic[0]!;\n    ArrayUtil.set(\n      meta.sets,\n      explore_metadata(checker)(options)(collection)(errors)(key, {\n        ...explore,\n        escaped: false,\n        aliased: false,\n      }),\n      (elem) => elem.getName(),\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataHelper } from \"./MetadataHelper\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_template =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    const filter = (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n    if (!filter(ts.TypeFlags.TemplateLiteral)) return false;\n\n    const template: ts.TemplateLiteralType = type as ts.TemplateLiteralType;\n    const row: Metadata[] = [];\n\n    template.texts.forEach((text, i) => {\n      // TEXT LITERAL TYPE\n      if (text !== \"\") row.push(MetadataHelper.literal_to_metadata(text));\n\n      // BINDED TEMPLATE TYPE\n      const binded: ts.Type | undefined = template.types[i];\n      if (binded)\n        row.push(\n          explore_metadata(checker)(options)(collection)(errors)(binded, {\n            ...explore,\n            escaped: false,\n            aliased: false,\n          }),\n        );\n    });\n    meta.templates.push(row);\n\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataTupleType } from \"../../../schemas/metadata/MetadataTupleType\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_tuple =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.TupleType,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataTupleType => {\n    // CHECK EXISTENCE\n    const [tuple, newbie, closure] = collection.emplaceTuple(checker, type);\n    ArrayUtil.add(tuple.nullables, nullable);\n    if (newbie === false) return tuple;\n\n    // CONSTRUCT ELEMENT TYPES\n    const flagList: readonly ts.ElementFlags[] =\n      type.elementFlags ?? (type.target as ts.TupleType)?.elementFlags ?? [];\n    const elements: Metadata[] = checker\n      .getTypeArguments(type as ts.TypeReference)\n      .map((elem, i) => {\n        const child: Metadata = explore_metadata(checker)(options)(collection)(\n          errors,\n        )(elem, {\n          ...explore,\n          nested: tuple,\n          aliased: false,\n          escaped: false,\n        });\n\n        // CHECK OPTIONAL\n        const flag: ts.ElementFlags | undefined = flagList[i];\n        if (flag === ts.ElementFlags.Optional) Writable(child).optional = true;\n\n        // REST TYPE\n        if (flag !== ts.ElementFlags.Rest) return child;\n        const wrapper: Metadata = Metadata.initialize();\n        Writable(wrapper).rest = child;\n        return wrapper;\n      });\n    closure(elements);\n\n    return tuple;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataTuple } from \"../../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../../schemas/metadata/MetadataTupleType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_tuple } from \"./emplace_metadata_tuple\";\n\nexport const iterate_metadata_tuple =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.TupleType,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!checker.isTupleType(type)) return false;\n\n    const tupleType: MetadataTupleType = emplace_metadata_tuple(checker)(\n      options,\n    )(collection)(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(\n      meta.tuples,\n      MetadataTuple.create({\n        type: tupleType,\n        tags: [],\n      }),\n      (elem) => elem.type.name === tupleType.name,\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const iterate_metadata_union =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!type.isUnion()) return false;\n    type.types.forEach((t) =>\n      iterate_metadata(checker)(options)(collection)(errors)(meta, t, {\n        ...explore,\n        aliased: false,\n      }),\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { iterate_metadata_alias } from \"./iterate_metadata_alias\";\nimport { iterate_metadata_array } from \"./iterate_metadata_array\";\nimport { iterate_metadata_atomic } from \"./iterate_metadata_atomic\";\nimport { iterate_metadata_coalesce } from \"./iterate_metadata_coalesce\";\nimport { iterate_metadata_constant } from \"./iterate_metadata_constant\";\nimport { iterate_metadata_escape } from \"./iterate_metadata_escape\";\nimport { iterate_metadata_intersection } from \"./iterate_metadata_intersection\";\nimport { iterate_metadata_map } from \"./iterate_metadata_map\";\nimport { iterate_metadata_native } from \"./iterate_metadata_native\";\nimport { iterate_metadata_object } from \"./iterate_metadata_object\";\nimport { iterate_metadata_set } from \"./iterate_metadata_set\";\nimport { iterate_metadata_template } from \"./iterate_metadata_template\";\nimport { iterate_metadata_tuple } from \"./iterate_metadata_tuple\";\nimport { iterate_metadata_union } from \"./iterate_metadata_union\";\n\nexport const iterate_metadata =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (meta: Metadata, type: ts.Type, explore: MetadataFactory.IExplore): void => {\n    if (type.isTypeParameter() === true) {\n      errors.push({\n        name: TypeFactory.getFullName(checker)(type),\n        explore: { ...explore },\n        messages: [\"non-specified generic argument found.\"],\n      });\n      return;\n    }\n    // CHECK SPECIAL CASES\n    else if (\n      (explore.aliased !== true &&\n        iterate_metadata_alias(checker)(options)(collection)(errors)(\n          meta,\n          type,\n          explore,\n        )) ||\n      iterate_metadata_intersection(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_union(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_escape(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      )\n    )\n      return;\n\n    // ITERATE CASES\n    iterate_metadata_coalesce(meta, type) ||\n      iterate_metadata_constant(checker)(options)(meta, type) ||\n      iterate_metadata_template(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_atomic(meta, type) ||\n      iterate_metadata_tuple(checker)(options)(collection)(errors)(\n        meta,\n        type as ts.TupleType,\n        explore,\n      ) ||\n      iterate_metadata_array(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_native(checker)(meta, type) ||\n      iterate_metadata_map(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_set(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_object(checker)(options)(collection)(errors)(meta, type);\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emend_metadata_atomics } from \"./emend_metadata_atomics\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const explore_metadata =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (type: ts.Type | null, explore: MetadataFactory.IExplore): Metadata => {\n    // CONSTRUCT METADATA\n    const meta: Metadata = Metadata.initialize(explore.escaped);\n    if (type === null) return meta;\n\n    // ITERATE TYPESCRIPT TYPES\n    iterate_metadata(checker)(options)(collection)(errors)(meta, type, explore);\n    emend_metadata_atomics(meta);\n    if (meta.escaped) {\n      emend_metadata_atomics(meta.escaped.original);\n      emend_metadata_atomics(meta.escaped.returns);\n    }\n    return meta;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAlias } from \"../../../schemas/metadata/MetadataAlias\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_alias =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.Type,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataAlias => {\n    // CHECK EXISTENCE\n    const [alias, newbie, closure] = collection.emplaceAlias(\n      checker,\n      type,\n      type.aliasSymbol!,\n    );\n    ArrayUtil.add(alias.nullables, nullable);\n    if (newbie === false) return alias;\n\n    // CONSTRUCT VALUE TYPE\n    const value: Metadata = explore_metadata(checker)(options)(collection)(\n      errors,\n    )(type, {\n      ...explore,\n      escaped: false,\n      aliased: true,\n    });\n    closure(value);\n    return alias;\n  };\n"],"mappings":"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","names":["iterate_metadata_alias","checker","options","collection","errors","meta","type","explore","absorb","aliasSymbol","undefined","node","declarations","alias","emplace_metadata_alias","nullable","ArrayUtil","add","aliases","elem","name","emplace_metadata_array_type","checker","options","collection","errors","type","nullable","explore","array","newbie","setValue","emplaceArray","ArrayUtil","add","nullables","value","explore_metadata","getNumberIndexType","escaped","aliased","iterate_metadata_array","checker","options","collection","errors","meta","type","explore","isArrayType","array","find_array_extended","Map","arrayType","emplace_metadata_array_type","nullable","ArrayUtil","add","arrays","MetadataArray","create","tags","elem","name","memory","cached","get","undefined","set","res","isClassOrInterface","t","resolvedBaseTypes","iterate_metadata_escape","checker","options","collection","errors","meta","type","explore","escape","escaped","TypeFactory","getReturnType","Writable","MetadataEscaped","create","original","Metadata","initialize","returns","iterate_metadata","ts","iterate_metadata_intersection","checker","options","collection","errors","meta","type","explore","isIntersection","types","every","child","getFlags","ts","TypeFlags","Object","isArrayType","isTupleType","fakeCollection","MetadataCollection","fakeErrors","children","Map","map","t","m","explore_metadata","absorb","aliased","getName","values","length","push","iterate_metadata","c","objects","size","individuals","i","filter","atomics","constants","arrays","nullable","isRequired","o","properties","p","value","optional","Set","a","name","flat","join","messages","target","next","some","iterate_metadata_array","find","escaped","ArrayUtil","add","MetadataAtomic","create","tags","b","take","MetadataConstant","MetadataConstantValue","MetadataTypeTagFactory","analyze","om","at","constant","v","iterate_metadata_map","checker","options","collection","errors","meta","type","explore","getApparentType","name","TypeFactory","getFullName","getSymbol","generic","aliasSymbol","aliasTypeArguments","getTypeArguments","substring","length","key","value","ArrayUtil","set","maps","explore_metadata","escaped","aliased","elem","getName","ts","ts","emplace_metadata_object","checker","options","collection","errors","parent","nullable","obj","newbie","emplace","ArrayUtil","add","nullables","elem","isClass","pred","node","kind","getChildren","ts","SyntaxKind","PrivateKeyword","ProtectedKeyword","isProperty","insert","key","value","symbol","filter","description","CommentFactory","jsDocTags","getJsDocTags","property","MetadataProperty","create","properties","push","prop","getApparentProperties","find","tag","name","undefined","type","getDeclarations","getTypeOfSymbolAtLocation","getTypeOfPropertyOfType","MetadataHelper","literal_to_metadata","explore_metadata","top","object","nested","escaped","aliased","Writable","optional","flags","SymbolFlags","Optional","index","getIndexInfosOfType","analyzer","keyType","atomics","length","constants","map","c","values","reduce","a","b","templates","natives","size","getName","explore","messages","declaration","getSymbolAtLocation","doc","isParameter","isPropertyDeclaration","isPropertyAssignment","isPropertySignature","isTypeLiteralNode","iterate_metadata_object","checker","options","collection","errors","meta","type","ensure","filter","flag","getFlags","ts","TypeFlags","Object","isIntersection","intrinsicName","obj","emplace_metadata_object","nullable","ArrayUtil","add","objects","elem","name","iterate_metadata_set","checker","options","collection","errors","meta","type","explore","getApparentType","name","TypeFactory","getFullName","getSymbol","generic","aliasSymbol","aliasTypeArguments","getTypeArguments","substring","length","key","ArrayUtil","set","sets","explore_metadata","escaped","aliased","elem","getName","ts","iterate_metadata_template","checker","options","collection","errors","meta","type","explore","filter","flag","getFlags","ts","TypeFlags","TemplateLiteral","template","row","texts","forEach","text","i","push","MetadataHelper","literal_to_metadata","binded","types","explore_metadata","escaped","aliased","templates","ts","emplace_metadata_tuple","checker","options","collection","errors","type","nullable","explore","tuple","newbie","closure","emplaceTuple","ArrayUtil","add","nullables","flagList","elementFlags","target","elements","getTypeArguments","map","elem","i","child","explore_metadata","nested","aliased","escaped","flag","ts","ElementFlags","Optional","Writable","optional","Rest","wrapper","Metadata","initialize","rest","iterate_metadata_tuple","checker","options","collection","errors","meta","type","explore","isTupleType","tupleType","emplace_metadata_tuple","nullable","ArrayUtil","add","tuples","MetadataTuple","create","tags","elem","name","iterate_metadata_union","checker","options","collection","errors","meta","type","explore","isUnion","types","forEach","t","iterate_metadata","aliased","iterate_metadata","checker","options","collection","errors","meta","type","explore","isTypeParameter","push","name","TypeFactory","getFullName","messages","aliased","iterate_metadata_alias","iterate_metadata_intersection","iterate_metadata_union","iterate_metadata_escape","iterate_metadata_coalesce","iterate_metadata_constant","iterate_metadata_template","iterate_metadata_atomic","iterate_metadata_tuple","iterate_metadata_array","iterate_metadata_native","iterate_metadata_map","iterate_metadata_set","iterate_metadata_object","explore_metadata","checker","options","collection","errors","type","explore","meta","Metadata","initialize","escaped","iterate_metadata","emend_metadata_atomics","original","returns","emplace_metadata_alias","checker","options","collection","errors","type","nullable","explore","alias","newbie","closure","emplaceAlias","aliasSymbol","ArrayUtil","add","nullables","value","explore_metadata","escaped","aliased"]}