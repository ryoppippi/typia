{"version":3,"sources":["../src/factories/internal/metadata/iterate_metadata_alias.ts","../src/factories/internal/metadata/emplace_metadata_array_type.ts","../src/factories/internal/metadata/iterate_metadata_array.ts","../src/factories/internal/metadata/iterate_metadata_escape.ts","../src/factories/internal/metadata/iterate_metadata_intersection.ts","../src/factories/internal/metadata/iterate_metadata_map.ts","../src/factories/internal/metadata/iterate_metadata_object.ts","../src/factories/internal/metadata/emplace_metadata_object.ts","../src/factories/internal/metadata/iterate_metadata_set.ts","../src/factories/internal/metadata/iterate_metadata_template.ts","../src/factories/internal/metadata/emplace_metadata_tuple.ts","../src/factories/internal/metadata/iterate_metadata_tuple.ts","../src/factories/internal/metadata/iterate_metadata_union.ts","../src/factories/internal/metadata/iterate_metadata.ts","../src/factories/internal/metadata/explore_metadata.ts","../src/factories/internal/metadata/emplace_metadata_alias.ts"],"names":["iterate_metadata_alias","checker","options","collection","errors","meta","type","explore","absorb","aliasSymbol","undefined","node","declarations","alias","emplace_metadata_alias","nullable","ArrayUtil","add","aliases","elem","name","emplace_metadata_array_type","array","newbie","setValue","emplaceArray","nullables","value","explore_metadata","getNumberIndexType","escaped","aliased","iterate_metadata_array","isArrayType","find_array_extended","Map","arrayType","arrays","MetadataArray","create","tags","memory","cached","get","set","res","isClassOrInterface","t","resolvedBaseTypes","iterate_metadata_escape","escape","TypeFactory","getReturnType","Writable","MetadataEscaped","original","Metadata","initialize","returns","iterate_metadata","ts","iterate_metadata_intersection","isIntersection","types","every","child","getFlags","TypeFlags","Object","isTupleType","fakeCollection","MetadataCollection","fakeErrors","children","map","m","getName","values","length","push","c","objects","size","individuals","i","filter","atomics","constants","isRequired","o","properties","p","optional","Set","a","flat","join","messages","target","next","some","find","MetadataAtomic","b","take","MetadataConstant","MetadataConstantValue","MetadataTypeTagFactory","analyze","om","at","constant","v","iterate_metadata_map","getApparentType","getFullName","getSymbol","generic","aliasTypeArguments","getTypeArguments","substring","key","maps","emplace_metadata_object","parent","obj","emplace","isClass","pred","kind","getChildren","SyntaxKind","PrivateKeyword","ProtectedKeyword","isProperty","insert","symbol","description","CommentFactory","jsDocTags","getJsDocTags","property","MetadataProperty","prop","getApparentProperties","tag","getDeclarations","getTypeOfSymbolAtLocation","getTypeOfPropertyOfType","MetadataHelper","literal_to_metadata","top","object","nested","flags","SymbolFlags","Optional","index","getIndexInfosOfType","analyzer","keyType","reduce","templates","natives","declaration","getSymbolAtLocation","doc","isParameter","isPropertyDeclaration","isPropertyAssignment","isPropertySignature","isTypeLiteralNode","iterate_metadata_object","ensure","flag","intrinsicName","iterate_metadata_set","sets","iterate_metadata_template","TemplateLiteral","template","row","texts","forEach","text","binded","emplace_metadata_tuple","tuple","closure","emplaceTuple","flagList","elementFlags","elements","ElementFlags","Rest","wrapper","rest","iterate_metadata_tuple","tupleType","tuples","MetadataTuple","iterate_metadata_union","isUnion","isTypeParameter","iterate_metadata_coalesce","iterate_metadata_constant","iterate_metadata_atomic","iterate_metadata_native","emend_metadata_atomics","emplaceAlias"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAlias } from \"../../../schemas/metadata/MetadataAlias\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_alias } from \"./emplace_metadata_alias\";\n\nexport const iterate_metadata_alias =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (options.absorb !== false || type.aliasSymbol === undefined)\n      return false;\n\n    const node: ts.Declaration | undefined = type.aliasSymbol.declarations?.[0];\n    if (node === undefined) return false;\n\n    // CONSTRUCT DEFINITION\n    const alias: MetadataAlias = emplace_metadata_alias(checker)(options)(\n      collection,\n    )(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(meta.aliases, alias, (elem) => elem.name === alias.name);\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../../schemas/metadata/MetadataArrayType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_array_type =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.Type,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataArrayType => {\n    // CHECK EXISTENCE\n    const [array, newbie, setValue] = collection.emplaceArray(checker, type);\n    ArrayUtil.add(array.nullables, nullable);\n    if (newbie === false) return array;\n\n    // CONSTRUCT VALUE TYPE\n    const value: Metadata = explore_metadata(checker)(options)(collection)(\n      errors,\n    )(type.getNumberIndexType()!, {\n      ...explore,\n      escaped: false,\n      aliased: false,\n    });\n    setValue(value);\n\n    return array;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../../../schemas/metadata/MetadataArrayType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_array_type } from \"./emplace_metadata_array_type\";\n\nexport const iterate_metadata_array =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (checker.isArrayType(type) === false) {\n      const array: ts.Type | null = find_array_extended(checker)(new Map())(\n        type,\n      );\n      if (array !== null)\n        return iterate_metadata_array(checker)(options)(collection)(errors)(\n          meta,\n          array,\n          explore,\n        );\n      return false;\n    }\n\n    const arrayType: MetadataArrayType = emplace_metadata_array_type(checker)(\n      options,\n    )(collection)(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(\n      meta.arrays,\n      MetadataArray.create({\n        type: arrayType,\n        tags: [],\n      }),\n      (elem) => elem.type.name === arrayType.name,\n    );\n    return true;\n  };\n\nconst find_array_extended =\n  (checker: ts.TypeChecker) =>\n  (memory: Map<ts.Type, ts.Type | null>) =>\n  (type: ts.Type): ts.Type | null => {\n    const cached = memory.get(type);\n    if (cached !== undefined) return null;\n\n    memory.set(type, null);\n    const res: ts.Type | null = (() => {\n      if (type.isClassOrInterface() === false) return null;\n      for (const t of type.resolvedBaseTypes ?? [])\n        if (checker.isArrayType(t)) return t;\n        else {\n          const res: ts.Type | null = find_array_extended(checker)(memory)(t);\n          if (res !== null) return res;\n        }\n      return null;\n    })();\n    memory.set(type, res);\n    return res;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataEscaped } from \"../../../schemas/metadata/MetadataEscaped\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const iterate_metadata_escape =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (options.escape === false || explore.escaped === true) return false;\n\n    const escaped: ts.Type | null =\n      TypeFactory.getReturnType(checker)(type)(\"toJSON\");\n    if (escaped === null) return false;\n\n    if (meta.escaped === null) {\n      Writable(meta).escaped = MetadataEscaped.create({\n        original: Metadata.initialize(),\n        returns: Metadata.initialize(),\n      });\n    }\n    iterate_metadata(checker)(options)(collection)(errors)(\n      meta.escaped!.original,\n      type,\n      {\n        ...explore,\n        escaped: true,\n      },\n    );\n    iterate_metadata(checker)(options)(collection)(errors)(\n      meta.escaped!.returns,\n      escaped,\n      {\n        ...explore,\n        escaped: true,\n      },\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { IMetadataTypeTag } from \"../../../schemas/metadata/IMetadataTypeTag\";\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAtomic } from \"../../../schemas/metadata/MetadataAtomic\";\nimport { MetadataConstant } from \"../../../schemas/metadata/MetadataConstant\";\nimport { MetadataConstantValue } from \"../../../schemas/metadata/MetadataConstantValue\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataTypeTagFactory } from \"../../MetadataTypeTagFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\nimport { iterate_metadata } from \"./iterate_metadata\";\nimport { iterate_metadata_array } from \"./iterate_metadata_array\";\n\nexport const iterate_metadata_intersection =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!type.isIntersection()) return false;\n    else if (\n      type.types.every(\n        (child) =>\n          (child.getFlags() & ts.TypeFlags.Object) !== 0 &&\n          !checker.isArrayType(child) &&\n          !checker.isTupleType(child),\n      )\n    )\n      return false;\n\n    // COSTRUCT FAKE METADATA LIST\n    const fakeCollection: MetadataCollection = new MetadataCollection();\n    const fakeErrors: MetadataFactory.IError[] = [];\n    const children: Metadata[] = [\n      ...new Map(\n        type.types.map((t) => {\n          const m: Metadata = explore_metadata(checker)({\n            ...options,\n            absorb: true,\n          })(fakeCollection)(fakeErrors)(t, {\n            ...explore,\n            aliased: false,\n          });\n          return [m.getName(), m] as const;\n        }),\n      ).values(),\n    ];\n    if (fakeErrors.length) {\n      errors.push(...fakeErrors);\n      return true;\n    }\n\n    // ONLY ONE CHILD AFTER REMOVING DUPLICATES\n    if (children.length === 1) {\n      iterate_metadata(checker)(options)(collection)(errors)(\n        meta,\n        type.types[0]!,\n        explore,\n      );\n      return true;\n    } else if (children.every((c) => c.objects.length === c.size()))\n      return false;\n\n    // VALIDATE EACH TYPES\n    const individuals: (readonly [Metadata, number])[] = children\n      .map((child, i) => [child, i] as const)\n      .filter(\n        ([c]) =>\n          c.size() === 1 &&\n          (c.atomics.length === 1 ||\n            (c.constants.length === 1 && c.constants[0]!.values.length === 1) ||\n            c.arrays.length === 1),\n      );\n    if (individuals.length !== 1) return false;\n\n    const objects: Metadata[] = children.filter(\n      (c) =>\n        c.nullable === false &&\n        c.isRequired() === true &&\n        c.objects.length &&\n        c.objects.length === c.size() &&\n        c.objects.every((o) => o.properties.every((p) => p.value.optional)),\n    );\n    const arrays: Set<string> = new Set(\n      individuals.map(([c]) => c.arrays.map((a) => a.type.name)).flat(),\n    );\n    const atomics: Set<\"boolean\" | \"bigint\" | \"number\" | \"string\"> = new Set(\n      individuals.map(([c]) => [...c.atomics.map((a) => a.type)]).flat(),\n    );\n    const constants: Metadata[] = individuals\n      .filter((i) => i[0].constants.length === 1)\n      .map(([c]) => c);\n\n    // ESCAPE WHEN ONLY CONSTANT TYPES EXIST\n    if (\n      atomics.size + constants.length + arrays.size > 1 ||\n      individuals.length + objects.length !== children.length\n    ) {\n      errors.push({\n        name: children.map((c) => c.getName()).join(\" & \"),\n        explore: { ...explore },\n        messages: [\"nonsensible intersection\"],\n      });\n      return true;\n    }\n\n    // RE-GENERATE TYPE\n    const target: \"boolean\" | \"bigint\" | \"number\" | \"string\" | \"array\" =\n      arrays.size\n        ? \"array\"\n        : atomics.size\n          ? atomics.values().next().value\n          : constants[0]!.constants[0]!.type;\n    if (target === \"array\") {\n      const name: string = arrays.values().next().value;\n      if (!meta.arrays.some((a) => a.type.name === name)) {\n        iterate_metadata_array(checker)(options)(collection)(errors)(\n          meta,\n          type.types[individuals.find((i) => i[0].arrays.length === 1)![1]]!,\n          {\n            ...explore,\n            aliased: false,\n            escaped: false,\n          },\n        );\n      }\n    } else if (atomics.size)\n      ArrayUtil.add(\n        meta.atomics,\n        MetadataAtomic.create({\n          type: atomics.values().next().value as \"string\",\n          tags: [],\n        }),\n        (a, b) => a.type === b.type,\n      );\n    else\n      ArrayUtil.take(\n        ArrayUtil.take(\n          meta.constants,\n          (o) => o.type === target,\n          () =>\n            MetadataConstant.create({\n              type: target,\n              values: [],\n            }),\n        ).values,\n        (o) => o.value === constants[0]!.constants[0]!.values[0]!.value,\n        () =>\n          MetadataConstantValue.create({\n            value: constants[0]!.constants[0]!.values[0]!.value,\n            tags: [],\n          }),\n      );\n\n    // ASSIGN TAGS\n    if (objects.length) {\n      const tags: IMetadataTypeTag[] = MetadataTypeTagFactory.analyze(errors)(\n        target,\n      )(objects.map((om) => om.objects).flat(), explore);\n      if (tags.length)\n        if (target === \"array\") meta.arrays.at(-1)!.tags.push(tags);\n        else if (atomics.size)\n          meta.atomics.find((a) => a.type === target)!.tags.push(tags);\n        else {\n          const constant: MetadataConstant = meta.constants.find(\n            (c) => c.type === target,\n          )!;\n          const value: MetadataConstantValue = constant.values.find(\n            (v) => v.value === constants[0]!.constants[0]!.values[0]!.value,\n          )!;\n          value.tags ??= [];\n          value.tags.push(tags);\n        }\n    }\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_map =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    type = checker.getApparentType(type);\n\n    const name = TypeFactory.getFullName(checker)(type, type.getSymbol());\n    const generic = type.aliasSymbol\n      ? type.aliasTypeArguments\n      : checker.getTypeArguments(type as ts.TypeReference);\n    if (name.substring(0, 4) !== \"Map<\" || generic?.length !== 2) return false;\n\n    const key: ts.Type = generic[0]!;\n    const value: ts.Type = generic[1]!;\n\n    ArrayUtil.set(\n      meta.maps,\n      {\n        key: explore_metadata(checker)(options)(collection)(errors)(key, {\n          ...explore,\n          escaped: false,\n          aliased: false,\n        }),\n        value: explore_metadata(checker)(options)(collection)(errors)(value, {\n          ...explore,\n          escaped: false,\n          aliased: false,\n        }),\n      },\n      (elem) => `Map<${elem.key.getName()}, ${elem.value.getName()}>`,\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../../schemas/metadata/MetadataObject\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_object } from \"./emplace_metadata_object\";\n\nexport const iterate_metadata_object =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (meta: Metadata, type: ts.Type, ensure: boolean = false): boolean => {\n    if (ensure === false) {\n      const filter = (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n      if (\n        !filter(ts.TypeFlags.Object) &&\n        !type.isIntersection() &&\n        (type as any).intrinsicName !== \"object\"\n      )\n        return false;\n    }\n\n    const obj: MetadataObject = emplace_metadata_object(checker)(options)(\n      collection,\n    )(errors)(type, meta.nullable);\n    ArrayUtil.add(meta.objects, obj, (elem) => elem.name === obj.name);\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../../schemas/metadata/MetadataProperty\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { CommentFactory } from \"../../CommentFactory\";\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataHelper } from \"./MetadataHelper\";\nimport { explore_metadata } from \"./explore_metadata\";\nimport { iterate_metadata_coalesce } from \"./iterate_metadata_coalesce\";\n\nexport const emplace_metadata_object =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (parent: ts.Type, nullable: boolean): MetadataObject => {\n    // EMPLACE OBJECT\n    const [obj, newbie] = collection.emplace(checker, parent);\n    ArrayUtil.add(obj.nullables, nullable, (elem) => elem === nullable);\n\n    if (newbie === false) return obj;\n\n    // PREPARE ASSETS\n    const isClass: boolean = parent.isClass();\n    const pred: (node: ts.Declaration) => boolean = isClass\n      ? (node) => {\n          const kind: ts.SyntaxKind | undefined = node\n            .getChildren()[0]\n            ?.getChildren()[0]?.kind;\n          return (\n            kind !== ts.SyntaxKind.PrivateKeyword &&\n            kind !== ts.SyntaxKind.ProtectedKeyword &&\n            isProperty(node)\n          );\n        }\n      : (node) => isProperty(node);\n\n    const insert =\n      (key: Metadata) =>\n      (value: Metadata) =>\n      (\n        symbol: ts.Symbol | undefined,\n        filter?: (doc: ts.JSDocTagInfo) => boolean,\n      ): MetadataProperty => {\n        // COMMENTS AND TAGS\n        const description: string | null = symbol\n          ? CommentFactory.description(symbol) ?? null\n          : null;\n        const jsDocTags: ts.JSDocTagInfo[] = (\n          symbol?.getJsDocTags() ?? []\n        ).filter(filter ?? (() => true));\n\n        // THE PROPERTY\n        const property = MetadataProperty.create({\n          key,\n          value,\n          description,\n          jsDocTags,\n        });\n        obj.properties.push(property);\n        return property;\n      };\n\n    //----\n    // REGULAR PROPERTIES\n    //----\n    for (const prop of parent.getApparentProperties()) {\n      // CHECK INTERNAL TAG\n      if (\n        (prop.getJsDocTags(checker) ?? []).find(\n          (tag) => tag.name === \"internal\",\n        ) !== undefined\n      )\n        continue;\n\n      // CHECK NODE IS A FORMAL PROPERTY\n      const [node, type] = (() => {\n        const node = prop.getDeclarations()?.[0] as\n          | ts.PropertyDeclaration\n          | undefined;\n        const type: ts.Type | undefined = node\n          ? checker.getTypeOfSymbolAtLocation(prop, node)\n          : checker.getTypeOfPropertyOfType(parent, prop.name);\n        return [node, type];\n      })();\n      if ((node && pred(node) === false) || type === undefined) continue;\n\n      // GET EXACT TYPE\n      const key: Metadata = MetadataHelper.literal_to_metadata(prop.name);\n      const value: Metadata = explore_metadata(checker)(options)(collection)(\n        errors,\n      )(type, {\n        top: false,\n        object: obj,\n        property: prop.name,\n        nested: null,\n        escaped: false,\n        aliased: false,\n      });\n      Writable(value).optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n      insert(key)(value)(prop);\n    }\n\n    //----\n    // DYNAMIC PROPERTIES\n    //----\n    for (const index of checker.getIndexInfosOfType(parent)) {\n      // GET EXACT TYPE\n      const analyzer = (type: ts.Type) => (property: {} | null) =>\n        explore_metadata(checker)(options)(collection)(errors)(type, {\n          top: false,\n          object: obj,\n          property,\n          nested: null,\n          escaped: false,\n          aliased: false,\n        });\n      const key: Metadata = analyzer(index.keyType)(null);\n      const value: Metadata = analyzer(index.type)({});\n\n      if (\n        key.atomics.length +\n          key.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0) +\n          key.templates.length +\n          key.natives.filter(\n            (type) =>\n              type === \"Boolean\" ||\n              type === \"BigInt\" ||\n              type === \"Number\" ||\n              type === \"String\",\n          ).length !==\n        key.size()\n      )\n        errors.push({\n          name: key.getName(),\n          explore: {\n            top: false,\n            object: obj,\n            property: \"[key]\",\n            nested: null,\n            escaped: false,\n            aliased: false,\n          },\n          messages: [],\n        });\n\n      // INSERT WITH REQUIRED CONFIGURATION\n      insert(key)(value)(\n        index.declaration?.parent\n          ? checker.getSymbolAtLocation(index.declaration.parent)\n          : undefined,\n        (doc) => doc.name !== \"default\",\n      );\n    }\n    return obj;\n  };\n\nconst isProperty = (node: ts.Declaration) =>\n  ts.isParameter(node) ||\n  ts.isPropertyDeclaration(node) ||\n  ts.isPropertyAssignment(node) ||\n  ts.isPropertySignature(node) ||\n  ts.isTypeLiteralNode(node);\n\nconst iterate_optional_coalesce = (meta: Metadata, type: ts.Type): void => {\n  if (type.isUnionOrIntersection())\n    type.types.forEach((child) => iterate_optional_coalesce(meta, child));\n  else iterate_metadata_coalesce(meta, type);\n};\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_set =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    type = checker.getApparentType(type);\n\n    const name = TypeFactory.getFullName(checker)(type, type.getSymbol());\n    const generic = type.aliasSymbol\n      ? type.aliasTypeArguments\n      : checker.getTypeArguments(type as ts.TypeReference);\n    if (name.substring(0, 4) !== \"Set<\" || generic?.length !== 1) return false;\n\n    const key: ts.Type = generic[0]!;\n    ArrayUtil.set(\n      meta.sets,\n      explore_metadata(checker)(options)(collection)(errors)(key, {\n        ...explore,\n        escaped: false,\n        aliased: false,\n      }),\n      (elem) => elem.getName(),\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { MetadataHelper } from \"./MetadataHelper\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const iterate_metadata_template =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    const filter = (flag: ts.TypeFlags) => (type.getFlags() & flag) !== 0;\n    if (!filter(ts.TypeFlags.TemplateLiteral)) return false;\n\n    const template: ts.TemplateLiteralType = type as ts.TemplateLiteralType;\n    const row: Metadata[] = [];\n\n    template.texts.forEach((text, i) => {\n      // TEXT LITERAL TYPE\n      if (text !== \"\") row.push(MetadataHelper.literal_to_metadata(text));\n\n      // BINDED TEMPLATE TYPE\n      const binded: ts.Type | undefined = template.types[i];\n      if (binded)\n        row.push(\n          explore_metadata(checker)(options)(collection)(errors)(binded, {\n            ...explore,\n            escaped: false,\n            aliased: false,\n          }),\n        );\n    });\n    meta.templates.push(row);\n\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataTupleType } from \"../../../schemas/metadata/MetadataTupleType\";\n\nimport { Writable } from \"../../../typings/Writable\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_tuple =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.TupleType,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataTupleType => {\n    // CHECK EXISTENCE\n    const [tuple, newbie, closure] = collection.emplaceTuple(checker, type);\n    ArrayUtil.add(tuple.nullables, nullable);\n    if (newbie === false) return tuple;\n\n    // CONSTRUCT ELEMENT TYPES\n    const flagList: readonly ts.ElementFlags[] =\n      type.elementFlags ?? (type.target as ts.TupleType)?.elementFlags ?? [];\n    const elements: Metadata[] = checker\n      .getTypeArguments(type as ts.TypeReference)\n      .map((elem, i) => {\n        const child: Metadata = explore_metadata(checker)(options)(collection)(\n          errors,\n        )(elem, {\n          ...explore,\n          nested: tuple,\n          aliased: false,\n          escaped: false,\n        });\n\n        // CHECK OPTIONAL\n        const flag: ts.ElementFlags | undefined = flagList[i];\n        if (flag === ts.ElementFlags.Optional) Writable(child).optional = true;\n\n        // REST TYPE\n        if (flag !== ts.ElementFlags.Rest) return child;\n        const wrapper: Metadata = Metadata.initialize();\n        Writable(wrapper).rest = child;\n        return wrapper;\n      });\n    closure(elements);\n\n    return tuple;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataTuple } from \"../../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../../schemas/metadata/MetadataTupleType\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emplace_metadata_tuple } from \"./emplace_metadata_tuple\";\n\nexport const iterate_metadata_tuple =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.TupleType,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!checker.isTupleType(type)) return false;\n\n    const tupleType: MetadataTupleType = emplace_metadata_tuple(checker)(\n      options,\n    )(collection)(errors)(type, meta.nullable, explore);\n    ArrayUtil.add(\n      meta.tuples,\n      MetadataTuple.create({\n        type: tupleType,\n        tags: [],\n      }),\n      (elem) => elem.type.name === tupleType.name,\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const iterate_metadata_union =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    meta: Metadata,\n    type: ts.Type,\n    explore: MetadataFactory.IExplore,\n  ): boolean => {\n    if (!type.isUnion()) return false;\n    type.types.forEach((t) =>\n      iterate_metadata(checker)(options)(collection)(errors)(meta, t, {\n        ...explore,\n        aliased: false,\n      }),\n    );\n    return true;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { TypeFactory } from \"../../TypeFactory\";\nimport { iterate_metadata_alias } from \"./iterate_metadata_alias\";\nimport { iterate_metadata_array } from \"./iterate_metadata_array\";\nimport { iterate_metadata_atomic } from \"./iterate_metadata_atomic\";\nimport { iterate_metadata_coalesce } from \"./iterate_metadata_coalesce\";\nimport { iterate_metadata_constant } from \"./iterate_metadata_constant\";\nimport { iterate_metadata_escape } from \"./iterate_metadata_escape\";\nimport { iterate_metadata_intersection } from \"./iterate_metadata_intersection\";\nimport { iterate_metadata_map } from \"./iterate_metadata_map\";\nimport { iterate_metadata_native } from \"./iterate_metadata_native\";\nimport { iterate_metadata_object } from \"./iterate_metadata_object\";\nimport { iterate_metadata_set } from \"./iterate_metadata_set\";\nimport { iterate_metadata_template } from \"./iterate_metadata_template\";\nimport { iterate_metadata_tuple } from \"./iterate_metadata_tuple\";\nimport { iterate_metadata_union } from \"./iterate_metadata_union\";\n\nexport const iterate_metadata =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (meta: Metadata, type: ts.Type, explore: MetadataFactory.IExplore): void => {\n    if (type.isTypeParameter() === true) {\n      errors.push({\n        name: TypeFactory.getFullName(checker)(type),\n        explore: { ...explore },\n        messages: [\"non-specified generic argument found.\"],\n      });\n      return;\n    }\n    // CHECK SPECIAL CASES\n    else if (\n      (explore.aliased !== true &&\n        iterate_metadata_alias(checker)(options)(collection)(errors)(\n          meta,\n          type,\n          explore,\n        )) ||\n      iterate_metadata_intersection(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_union(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_escape(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      )\n    )\n      return;\n\n    // ITERATE CASES\n    iterate_metadata_coalesce(meta, type) ||\n      iterate_metadata_constant(checker)(options)(meta, type) ||\n      iterate_metadata_template(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_atomic(meta, type) ||\n      iterate_metadata_tuple(checker)(options)(collection)(errors)(\n        meta,\n        type as ts.TupleType,\n        explore,\n      ) ||\n      iterate_metadata_array(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_native(checker)(meta, type) ||\n      iterate_metadata_map(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_set(checker)(options)(collection)(errors)(\n        meta,\n        type,\n        explore,\n      ) ||\n      iterate_metadata_object(checker)(options)(collection)(errors)(meta, type);\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { emend_metadata_atomics } from \"./emend_metadata_atomics\";\nimport { iterate_metadata } from \"./iterate_metadata\";\n\nexport const explore_metadata =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (type: ts.Type | null, explore: MetadataFactory.IExplore): Metadata => {\n    // CONSTRUCT METADATA\n    const meta: Metadata = Metadata.initialize(explore.escaped);\n    if (type === null) return meta;\n\n    // ITERATE TYPESCRIPT TYPES\n    iterate_metadata(checker)(options)(collection)(errors)(meta, type, explore);\n    emend_metadata_atomics(meta);\n    if (meta.escaped) {\n      emend_metadata_atomics(meta.escaped.original);\n      emend_metadata_atomics(meta.escaped.returns);\n    }\n    return meta;\n  };\n","import ts from \"typescript\";\n\nimport { Metadata } from \"../../../schemas/metadata/Metadata\";\nimport { MetadataAlias } from \"../../../schemas/metadata/MetadataAlias\";\n\nimport { ArrayUtil } from \"../../../utils/ArrayUtil\";\n\nimport { MetadataCollection } from \"../../MetadataCollection\";\nimport { MetadataFactory } from \"../../MetadataFactory\";\nimport { explore_metadata } from \"./explore_metadata\";\n\nexport const emplace_metadata_alias =\n  (checker: ts.TypeChecker) =>\n  (options: MetadataFactory.IOptions) =>\n  (collection: MetadataCollection) =>\n  (errors: MetadataFactory.IError[]) =>\n  (\n    type: ts.Type,\n    nullable: boolean,\n    explore: MetadataFactory.IExplore,\n  ): MetadataAlias => {\n    // CHECK EXISTENCE\n    const [alias, newbie, closure] = collection.emplaceAlias(\n      checker,\n      type,\n      type.aliasSymbol!,\n    );\n    ArrayUtil.add(alias.nullables, nullable);\n    if (newbie === false) return alias;\n\n    // CONSTRUCT VALUE TYPE\n    const value: Metadata = explore_metadata(checker)(options)(collection)(\n      errors,\n    )(type, {\n      ...explore,\n      escaped: false,\n      aliased: true,\n    });\n    closure(value);\n    return alias;\n  };\n"]}