{"version":3,"sources":["../src/programmers/ValidateProgrammer.ts"],"names":["ts","ValidateProgrammer","write","project","modulo","equals","type","name","importer","FunctionImporter","getText","is","IsProgrammer","TypeFactory","getFullName","checker","validate","CheckerProgrammer","prefix","path","trace","numeric","OptionPredicator","options","atomist","explore","entry","input","expression","conditions","length","map","cond","factory","createLogicalOr","create_report_call","from","createTrue","createIdentifier","postfix","expected","set","s","reduce","a","b","createLogicalAnd","x","y","combiner","combine","joiner","success","addition","declare","createArrowFunction","undefined","IdentifierFactory","parameter","keyword","createTypeReferenceNode","createBlock","StatementFactory","constant","createAsExpression","createArrayLiteralExpression","createArrayTypeNode","createIfStatement","createStrictEquality","createFalse","createCallExpression","access","createParenthesizedExpression","createExpressionStatement","createStringLiteral","ExpressionFactory","number","createReturnStatement","create_output","tracable","configure","object","validate_object","logic","binaries","binary","combined","source","check_object","assert","positive","superfluous","value","createAdd","use","halt","expr","array","arrow","check_everything","failure","tuple","createObjectLiteralExpression","createShorthandPropertyAssignment","createPropertyAssignment","createConditionalExpression","exceptionable"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../factories/StatementFactory\";\nimport { TypeFactory } from \"../factories/TypeFactory\";\n\nimport { IProject } from \"../transformers/IProject\";\n\nimport { CheckerProgrammer } from \"./CheckerProgrammer\";\nimport { IsProgrammer } from \"./IsProgrammer\";\nimport { FunctionImporter } from \"./helpers/FunctionImporter\";\nimport { OptionPredicator } from \"./helpers/OptionPredicator\";\nimport { check_everything } from \"./internal/check_everything\";\nimport { check_object } from \"./internal/check_object\";\n\nexport namespace ValidateProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (type: ts.Type, name?: string) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n\n      const is = IsProgrammer.write(project)(modulo, true)(equals)(\n        type,\n        name ?? TypeFactory.getFullName(project.checker)(type),\n      );\n      const validate: ts.ArrowFunction = CheckerProgrammer.write(project)({\n        prefix: \"$v\",\n        path: true,\n        trace: true,\n        numeric: OptionPredicator.numeric(project.options),\n        equals,\n        atomist: (explore) => (entry) => (input) =>\n          [\n            ...(entry.expression ? [entry.expression] : []),\n            ...(entry.conditions.length === 0\n              ? []\n              : entry.conditions.length === 1\n                ? entry.conditions[0]!.map((cond) =>\n                    ts.factory.createLogicalOr(\n                      cond.expression,\n                      create_report_call(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        cond.expected,\n                        input,\n                      ),\n                    ),\n                  )\n                : [\n                    ts.factory.createLogicalOr(\n                      entry.conditions\n                        .map((set) =>\n                          set\n                            .map((s) => s.expression)\n                            .reduce((a, b) =>\n                              ts.factory.createLogicalAnd(a, b),\n                            ),\n                        )\n                        .reduce((a, b) => ts.factory.createLogicalOr(a, b)),\n                      create_report_call(\n                        explore.from === \"top\"\n                          ? ts.factory.createTrue()\n                          : ts.factory.createIdentifier(\"_exceptionable\"),\n                      )(\n                        ts.factory.createIdentifier(\n                          explore.postfix\n                            ? `_path + ${explore.postfix}`\n                            : \"_path\",\n                        ),\n                        entry.expected,\n                        input,\n                      ),\n                    ),\n                  ]),\n          ].reduce((x, y) => ts.factory.createLogicalAnd(x, y)),\n        combiner: combine(equals)(project)(importer),\n        joiner: joiner(equals)(project)(importer),\n        success: ts.factory.createTrue(),\n        addition: () => importer.declare(modulo),\n      })(importer)(type, name);\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [IdentifierFactory.parameter(\"input\", TypeFactory.keyword(\"any\"))],\n        ts.factory.createTypeReferenceNode(\n          `typia.IValidation<${\n            name ?? TypeFactory.getFullName(project.checker)(type)\n          }>`,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            StatementFactory.constant(\n              \"errors\",\n              ts.factory.createAsExpression(\n                ts.factory.createArrayLiteralExpression([]),\n                ts.factory.createArrayTypeNode(TypeFactory.keyword(\"any\")),\n              ),\n            ),\n            StatementFactory.constant(\"__is\", is),\n            ts.factory.createIfStatement(\n              ts.factory.createStrictEquality(\n                ts.factory.createFalse(),\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"__is\"),\n                  undefined,\n                  [ts.factory.createIdentifier(\"input\")],\n                ),\n              ),\n              ts.factory.createBlock([\n                StatementFactory.constant(\n                  \"$report\",\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(\n                      ts.factory.createParenthesizedExpression(\n                        ts.factory.createAsExpression(\n                          modulo,\n                          TypeFactory.keyword(\"any\"),\n                        ),\n                      ),\n                    )(\"report\"),\n                    [],\n                    [ts.factory.createIdentifier(\"errors\")],\n                  ),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(validate, undefined, [\n                    ts.factory.createIdentifier(\"input\"),\n                    ts.factory.createStringLiteral(\"$input\"),\n                    ts.factory.createTrue(),\n                  ]),\n                ),\n              ]),\n            ),\n            StatementFactory.constant(\n              \"success\",\n              ts.factory.createStrictEquality(\n                ExpressionFactory.number(0),\n                ts.factory.createIdentifier(\"errors.length\"),\n              ),\n            ),\n            ts.factory.createReturnStatement(\n              ts.factory.createAsExpression(\n                create_output(),\n                TypeFactory.keyword(\"any\"),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n}\n\nconst combine =\n  (equals: boolean) =>\n  (project: IProject) =>\n  (importer: FunctionImporter): CheckerProgrammer.IConfig.Combiner =>\n  (explore: CheckerProgrammer.IExplore) => {\n    if (explore.tracable === false)\n      return IsProgrammer.configure({\n        object: validate_object(equals)(project)(importer),\n        numeric: true,\n      })(project)(importer).combiner(explore);\n\n    const path: string = explore.postfix\n      ? `_path + ${explore.postfix}`\n      : \"_path\";\n    return (logic) => (input, binaries, expected) =>\n      logic === \"and\"\n        ? binaries\n            .map((binary) =>\n              binary.combined\n                ? binary.expression\n                : ts.factory.createLogicalOr(\n                    binary.expression,\n                    create_report_call(\n                      explore.source === \"top\"\n                        ? ts.factory.createTrue()\n                        : ts.factory.createIdentifier(\"_exceptionable\"),\n                    )(ts.factory.createIdentifier(path), expected, input),\n                  ),\n            )\n            .reduce(ts.factory.createLogicalAnd)\n        : ts.factory.createLogicalOr(\n            binaries\n              .map((binary) => binary.expression)\n              .reduce(ts.factory.createLogicalOr),\n            create_report_call(\n              explore.source === \"top\"\n                ? ts.factory.createTrue()\n                : ts.factory.createIdentifier(\"_exceptionable\"),\n            )(ts.factory.createIdentifier(path), expected, input),\n          );\n  };\n\nconst validate_object =\n  (equals: boolean) => (project: IProject) => (importer: FunctionImporter) =>\n    check_object({\n      equals,\n      undefined: true,\n      assert: false,\n      reduce: ts.factory.createLogicalAnd,\n      positive: ts.factory.createTrue(),\n      superfluous: (value) =>\n        create_report_call()(\n          ts.factory.createAdd(\n            ts.factory.createIdentifier(\"_path\"),\n            ts.factory.createCallExpression(importer.use(\"join\"), undefined, [\n              ts.factory.createIdentifier(\"key\"),\n            ]),\n          ),\n          \"undefined\",\n          value,\n        ),\n      halt: (expr) =>\n        ts.factory.createLogicalOr(\n          ts.factory.createStrictEquality(\n            ts.factory.createFalse(),\n            ts.factory.createIdentifier(\"_exceptionable\"),\n          ),\n          expr,\n        ),\n    })(project)(importer);\n\nconst joiner =\n  (equals: boolean) =>\n  (project: IProject) =>\n  (importer: FunctionImporter): CheckerProgrammer.IConfig.IJoiner => ({\n    object: validate_object(equals)(project)(importer),\n    array: (input, arrow) =>\n      check_everything(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(input)(\"map\"),\n          undefined,\n          [arrow],\n        ),\n      ),\n    failure: (value, expected, explore) =>\n      create_report_call(\n        explore?.from === \"top\"\n          ? ts.factory.createTrue()\n          : ts.factory.createIdentifier(\"_exceptionable\"),\n      )(\n        ts.factory.createIdentifier(\n          explore?.postfix ? `_path + ${explore.postfix}` : \"_path\",\n        ),\n        expected,\n        value,\n      ),\n    tuple: (binaries) =>\n      check_everything(ts.factory.createArrayLiteralExpression(binaries, true)),\n  });\n\nconst create_output = () =>\n  ts.factory.createObjectLiteralExpression(\n    [\n      ts.factory.createShorthandPropertyAssignment(\"success\"),\n      ts.factory.createShorthandPropertyAssignment(\"errors\"),\n      ts.factory.createPropertyAssignment(\n        \"data\",\n        ts.factory.createConditionalExpression(\n          ts.factory.createIdentifier(\"success\"),\n          undefined,\n          ts.factory.createIdentifier(\"input\"),\n          undefined,\n          ts.factory.createIdentifier(\"undefined\"),\n        ),\n      ),\n    ],\n    true,\n  );\n\nconst create_report_call =\n  (exceptionable?: ts.Expression) =>\n  (\n    path: ts.Expression,\n    expected: string,\n    value: ts.Expression,\n  ): ts.Expression =>\n    ts.factory.createCallExpression(\n      ts.factory.createIdentifier(\"$report\"),\n      undefined,\n      [\n        exceptionable ?? ts.factory.createIdentifier(\"_exceptionable\"),\n        ts.factory.createObjectLiteralExpression(\n          [\n            ts.factory.createPropertyAssignment(\"path\", path),\n            ts.factory.createPropertyAssignment(\n              \"expected\",\n              ts.factory.createStringLiteral(expected),\n            ),\n            ts.factory.createPropertyAssignment(\"value\", value),\n          ],\n          true,\n        ),\n      ],\n    );\n"]}