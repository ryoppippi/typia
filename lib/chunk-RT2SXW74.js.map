{"version":3,"sources":["../src/programmers/functional/FunctionalAssertParametersProgrammer.ts","../src/programmers/functional/FunctionalAssertFunctionProgrammer.ts","../src/programmers/functional/FunctionalAssertReturnProgrammer.ts"],"names":["ts","FunctionAssertReturnProgrammer","write","project","modulo","equals","expression","declaration","init","wrapper","FunctionalAssertFunctionProgrammer","errorFactoryWrapper","parameters","async","returns","statement","returnStatement","name","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","type","createBlock","variable","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","getText","createReturnStatement","AssertProgrammer","hookPath","replacer","createAwaitExpression","FunctionalAssertParametersProgrammer","argumentExpressions","createExpressionStatement","paramters","StringUtil","escapeDuplicate","createVariableStatement","createVariableDeclarationList","createVariableDeclaration","Guardian","createPropertyAccessExpression","createAsExpression","TypeFactory","keyword","NodeFlags","Const","props","IdentifierFactory","parameter","createObjectLiteralExpression","createSpreadAssignment","createPropertyAssignment","createConditionalExpression","createStringLiteral","i","getTypeFromTypeNode"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertFunctionProgrammer } from \"./FunctionalAssertFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalAssertParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = FunctionalAssertFunctionProgrammer.errorFactoryWrapper(\n        modulo,\n      )(declaration.parameters)(init);\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock(\n          [\n            wrapper.variable,\n            ...argumentExpressions(project)(modulo)(equals)(\n              declaration.parameters,\n              wrapper.name,\n            ).map(ts.factory.createExpressionStatement),\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                expression,\n                undefined,\n                declaration.parameters.map((p) =>\n                  ts.factory.createIdentifier(p.name.getText()),\n                ),\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const argumentExpressions =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      parameters: readonly ts.ParameterDeclaration[],\n      wrapper: string,\n    ): ts.CallExpression[] =>\n      parameters.map((p, i) =>\n        ts.factory.createCallExpression(\n          AssertProgrammer.write(project)(modulo)(equals)(\n            p.type\n              ? project.checker.getTypeFromTypeNode(p.type)\n              : project.checker.getTypeFromTypeNode(TypeFactory.keyword(\"any\")),\n            undefined,\n            FunctionalAssertFunctionProgrammer.hookPath({\n              wrapper,\n              replacer: `$input.parameters[${i}]`,\n            }),\n          ),\n          undefined,\n          [ts.factory.createIdentifier(p.name.getText())],\n        ),\n      );\n}\n","import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertParametersProgrammer } from \"./FunctionalAssertParametersProgrammer\";\nimport { FunctionAssertReturnProgrammer } from \"./FunctionalAssertReturnProgrammer\";\n\nexport namespace FunctionalAssertFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = errorFactoryWrapper(modulo)(declaration.parameters)(init);\n      const { async, returns } = FunctionAssertReturnProgrammer.returnStatement(\n        project,\n      )(modulo)(equals)(expression, declaration, wrapper.name);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock([\n          wrapper.variable,\n          ...FunctionalAssertParametersProgrammer.argumentExpressions(project)(\n            modulo,\n          )(equals)(declaration.parameters, wrapper.name).map(\n            ts.factory.createExpressionStatement,\n          ),\n          returns,\n        ]),\n      );\n    };\n\n  export const errorFactoryWrapper =\n    (modulo: ts.LeftHandSideExpression) =>\n    (paramters: readonly ts.ParameterDeclaration[]) =>\n    (\n      init: ts.Expression | undefined,\n    ): {\n      name: string;\n      variable: ts.VariableStatement;\n    } => {\n      const name: string = StringUtil.escapeDuplicate(\n        paramters.map((p) => p.name.getText()),\n      )(\"errorFactoryWrapper\");\n      const variable: ts.VariableStatement = ts.factory.createVariableStatement(\n        undefined,\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              name,\n              undefined,\n              AssertProgrammer.Guardian.type(),\n              init ??\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createAsExpression(\n                    modulo,\n                    TypeFactory.keyword(\"any\"),\n                  ),\n                  \"errorFactory\",\n                ),\n            ),\n          ],\n          ts.NodeFlags.Const,\n        ),\n      );\n      return { name, variable };\n    };\n\n  export const hookPath = (props: {\n    wrapper: string;\n    replacer: string;\n  }): ts.ArrowFunction =>\n    ts.factory.createArrowFunction(\n      undefined,\n      undefined,\n      [IdentifierFactory.parameter(\"p\")],\n      undefined,\n      undefined,\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(props.wrapper),\n        undefined,\n        [\n          ts.factory.createObjectLiteralExpression([\n            ts.factory.createSpreadAssignment(ts.factory.createIdentifier(\"p\")),\n            ts.factory.createPropertyAssignment(\n              \"path\",\n              ts.factory.createConditionalExpression(\n                ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(\"p\"),\n                  \"path\",\n                ),\n                undefined,\n                ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(\"p\"),\n                      \"path\",\n                    ),\n                    \"replace\",\n                  ),\n                  undefined,\n                  [\n                    ts.factory.createStringLiteral(\"$input\"),\n                    ts.factory.createStringLiteral(props.replacer),\n                  ],\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"undefined\"),\n              ),\n            ),\n          ]),\n        ],\n      ),\n    );\n}\n","import ts from \"typescript\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { AssertProgrammer } from \"../AssertProgrammer\";\nimport { FunctionalAssertFunctionProgrammer } from \"./FunctionalAssertFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionAssertReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      init?: ts.Expression,\n    ): ts.ArrowFunction => {\n      const wrapper = FunctionalAssertFunctionProgrammer.errorFactoryWrapper(\n        modulo,\n      )(declaration.parameters)(init);\n      const { async, returns: statement } = returnStatement(project)(modulo)(\n        equals,\n      )(expression, declaration, wrapper.name);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        declaration.type,\n        undefined,\n        ts.factory.createBlock([wrapper.variable, statement], true),\n      );\n    };\n\n  export const returnStatement =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n      wrapper: string,\n    ): {\n      async: boolean;\n      returns: ts.ReturnStatement;\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n      return {\n        async,\n        returns: ts.factory.createReturnStatement(\n          ts.factory.createCallExpression(\n            AssertProgrammer.write(project)(modulo)(equals)(\n              type,\n              undefined,\n              FunctionalAssertFunctionProgrammer.hookPath({\n                wrapper,\n                replacer: \"$input.return\",\n              }),\n            ),\n            undefined,\n            [async ? ts.factory.createAwaitExpression(caller) : caller],\n          ),\n        ),\n      };\n    };\n}\n"]}