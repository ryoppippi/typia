{"version":3,"sources":["../src/factories/MetadataTypeTagSchemaFactory.ts"],"names":["MetadataTypeTagSchemaFactory","object","report","obj","recursive","name","undefined","output","p","properties","key","getSoleLiteral","getName","iterate","value","parent","meta","any","atomics","length","arrays","natives","functional","size","nullable","isRequired","constants","values","tuples","tuple","type","isRest","elements","some","e","required","map","objects"],"mappings":";;;;;;UAGiBA,+BAAAA;gCACFC,SACX,CAACC,WACD,CAACC,QAAAA;AACC,QAAIA,IAAIC,WAAW;AACjBF,aAAO,GAAGC,IAAIE,IAAI,qBAAqB;AACvC,aAAOC;IACT;AACA,UAAMC,SAAc,CAAC;AACrB,eAAWC,KAAKL,IAAIM,YAAY;AAC9B,YAAMC,MAAqBF,EAAEE,IAAIC,eAAc;AAC/C,UAAID,QAAQ,MAAM;AAChBR,eAAO,GAAGC,IAAIE,IAAI,8BAA8BG,EAAEE,IAAIE,QAAO,CAAA,EAAI;AACjE;MACF;AACAL,aAAOG,GAAAA,IAAOG,QAAQX,MAAAA,EAAQ;QAAED,QAAQE;QAAKO;MAAI,CAAA,EAAGF,EAAEM,KAAK;IAC7D;AACA,WAAOP;EACT;AAEF,QAAMM,UACJ,wBAACX,WACD,CAACa,WACD,CAACC,SAAAA;AACC,QACEA,KAAKC,OACLD,KAAKE,QAAQC,UACbH,KAAKI,OAAOD,UACZH,KAAKK,QAAQF,UACbH,KAAKM,WAELpB,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,uBAAuB;aAC1DM,KAAKO,KAAI,IAAK,EACrBrB,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,iBAAiB;aACpDM,KAAKO,KAAI,MAAO,EACvB,KAAIP,KAAKQ,SAAU,QAAO;aACjBR,KAAKS,WAAU,MAAO,KAC7BvB,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,uBAAuB;QAC9D,QAAOJ;aACLU,KAAKU,UAAUP,OACtB,QAAOH,KAAKU,UAAU,CAAA,EAAIC,OAAO,CAAA,EAAIb;aAC9BE,KAAKY,OAAOT,QAAQ;AAC3B,YAAMU,QAAQb,KAAKY,OAAO,CAAA;AAC1B,UAAIC,MAAMC,KAAKC,OAAM,EACnB7B,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,sBAAsB;eACzDmB,MAAMC,KAAK1B,UAClBF,QACE,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,2BAA2B;eAEzDmB,MAAMC,KAAKE,SAASC,KAAK,CAACC,MAAMA,EAAEC,aAAa,KAAA,EACtDjC,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,0BAA0B;AACtE,aAAOmB,MAAMC,KAAKE,SAASI,IAAIvB,QAAQX,MAAAA,EAAQa,MAAAA,CAAAA;IACjD,WAAWC,KAAKqB,QAAQlB,OAAQ,QAAOlB,8BAAAA,OAAOC,MAAAA,EAAQc,KAAKqB,QAAQ,CAAA,CAAE;QAChEnC,QAAO,GAAGa,OAAOd,OAAOI,IAAI,IAAIU,OAAOL,GAAG,uBAAuB;EACxE,GAjCA;AAkCJ,GAvDiBV,iCAAAA,+BAAAA,CAAAA,EAAAA","sourcesContent":["import { Metadata } from \"../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../schemas/metadata/MetadataObject\";\n\nexport namespace MetadataTypeTagSchemaFactory {\n  export const object =\n    (report: (msg: string) => false) =>\n    (obj: MetadataObject): object | undefined => {\n      if (obj.recursive) {\n        report(`${obj.name} has recursive type`);\n        return undefined;\n      }\n      const output: any = {};\n      for (const p of obj.properties) {\n        const key: string | null = p.key.getSoleLiteral()!;\n        if (key === null) {\n          report(`${obj.name} has non-literal key type: ${p.key.getName()}`);\n          continue;\n        }\n        output[key] = iterate(report)({ object: obj, key })(p.value);\n      }\n      return output;\n    };\n\n  const iterate =\n    (report: (msg: string) => false) =>\n    (parent: { object: MetadataObject; key: string }) =>\n    (meta: Metadata): any => {\n      if (\n        meta.any ||\n        meta.atomics.length ||\n        meta.arrays.length ||\n        meta.natives.length ||\n        meta.functional\n      )\n        report(`${parent.object.name}.${parent.key} has non-literal type`);\n      else if (meta.size() > 1)\n        report(`${parent.object.name}.${parent.key} has union type`);\n      else if (meta.size() === 0)\n        if (meta.nullable) return null;\n        else if (meta.isRequired() === true)\n          report(`${parent.object.name}.${parent.key} has non-literal type`);\n        else return undefined;\n      else if (meta.constants.length)\n        return meta.constants[0]!.values[0]!.value;\n      else if (meta.tuples.length) {\n        const tuple = meta.tuples[0]!;\n        if (tuple.type.isRest())\n          report(`${parent.object.name}.${parent.key} has rest tuple type`);\n        else if (tuple.type.recursive)\n          report(\n            `${parent.object.name}.${parent.key} has recursive tuple type`,\n          );\n        else if (tuple.type.elements.some((e) => e.required === false))\n          report(`${parent.object.name}.${parent.key} has optional tuple type`);\n        return tuple.type.elements.map(iterate(report)(parent));\n      } else if (meta.objects.length) return object(report)(meta.objects[0]!);\n      else report(`${parent.object.name}.${parent.key} has non-literal type`);\n    };\n}\n"]}