{"version":3,"sources":["../src/programmers/protobuf/ProtobufMessageProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { ProtobufFactory } from \"../../factories/ProtobufFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { MapUtil } from \"../../utils/MapUtil\";\nimport { NameEncoder } from \"../../utils/NameEncoder\";\n\nimport { ProtobufUtil } from \"../helpers/ProtobufUtil\";\n\nexport namespace ProtobufMessageProgrammer {\n  export const write = (project: IProject) => (type: ts.Type) => {\n    // PARSE TARGET TYPE\n    const collection: MetadataCollection = new MetadataCollection();\n    ProtobufFactory.metadata(\"message\")(project.checker, project.context)(\n      collection,\n    )(type);\n\n    // STRINGIFY\n    const hierarchies: Map<string, Hierarchy> = new Map();\n    for (const obj of collection.objects())\n      if (is_dynamic_object(obj) === false) emplace(hierarchies)(obj);\n\n    const content: string =\n      `syntax = \"proto3\";\\n\\n` +\n      [...hierarchies.values()]\n        .map((hier) => write_hierarchy(hier))\n        .join(\"\\n\\n\");\n\n    // RETURNS\n    return ts.factory.createStringLiteral(content);\n  };\n\n  const emplace = (dict: Map<string, Hierarchy>) => (obj: MetadataObject) => {\n    const accessors: string[] = obj.name.split(\".\");\n    accessors.forEach((access, i) => {\n      const hierarchy: Hierarchy = MapUtil.take(dict)(access, () => ({\n        key: access,\n        object: null!,\n        children: new Map(),\n      }));\n      dict = hierarchy.children;\n      if (i === accessors.length - 1) hierarchy.object = obj;\n    });\n  };\n\n  const is_dynamic_object = (obj: MetadataObject): boolean =>\n    obj.properties.length === 1 &&\n    obj.properties[0]!.key.isSoleLiteral() === false;\n\n  const write_hierarchy = (hierarchy: Hierarchy): string => {\n    const elements: string[] = [\n      `message ${NameEncoder.encode(hierarchy.key)} {`,\n    ];\n    if (hierarchy.object !== null) {\n      const text: string = write_object(hierarchy.object);\n      elements.push(...text.split(\"\\n\").map((str) => `${TAB}${str}`));\n    }\n    if (hierarchy.children.size)\n      elements.push(\n        [...hierarchy.children.values()]\n          .map((child) => write_hierarchy(child))\n          .map((body) =>\n            body\n              .split(\"\\n\")\n              .map((line) => `${TAB}${line}`)\n              .join(\"\\n\"),\n          )\n          .join(\"\\n\\n\"),\n      );\n    elements.push(\"}\");\n    return elements.join(\"\\n\");\n  };\n\n  const write_object = (obj: MetadataObject): string => {\n    const ptr: IPointer<number> = { value: 0 };\n    return obj.properties\n      .map((prop) => {\n        const key: string = prop.key.getSoleLiteral()!;\n        const type: string = decode(ptr)(prop.value);\n        return type.indexOf(\"${name}\") !== -1\n          ? type.replace(\"${name}\", key)\n          : `${\n              prop.value.arrays.length || type.startsWith(\"map<\")\n                ? \"\"\n                : !prop.value.isRequired() || prop.value.nullable\n                  ? \"optional \"\n                  : \"required \"\n            }${type} ${key} = ${++ptr.value};`;\n      })\n      .join(\"\\n\");\n  };\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (ptr: IPointer<number>) =>\n    (meta: Metadata): string => {\n      const elements: Set<string> = new Set();\n      if (meta.natives.length) elements.add(\"bytes\");\n      for (const atomic of ProtobufUtil.getAtomics(meta)) elements.add(atomic);\n      for (const array of meta.arrays)\n        elements.add(`repeated ${decode(ptr)(array.type.value)}`);\n      for (const obj of meta.objects)\n        elements.add(\n          is_dynamic_object(obj)\n            ? decode_map(ptr)(\n                MetadataProperty.create({\n                  ...obj.properties[0]!,\n                  key: (() => {\n                    const key: Metadata = Metadata.initialize();\n                    key.atomics.push(\n                      MetadataAtomic.create({\n                        type: \"string\",\n                        tags: [],\n                      }),\n                    );\n                    return key;\n                  })(),\n                }),\n              )\n            : NameEncoder.encode(obj.name),\n        );\n      for (const map of meta.maps) elements.add(decode_map(ptr)(map));\n      return elements.size === 1\n        ? [...elements][0]!\n        : [\n            \"oneof ${name} {\",\n            ...[...elements].map(\n              (str) => `${TAB}${str} v${ptr.value + 1} = ${++ptr.value};`,\n            ),\n            \"}\",\n          ].join(\"\\n\");\n    };\n\n  const decode_map =\n    (ptr: IPointer<number>) =>\n    (prop: Metadata.Entry): string =>\n      `map<${decode(ptr)(prop.key)}, ${decode(ptr)(prop.value)}>`;\n}\n\ninterface Hierarchy {\n  key: string;\n  object: MetadataObject | null;\n  children: Map<string, Hierarchy>;\n}\n\ninterface IPointer<T> {\n  value: T;\n}\n\nconst TAB = \" \".repeat(2);\n"],"mappings":"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","names":["ts","ProtobufMessageProgrammer","write","project","type","collection","MetadataCollection","ProtobufFactory","metadata","checker","context","hierarchies","Map","obj","objects","is_dynamic_object","emplace","content","values","map","hier","write_hierarchy","join","ts","factory","createStringLiteral","dict","accessors","name","split","forEach","access","i","hierarchy","MapUtil","take","key","object","children","length","properties","isSoleLiteral","elements","NameEncoder","encode","text","write_object","push","str","TAB","size","child","body","line","ptr","value","prop","getSoleLiteral","decode","indexOf","replace","arrays","startsWith","isRequired","nullable","meta","Set","natives","add","atomic","ProtobufUtil","getAtomics","array","decode_map","MetadataProperty","create","Metadata","initialize","atomics","MetadataAtomic","tags","maps","repeat"]}