{"version":3,"sources":["../src/programmers/helpers/UnionExplorer.ts"],"names":["ts","UnionExplorer","object","config","level","input","targets","explore","length","objector","decoder","expected","map","t","name","join","specList","UnionPredicator","condition","unionizer","tracable","full","remained","filter","find","s","undefined","spec","property","key","getSoleLiteral","i","array","accessor","IdentifierFactory","access","pred","neighbour","checker","value","postfix","required","exp","ExpressionFactory","isRequired","factory","createIfStatement","is","createReturnStatement","failure","reverse","reduce","a","b","expression","thenStatement","createCallExpression","createArrowFunction","createBlock","tuple","props","check_union_array_like","transform","x","element","size","front","type","createElementAccessExpression","array_or_tuple","MetadataArray","m","set","create","tags","MetadataArrayType","getName","index","recursive","nullables","createArrayLiteralExpression","createSpreadElement","_m","e","tuples","elements","k","v","Metadata","initialize","MetadataTuple","MetadataTupleType","of_map"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { check_union_array_like } from \"../internal/check_union_array_like\";\nimport { UnionPredicator } from \"./UnionPredicator\";\n\nexport namespace UnionExplorer {\n  export interface Decoder<T> {\n    (\n      input: ts.Expression,\n      target: T,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression;\n  }\n  export type ObjectCombiner = Decoder<MetadataObject[]>;\n\n  /* -----------------------------------------------------------\n        OBJECT\n    ----------------------------------------------------------- */\n  export const object =\n    (config: FeatureProgrammer.IConfig, level: number = 0) =>\n    (\n      input: ts.Expression,\n      targets: MetadataObject[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      // BREAKER\n      if (targets.length === 1)\n        return config.objector.decoder()(input, targets[0]!, explore);\n\n      const expected: string = `(${targets.map((t) => t.name).join(\" | \")})`;\n\n      // POSSIBLE TO SPECIALIZE?\n      const specList = UnionPredicator.object(targets);\n      if (specList.length === 0) {\n        const condition: ts.Expression = config.objector.unionizer(\n          input,\n          targets,\n          {\n            ...explore,\n            tracable: false,\n          },\n        );\n        return config.objector.full\n          ? config.objector.full(condition)(input, expected, explore)\n          : condition;\n      }\n      const remained: MetadataObject[] = targets.filter(\n        (t) => specList.find((s) => s.object === t) === undefined,\n      );\n\n      // DO SPECIALIZE\n      const condition: ts.IfStatement = specList\n        .filter((spec) => spec.property.key.getSoleLiteral() !== null)\n        .map((spec, i, array) => {\n          const key: string = spec.property.key.getSoleLiteral()!;\n          const accessor: ts.Expression = IdentifierFactory.access(input)(key);\n          const pred: ts.Expression = spec.neighbour\n            ? config.objector.checker()(accessor, spec.property.value, {\n                ...explore,\n                tracable: false,\n                postfix: IdentifierFactory.postfix(key),\n              })\n            : (config.objector.required || ((exp) => exp))(\n                ExpressionFactory.isRequired(accessor),\n              );\n          return ts.factory.createIfStatement(\n            (config.objector.is || ((exp) => exp))(pred),\n            ts.factory.createReturnStatement(\n              config.objector.decoder()(input, spec.object, explore),\n            ),\n            i === array.length - 1\n              ? remained.length\n                ? ts.factory.createReturnStatement(\n                    object(config, level + 1)(input, remained, explore),\n                  )\n                : config.objector.failure(input, expected, explore)\n              : undefined,\n          );\n        })\n        .reverse()\n        .reduce((a, b) =>\n          ts.factory.createIfStatement(b.expression, b.thenStatement, a),\n        );\n\n      // RETURNS WITH CONDITIONS\n      return ts.factory.createCallExpression(\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          undefined,\n          ts.factory.createBlock([condition], true),\n        ),\n        undefined,\n        undefined,\n      );\n    };\n\n  /* -----------------------------------------------------------\n        ARRAY LIKE\n    ----------------------------------------------------------- */\n  export const tuple = (\n    props: check_union_array_like.IProps<MetadataTuple, MetadataTuple>,\n  ) =>\n    check_union_array_like<MetadataTuple, MetadataTuple, MetadataTuple>({\n      transform: (x) => x,\n      element: (x) => x,\n      size: null!,\n      front: (input) => input,\n      array: (input) => input,\n      name: (t) => t.type.name,\n    })(props);\n  export namespace tuple {\n    export type IProps = check_union_array_like.IProps<\n      MetadataTuple,\n      MetadataTuple\n    >;\n  }\n\n  export const array = (props: array.IProps) =>\n    check_union_array_like<MetadataArray, MetadataArray, Metadata>({\n      transform: (x) => x,\n      element: (x) => x.type.value,\n      size: (input) => IdentifierFactory.access(input)(\"length\"),\n      front: (input) => ts.factory.createElementAccessExpression(input, 0),\n      array: (input) => input,\n      name: (t) => t.type.name,\n    })(props);\n  export namespace array {\n    export type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n  }\n\n  export const array_or_tuple = (props: array_or_tuple.IProps) =>\n    check_union_array_like<\n      MetadataArray | MetadataTuple,\n      MetadataArray | MetadataTuple,\n      Metadata | MetadataTuple\n    >({\n      transform: (x) => x,\n      element: (x) => (x instanceof MetadataArray ? x.type.value : x),\n      size: (input) => IdentifierFactory.access(input)(\"length\"),\n      front: (input) => ts.factory.createElementAccessExpression(input, 0),\n      array: (input) => input,\n      name: (m) => m.type.name,\n    })(props);\n  export namespace array_or_tuple {\n    export type IProps = check_union_array_like.IProps<\n      MetadataArray | MetadataTuple,\n      Metadata\n    >;\n  }\n\n  export const set = (props: set.IProps) =>\n    check_union_array_like<Metadata, MetadataArray, Metadata>({\n      transform: (value: Metadata) =>\n        MetadataArray.create({\n          tags: [],\n          type: MetadataArrayType.create({\n            name: `Set<${value.getName()}>`,\n            index: null,\n            recursive: false,\n            nullables: [],\n            value,\n          }),\n        }),\n      element: (array) => array.type.value,\n      size: (input) => IdentifierFactory.access(input)(\"size\"),\n      front: (input) =>\n        IdentifierFactory.access(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(input)(\"values\"),\n                undefined,\n                undefined,\n              ),\n            )(\"next\"),\n            undefined,\n            undefined,\n          ),\n        )(\"value\"),\n      array: (input) =>\n        ts.factory.createArrayLiteralExpression(\n          [ts.factory.createSpreadElement(input)],\n          false,\n        ),\n      name: (_m, e) => `Set<${e.getName()}>`,\n    })(props);\n  export namespace set {\n    export type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n  }\n\n  export const map = (props: map.IProps) =>\n    check_union_array_like<Metadata.Entry, MetadataArray, [Metadata, Metadata]>(\n      {\n        element: (array) =>\n          array.type.value.tuples[0]!.type.elements as [Metadata, Metadata],\n        size: (input) => IdentifierFactory.access(input)(\"size\"),\n        front: (input) =>\n          IdentifierFactory.access(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(input)(\"entries\"),\n                  undefined,\n                  undefined,\n                ),\n              )(\"next\"),\n              undefined,\n              undefined,\n            ),\n          )(\"value\"),\n        array: (input) =>\n          ts.factory.createArrayLiteralExpression(\n            [ts.factory.createSpreadElement(input)],\n            false,\n          ),\n        name: (_m, [k, v]) => `Map<${k.getName()}, ${v.getName()}>`,\n        transform: (m: Metadata.Entry) =>\n          MetadataArray.create({\n            tags: [],\n            type: MetadataArrayType.create({\n              name: `Map<${m.key.getName()}, ${m.value.getName()}>`,\n              index: null,\n              recursive: false,\n              nullables: [],\n              value: Metadata.create({\n                ...Metadata.initialize(),\n                tuples: [\n                  (() => {\n                    const tuple = MetadataTuple.create({\n                      tags: [],\n                      type: MetadataTupleType.create({\n                        name: `[${m.key.getName()}, ${m.value.getName()}]`,\n                        index: null,\n                        recursive: false,\n                        nullables: [],\n                        elements: [m.key, m.value],\n                      }),\n                    });\n                    tuple.type.of_map = true;\n                    return tuple;\n                  })(),\n                ],\n              }),\n            }),\n          }),\n      },\n    )(props);\n\n  export namespace map {\n    export type IProps = check_union_array_like.IProps<\n      MetadataArray,\n      [Metadata, Metadata]\n    >;\n  }\n}\n"]}