{"version":3,"sources":["../src/notations.ts"],"names":["notations_exports","camel","halt","camelPure","Object","assign","Namespace","notations","assertCamel","assertCamelPure","assert","isCamel","isCamelPure","is","validateCamel","validateCamelPure","validate","pascal","pascalPure","assertPascal","assertPascalPure","isPascal","isPascalPure","validatePascal","validatePascalPure","snake","snakePure","assertSnake","assertSnakePure","isSnake","isSnakePure","validateSnake","validateSnakePure","createCamel","createCamelPure","createAssertCamel","createAssertCamelPure","createIsCamel","createIsCamelPure","createValidateCamel","createValidateCamelPure","createPascal","createPascalPure","createAssertPascal","createAssertPascalPure","createIsPascal","createIsPascalPure","createValidatePascal","createValidatePascalPure","createSnake","createSnakePure","createAssertSnake","createAssertSnakePure","createIsSnake","createIsSnakePure","createValidateSnake","createValidateSnakePure","name","Error"],"mappings":"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","sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { CamelCase } from \"./CamelCase\";\nimport { IValidation } from \"./IValidation\";\nimport { PascalCase } from \"./PascalCase\";\nimport { SnakeCase } from \"./SnakeCase\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    NOTATIONS (NAMING CONVENTIONS)\n      - CAMEL CASE\n      - PASCAL CASE\n      - SNAKE CASE\n      - FACTORY FUNCTIONS\n==============================================================\n    CAMEL CASE\n----------------------------------------------------------- */\n/**\n * Convert to camel case.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n *\n * For reference, this `typia.notations.camel()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertCamel}\n * - {@link isCamel}\n * - {@link validateCamel}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction camel<T>(input: T): CamelCase<T>;\n\n/**\n * @internal\n */\nfunction camel(): never {\n  return halt(\"camel\");\n}\nconst camelPure = /** @__PURE__ */ Object.assign<typeof camel, {}>(\n  camel,\n  /** @__PURE__ */ Namespace.notations.camel(\"camel\"),\n);\nexport { camelPure as camel };\n\n/**\n * Converts to camel case with type assertion.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertCamel<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): CamelCase<T>;\n\n/**\n * Converts to camel case with type assertion.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertCamel<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): CamelCase<T>;\n\n/**\n * @internal\n */\nfunction assertCamel(): never {\n  return halt(\"assertCamel\");\n}\nconst assertCamelPure = /** @__PURE__ */ Object.assign<\n  typeof assertCamel,\n  {},\n  {}\n>(\n  assertCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"assertCamel\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertCamel\"),\n);\nexport { assertCamelPure as assertCamel };\n\n/**\n * Converts to camel case with type checking.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isCamel<T>(input: T): CamelCase<T> | null;\n\n/**\n * Converts to camel case with type checking.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Camel case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isCamel<T>(input: unknown): CamelCase<T> | null;\n\n/**\n * @internal\n */\nfunction isCamel(): never {\n  return halt(\"isCamel\");\n}\nconst isCamelPure = /** @__PURE__ */ Object.assign<typeof isCamel, {}, {}>(\n  isCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"isCamel\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isCamelPure as isCamel };\n\n/**\n * Converts to camel case with type validation.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, camel cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateCamel<T>(input: T): IValidation<CamelCase<T>>;\n\n/**\n * Converts to camel case with type validation.\n *\n * Convert every property names of nested objects to follow the camel case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, camel cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with camel case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateCamel<T>(input: unknown): IValidation<CamelCase<T>>;\n\n/**\n * @internal\n */\nfunction validateCamel(): never {\n  return halt(\"validateCamel\");\n}\nconst validateCamelPure = /** @__PURE__ */ Object.assign<\n  typeof validateCamel,\n  {},\n  {}\n>(\n  validateCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"validateCamel\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateCamelPure as validateCamel };\n\n/* -----------------------------------------------------------\n    PASCAL CASE\n----------------------------------------------------------- */\n/**\n * Convert to pascal case.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n *\n * For reference, this `typia.notations.pascal()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertPascal}\n * - {@link isPascal}\n * - {@link validatePascal}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction pascal<T>(input: T): PascalCase<T>;\n\n/**\n * @internal\n */\nfunction pascal(): never {\n  return halt(\"pascal\");\n}\nconst pascalPure = /** @__PURE__ */ Object.assign<typeof pascal, {}>(\n  pascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"pascal\"),\n);\nexport { pascalPure as pascal };\n\n/**\n * Converts to pascal case with type assertion.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPascal<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): PascalCase<T>;\n\n/**\n * Converts to pascal case with type assertion.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertPascal<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): PascalCase<T>;\n\n/**\n * @internal\n */\nfunction assertPascal(): never {\n  return halt(\"assertPascal\");\n}\nconst assertPascalPure = /** @__PURE__ */ Object.assign<\n  typeof assertPascal,\n  {},\n  {}\n>(\n  assertPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"assertPascal\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertPascal\"),\n);\nexport { assertPascalPure as assertPascal };\n\n/**\n * Converts to pascal case with type checking.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPascal<T>(input: T): PascalCase<T> | null;\n\n/**\n * Converts to pascal case with type checking.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Pascal case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isPascal<T>(input: unknown): PascalCase<T> | null;\n\n/**\n * @internal\n */\nfunction isPascal(): never {\n  return halt(\"isPascal\");\n}\nconst isPascalPure = /** @__PURE__ */ Object.assign<typeof isPascal, {}, {}>(\n  isPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"isPascal\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isPascalPure as isPascal };\n\n/**\n * Converts to pascal case with type validation.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, pascal cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePascal<T>(input: T): IValidation<PascalCase<T>>;\n\n/**\n * Converts to pascal case with type validation.\n *\n * Convert every property names of nested objects to follow the pascal case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, pascal cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with pascal case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validatePascal<T>(input: unknown): IValidation<PascalCase<T>>;\n\n/**\n * @internal\n */\nfunction validatePascal(): never {\n  return halt(\"validatePascal\");\n}\nconst validatePascalPure = /** @__PURE__ */ Object.assign<\n  typeof validatePascal,\n  {},\n  {}\n>(\n  validatePascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"validatePascal\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validatePascalPure as validatePascal };\n\n/* -----------------------------------------------------------\n    SNAKE CASE\n----------------------------------------------------------- */\n/**\n * Convert to snake case.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n *\n * For reference, this `typia.notations.snake()` function does not validate the input value\n * type. It just believes that the input value is following the type `T`. Therefore,\n * if you can't ensure the input value type, it would be better to call one of them below:\n *\n * - {@link assertSnake}\n * - {@link isSnake}\n * - {@link validateSnake}\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction snake<T>(input: T): SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction snake(): never {\n  return halt(\"snake\");\n}\nconst snakePure = /** @__PURE__ */ Object.assign<typeof snake, {}>(\n  snake,\n  /** @__PURE__ */ Namespace.notations.snake(\"snake\"),\n);\nexport { snakePure as snake };\n\n/**\n * Converts to snake case with type assertion.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertSnake<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): SnakeCase<T>;\n\n/**\n * Converts to snake case with type assertion.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it throws {@link TypeGuardError}.\n *\n * @template T Type of the input value\n * @param input Target object\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertSnake<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction assertSnake(): never {\n  return halt(\"assertSnake\");\n}\nconst assertSnakePure = /** @__PURE__ */ Object.assign<\n  typeof assertSnake,\n  {},\n  {}\n>(\n  assertSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"assertSnake\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.assertSnake\"),\n);\nexport { assertSnakePure as assertSnake };\n\n/**\n * Converts to snake case with type checking.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isSnake<T>(input: T): SnakeCase<T> | null;\n\n/**\n * Converts to snake case with type checking.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns `null` value instead.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Snake case object when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isSnake<T>(input: unknown): SnakeCase<T> | null;\n\n/**\n * @internal\n */\nfunction isSnake(): never {\n  return halt(\"isSnake\");\n}\nconst isSnakePure = /** @__PURE__ */ Object.assign<typeof isSnake, {}, {}>(\n  isSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"isSnake\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { isSnakePure as isSnake };\n\n/**\n * Converts to snake case with type validation.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, snake cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateSnake<T>(input: T): IValidation<SnakeCase<T>>;\n\n/**\n * Converts to snake case with type validation.\n *\n * Convert every property names of nested objects to follow the snake case convention.\n * If the input value does not follow the type `T`, it returns {@link IValidation.Failure}\n * object. Otherwise, there's no problem on the input value, snake cased converted data\n * would be stored in the `data` property of the output {@link IValidation.Success} object.\n *\n * @template T Type of the input value\n * @param input Target object\n * @returns Validation result with snake case object\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateSnake<T>(input: unknown): IValidation<SnakeCase<T>>;\n\n/**\n * @internal\n */\nfunction validateSnake(): never {\n  return halt(\"validateSnake\");\n}\nconst validateSnakePure = /** @__PURE__ */ Object.assign<\n  typeof validateSnake,\n  {},\n  {}\n>(\n  validateSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"validateSnake\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { validateSnakePure as validateSnake };\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link camel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createCamel(): never;\n\n/**\n * Creates a reusable {@link camel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `camel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createCamel<T>(): (input: T) => CamelCase<T>;\n\n/**\n * @internal\n */\nfunction createCamel(): never {\n  halt(\"createCamel\");\n}\nconst createCamelPure = /** @__PURE__ */ Object.assign<typeof createCamel, {}>(\n  createCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createCamel\"),\n);\nexport { createCamelPure as createCamel };\n\n/**\n * Creates a reusable {@link assertCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertCamel(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertCamel} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertCamel<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => CamelCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertCamel(): never {\n  halt(\"createAssertCamel\");\n}\nconst createAssertCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertCamel,\n  {},\n  {}\n>(\n  createAssertCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createAssertCamel\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertCamel\"),\n);\nexport { createAssertCamelPure as createAssertCamel };\n\n/**\n * Creates a reusable {@link isCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsCamel(): never;\n\n/**\n * Creates a reusable {@link isCamel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsCamel<T>(): (input: T) => CamelCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsCamel(): never {\n  halt(\"createIsCamel\");\n}\nconst createIsCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createIsCamel,\n  {},\n  {}\n>(\n  createIsCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createIsCamel\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsCamelPure as createIsCamel };\n\n/**\n * Creates a reusable {@link validateCamel} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateCamel(): never;\n\n/**\n * Creates a reusable {@link validateCamel} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateCamel` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateCamel<T>(): (input: T) => IValidation<CamelCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidateCamel(): never {\n  halt(\"createValidateCamel\");\n}\nconst createValidateCamelPure = /** @__PURE__ */ Object.assign<\n  typeof createValidateCamel,\n  {},\n  {}\n>(\n  createValidateCamel,\n  /** @__PURE__ */ Namespace.notations.camel(\"createValidateCamel\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateCamelPure as createValidateCamel };\n\n/**\n * Creates a reusable {@link pascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPascal(): never;\n\n/**\n * Creates a reusable {@link pascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `pascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createPascal<T>(): (input: T) => PascalCase<T>;\n\n/**\n * @internal\n */\nfunction createPascal(): never {\n  halt(\"createPascal\");\n}\nconst createPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createPascal,\n  {}\n>(createPascal, /** @__PURE__ */ Namespace.notations.pascal(\"createPascal\"));\nexport { createPascalPure as createPascal };\n\n/**\n * Creates a reusable {@link assertPascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPascal(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertPascal} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertPascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertPascal<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => PascalCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertPascal(): never {\n  halt(\"createAssertPascal\");\n}\nconst createAssertPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createAssertPascal,\n  {},\n  {}\n>(\n  createAssertPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createAssertPascal\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertPascal\"),\n);\nexport { createAssertPascalPure as createAssertPascal };\n\n/**\n * Creates a reusable {@link isPascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPascal(): never;\n\n/**\n * Creates a reusable {@link isPascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsPascal<T>(): (input: T) => PascalCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsPascal(): never {\n  halt(\"createIsPascal\");\n}\nconst createIsPascalPure = /** @__PURE__ */ Object.assign<\n  typeof createIsPascal,\n  {},\n  {}\n>(\n  createIsPascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createIsPascal\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsPascalPure as createIsPascal };\n\n/**\n * Creates a reusable {@link validatePascal} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePascal(): never;\n\n/**\n * Creates a reusable {@link validatePascal} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePascal` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidatePascal<T>(): (input: T) => IValidation<PascalCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidatePascal(): never {\n  halt(\"createValidatePascal\");\n}\nconst createValidatePascalPure = /** @__PURE__ */ Object.assign<\n  typeof createValidatePascal,\n  {},\n  {}\n>(\n  createValidatePascal,\n  /** @__PURE__ */ Namespace.notations.pascal(\"createValidatePascal\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidatePascalPure as createValidatePascal };\n\n/**\n * Creates a reusable {@link snake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createSnake(): never;\n\n/**\n * Creates a reusable {@link snake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `snake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createSnake<T>(): (input: T) => SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction createSnake(): never {\n  halt(\"createSnake\");\n}\nconst createSnakePure = /** @__PURE__ */ Object.assign<typeof createSnake, {}>(\n  createSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createSnake\"),\n);\nexport { createSnakePure as createSnake };\n\n/**\n * Creates a reusable {@link assertSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertSnake(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertSnake} function.\n *\n * @template T Type of the input value\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertSnake<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => SnakeCase<T>;\n\n/**\n * @internal\n */\nfunction createAssertSnake(): never {\n  halt(\"createAssertSnake\");\n}\nconst createAssertSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertSnake,\n  {},\n  {}\n>(\n  createAssertSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createAssertSnake\"),\n  /** @__PURE__ */ Namespace.assert(\"notations.createAssertSnake\"),\n);\nexport { createAssertSnakePure as createAssertSnake };\n\n/**\n * Creates a reusable {@link isSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsSnake(): never;\n\n/**\n * Creates a reusable {@link isSnake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsSnake<T>(): (input: T) => SnakeCase<T> | null;\n\n/**\n * @internal\n */\nfunction createIsSnake(): never {\n  halt(\"createIsSnake\");\n}\nconst createIsSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createIsSnake,\n  {},\n  {}\n>(\n  createIsSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createIsSnake\"),\n  /** @__PURE__ */ Namespace.is(),\n);\nexport { createIsSnakePure as createIsSnake };\n\n/**\n * Creates a reusable {@link validateSnake} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until be configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateSnake(): never;\n\n/**\n * Creates a reusable {@link validateSnake} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateSnake` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateSnake<T>(): (input: T) => IValidation<SnakeCase<T>>;\n\n/**\n * @internal\n */\nfunction createValidateSnake(): never {\n  halt(\"createValidateSnake\");\n}\nconst createValidateSnakePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateSnake,\n  {},\n  {}\n>(\n  createValidateSnake,\n  /** @__PURE__ */ Namespace.notations.snake(\"createValidateSnake\"),\n  /** @__PURE__ */ Namespace.validate(),\n);\nexport { createValidateSnakePure as createValidateSnake };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.notations.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}