{"version":3,"sources":["../src/programmers/internal/stringify_regular_properties.ts"],"names":["ts","stringify_regular_properties","regular","dynamic","output","sort","x","y","sequence","meta","forEach","entry","index","key","getSoleLiteral","base","factory","createStringLiteral","JSON","stringify","expression","length","push","empty","isRequired","nullable","size","functional","any","createConditionalExpression","conditions","createStrictEquality","createIdentifier","input","ValueFactory","TYPEOF","reduce","createLogicalOr","undefined","TemplateFactory","generate"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;AAYR,IAAMC,+BAA+B,wBAC1CC,SACAC,YAAAA;AAEA,QAAMC,SAA0B,CAAA;AAEhCF,UAAQG,KAAK,CAACC,GAAGC,MAAMC,SAASF,EAAEG,IAAI,IAAID,SAASD,EAAEE,IAAI,CAAA;AACzDP,UAAQQ,QAAQ,CAACC,OAAOC,UAAAA;AAEtB,UAAMC,MAAcF,MAAME,IAAIC,eAAc;AAC5C,UAAMC,OAAwB;MAC5Bf,GAAGgB,QAAQC,oBAAoB,GAAGC,KAAKC,UAAUN,GAAAA,CAAAA,GAAO;MACxDF,MAAMS;;AAER,QAAIR,UAAUV,QAAQmB,SAAS,KAAKlB,QAAQkB,WAAW,EACrDN,MAAKO,KAAKtB,GAAGgB,QAAQC,oBAAoB,GAAG,CAAA;AAE9C,UAAMM,QACHZ,MAAMF,KAAKe,WAAU,MAAO,SAC3Bb,MAAMF,KAAKgB,aAAa,SACxBd,MAAMF,KAAKiB,KAAI,MAAO,KACvBf,MAAMF,KAAKkB,cACVhB,MAAMF,KAAKgB,aAAa,SACxBd,MAAMF,KAAKiB,KAAI,MAAO;AAE1B,QAAIH,UAAU,KAAM;aAElBZ,MAAMF,KAAKe,WAAU,MAAO,SAC5Bb,MAAMF,KAAKkB,eAAe,QAC1BhB,MAAMF,KAAKmB,QAAQ,KAEnBxB,QAAOkB,KACLtB,GAAGgB,QAAQa,6BACR,MAAA;AACC,YAAMC,aAAoC,CAAA;AAC1C,UAAInB,MAAMF,KAAKe,WAAU,MAAO,SAASb,MAAMF,KAAKmB,IAClDE,YAAWR,KACTtB,GAAGgB,QAAQe,qBACT/B,GAAGgB,QAAQgB,iBAAiB,WAAA,GAC5BrB,MAAMsB,KAAK,CAAA;AAGjB,UAAItB,MAAMF,KAAKkB,cAAchB,MAAMF,KAAKmB,IACtCE,YAAWR,KACTtB,GAAGgB,QAAQe,qBACT/B,GAAGgB,QAAQC,oBAAoB,UAAA,GAC/BiB,aAAaC,OAAOxB,MAAMsB,KAAK,CAAA,CAAA;AAGrC,aAAOH,WAAWT,WAAW,IACzBS,WAAW,CAAA,IACXA,WAAWM,OAAO,CAAC9B,GAAGC,MAAMP,GAAGgB,QAAQqB,gBAAgB/B,GAAGC,CAAAA,CAAAA;IAChE,GAAA,GACA+B,QACAtC,GAAGgB,QAAQC,oBAAoB,EAAA,GAC/BqB,QACAC,gBAAgBC,SAASzB,IAAAA,CAAAA,CAAAA;QAG1BX,QAAOkB,KAAI,GAAIP,IAAAA;EACtB,CAAA;AACA,SAAOX;AACT,GA9D4C;AAmE5C,IAAMI,WAAW,wBAACC,SAChBA,KAAKmB,OAAO,CAACnB,KAAKe,WAAU,KAAMf,KAAKkB,aAAa,IAAI,GADzC","sourcesContent":["import ts from \"typescript\";\n\nimport { TemplateFactory } from \"../../factories/TemplateFactory\";\nimport { ValueFactory } from \"../../factories/ValueFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\n\nimport { IExpressionEntry } from \"../helpers/IExpressionEntry\";\n\n/**\n * @internal\n */\nexport const stringify_regular_properties = (\n  regular: IExpressionEntry<ts.Expression>[],\n  dynamic: IExpressionEntry<ts.Expression>[],\n): ts.Expression[] => {\n  const output: ts.Expression[] = [];\n\n  regular.sort((x, y) => sequence(x.meta) - sequence(y.meta));\n  regular.forEach((entry, index) => {\n    // BASE ELEMENTS\n    const key: string = entry.key.getSoleLiteral()!;\n    const base: ts.Expression[] = [\n      ts.factory.createStringLiteral(`${JSON.stringify(key)}:`),\n      entry.expression,\n    ];\n    if (index !== regular.length - 1 || dynamic.length !== 0)\n      base.push(ts.factory.createStringLiteral(`,`));\n\n    const empty: boolean =\n      (entry.meta.isRequired() === false &&\n        entry.meta.nullable === false &&\n        entry.meta.size() === 0) ||\n      (entry.meta.functional &&\n        entry.meta.nullable === false &&\n        entry.meta.size() === 1);\n\n    if (empty === true) return;\n    else if (\n      entry.meta.isRequired() === false ||\n      entry.meta.functional === true ||\n      entry.meta.any === true\n    )\n      output.push(\n        ts.factory.createConditionalExpression(\n          (() => {\n            const conditions: ts.BinaryExpression[] = [];\n            if (entry.meta.isRequired() === false || entry.meta.any)\n              conditions.push(\n                ts.factory.createStrictEquality(\n                  ts.factory.createIdentifier(\"undefined\"),\n                  entry.input,\n                ),\n              );\n            if (entry.meta.functional || entry.meta.any)\n              conditions.push(\n                ts.factory.createStrictEquality(\n                  ts.factory.createStringLiteral(\"function\"),\n                  ValueFactory.TYPEOF(entry.input),\n                ),\n              );\n            return conditions.length === 1\n              ? conditions[0]!\n              : conditions.reduce((x, y) => ts.factory.createLogicalOr(x, y));\n          })(),\n          undefined,\n          ts.factory.createStringLiteral(\"\"),\n          undefined,\n          TemplateFactory.generate(base),\n        ),\n      );\n    else output.push(...base);\n  });\n  return output;\n};\n\n/**\n * @internal\n */\nconst sequence = (meta: Metadata): number =>\n  meta.any || !meta.isRequired() || meta.functional ? 0 : 1;\n"]}