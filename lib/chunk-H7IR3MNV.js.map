{"version":3,"sources":["../src/programmers/functional/FunctionalValidateParametersProgrammer.ts","../src/programmers/functional/FunctionalValidateFunctionProgrammer.ts","../src/programmers/functional/FunctionalValidateReturnProgrammer.ts"],"names":["ts","FunctionalValidateReturnProgrammer","write","project","modulo","equals","expression","declaration","async","statements","writeStatements","factory","createArrowFunction","createModifier","SyntaxKind","AsyncKeyword","undefined","parameters","FunctionalValidateFunctionProgrammer","getReturnTypeNode","createBlock","type","FunctionalGeneralProgrammer","getReturnType","checker","caller","createCallExpression","map","p","createIdentifier","name","getText","StringUtil","escapeDuplicate","StatementFactory","constant","ValidateProgrammer","createAwaitExpression","createIfStatement","createPrefixUnaryExpression","ExclamationToken","createPropertyAccessExpression","createExpressionStatement","createBinaryExpression","createToken","EqualsToken","hookErrors","replacer","createStringLiteral","createReturnStatement","FunctionalValidateParametersProgrammer","props","IdentifierFactory","parameter","createObjectLiteralExpression","createSpreadAssignment","createPropertyAssignment","typeArguments","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createTrue","createArrayLiteralExpression","resultName","validationResultArray","createAsExpression","getTypeFromTypeNode","TypeFactory","keyword","createQualifiedName","failures","createStrictEquality","createFalse","errorMatrix","createTemplateExpression","createTemplateHead","createTemplateSpan","createTemplateTail","GreaterThanToken","createNumericLiteral"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\nimport { FunctionalValidateFunctionProgrammer } from \"./FunctionalValidateFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalValidateParametersProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalValidateFunctionProgrammer.getReturnTypeNode(\n          declaration,\n          async,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...writeStatements(project)(modulo)(equals)(declaration),\n            ts.factory.createReturnStatement(\n              ts.factory.createObjectLiteralExpression(\n                [\n                  ts.factory.createPropertyAssignment(\n                    \"success\",\n                    ts.factory.createTrue(),\n                  ),\n                  ts.factory.createPropertyAssignment(\n                    \"data\",\n                    async ? ts.factory.createAwaitExpression(caller) : caller,\n                  ),\n                  ts.factory.createPropertyAssignment(\n                    \"errors\",\n                    ts.factory.createArrayLiteralExpression([]),\n                  ),\n                ],\n                true,\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (declaration: ts.FunctionDeclaration): ts.Statement[] => {\n      const resultName: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"paramResults\");\n      const validationResultArray: ts.ArrayLiteralExpression =\n        ts.factory.createArrayLiteralExpression(\n          declaration.parameters.map((p) =>\n            ts.factory.createAsExpression(\n              ts.factory.createCallExpression(\n                ValidateProgrammer.write(project)(modulo)(equals)(\n                  project.checker.getTypeFromTypeNode(\n                    p.type ?? TypeFactory.keyword(\"any\"),\n                  ),\n                ),\n                undefined,\n                [ts.factory.createIdentifier(p.name.getText())],\n              ),\n              ts.factory.createImportTypeNode(\n                ts.factory.createLiteralTypeNode(\n                  ts.factory.createStringLiteral(\"typia\"),\n                ),\n                undefined,\n                ts.factory.createQualifiedName(\n                  ts.factory.createIdentifier(\"IValidation\"),\n                  ts.factory.createIdentifier(\"IFailure\"),\n                ),\n                undefined,\n                false,\n              ),\n            ),\n          ),\n          true,\n        );\n      const failures = ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          validationResultArray,\n          \"filter\",\n        ),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [IdentifierFactory.parameter(\"r\")],\n            undefined,\n            undefined,\n            ts.factory.createStrictEquality(\n              ts.factory.createFalse(),\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(\"r\"),\n                \"success\",\n              ),\n            ),\n          ),\n        ],\n      );\n      const errorMatrix = ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(resultName),\n          \"map\",\n        ),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              IdentifierFactory.parameter(\"r\"),\n              IdentifierFactory.parameter(\"i\"),\n            ],\n            undefined,\n            undefined,\n            FunctionalValidateFunctionProgrammer.hookErrors({\n              expression: ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(\"r\"),\n                \"errors\",\n              ),\n              replacer: ts.factory.createTemplateExpression(\n                ts.factory.createTemplateHead(\"$input.parameters[\"),\n                [\n                  ts.factory.createTemplateSpan(\n                    ts.factory.createIdentifier(\"i\"),\n                    ts.factory.createTemplateTail(\"]\"),\n                  ),\n                ],\n              ),\n            }),\n          ),\n        ],\n      );\n      return [\n        StatementFactory.constant(resultName, failures),\n        ts.factory.createIfStatement(\n          ts.factory.createBinaryExpression(\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(resultName),\n              \"length\",\n            ),\n            ts.SyntaxKind.GreaterThanToken,\n            ts.factory.createNumericLiteral(\"0\"),\n          ),\n          ts.factory.createReturnStatement(\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"success\",\n                  ts.factory.createFalse(),\n                ),\n                ts.factory.createPropertyAssignment(\n                  \"errors\",\n                  ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      errorMatrix,\n                      \"flat\",\n                    ),\n                    undefined,\n                    undefined,\n                  ),\n                ),\n              ],\n              true,\n            ),\n          ),\n        ),\n      ];\n    };\n}\n","import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { FunctionalValidateParametersProgrammer } from \"./FunctionalValidateParametersProgrammer\";\nimport { FunctionalValidateReturnProgrammer } from \"./FunctionalValidateReturnProgrammer\";\n\nexport namespace FunctionalValidateFunctionProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } =\n        FunctionalValidateReturnProgrammer.writeStatements(project)(modulo)(\n          equals,\n        )(expression, declaration);\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        getReturnTypeNode(declaration, async),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...FunctionalValidateParametersProgrammer.writeStatements(project)(\n              modulo,\n            )(equals)(declaration),\n            ...statements,\n          ],\n          true,\n        ),\n      );\n    };\n\n  export const hookErrors = (props: {\n    expression: ts.Expression;\n    replacer: ts.Expression;\n  }): ts.CallExpression =>\n    ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(props.expression, \"map\"),\n      undefined,\n      [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [IdentifierFactory.parameter(\"error\")],\n          undefined,\n          undefined,\n          ts.factory.createObjectLiteralExpression(\n            [\n              ts.factory.createSpreadAssignment(\n                ts.factory.createIdentifier(\"error\"),\n              ),\n              ts.factory.createPropertyAssignment(\n                \"path\",\n                ts.factory.createCallExpression(\n                  ts.factory.createPropertyAccessExpression(\n                    ts.factory.createPropertyAccessExpression(\n                      ts.factory.createIdentifier(\"error\"),\n                      \"path\",\n                    ),\n                    \"replace\",\n                  ),\n                  undefined,\n                  [ts.factory.createStringLiteral(\"$input\"), props.replacer],\n                ),\n              ),\n            ],\n            true,\n          ),\n        ),\n      ],\n    );\n\n  export const getReturnTypeNode = (\n    declaration: ts.FunctionDeclaration,\n    async: boolean,\n  ): ts.TypeNode | undefined =>\n    declaration.type\n      ? async\n        ? !!(declaration.type! as ts.TypeReferenceNode).typeArguments?.[0]\n          ? ts.factory.createTypeReferenceNode(\"Promise\", [\n              ts.factory.createImportTypeNode(\n                ts.factory.createLiteralTypeNode(\n                  ts.factory.createStringLiteral(\"typia\"),\n                ),\n                undefined,\n                ts.factory.createIdentifier(\"IValidation\"),\n                [\n                  (declaration.type! as ts.TypeReferenceNode)\n                    .typeArguments![0]!,\n                ],\n              ),\n            ])\n          : undefined\n        : ts.factory.createImportTypeNode(\n            ts.factory.createLiteralTypeNode(\n              ts.factory.createStringLiteral(\"typia\"),\n            ),\n            undefined,\n            ts.factory.createIdentifier(\"IValidation\"),\n            [declaration.type],\n          )\n      : undefined;\n}\n","import ts from \"typescript\";\n\nimport { StatementFactory } from \"../../factories/StatementFactory\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { StringUtil } from \"../../utils/StringUtil\";\n\nimport { ValidateProgrammer } from \"../ValidateProgrammer\";\nimport { FunctionalValidateFunctionProgrammer } from \"./FunctionalValidateFunctionProgrammer\";\nimport { FunctionalGeneralProgrammer } from \"./internal/FunctionalGeneralProgrammer\";\n\nexport namespace FunctionalValidateReturnProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): ts.ArrowFunction => {\n      const { async, statements } = writeStatements(project)(modulo)(equals)(\n        expression,\n        declaration,\n      );\n      return ts.factory.createArrowFunction(\n        async\n          ? [ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : undefined,\n        undefined,\n        declaration.parameters,\n        FunctionalValidateFunctionProgrammer.getReturnTypeNode(\n          declaration,\n          async,\n        ),\n        undefined,\n        ts.factory.createBlock(statements, true),\n      );\n    };\n\n  export const writeStatements =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (equals: boolean) =>\n    (\n      expression: ts.Expression,\n      declaration: ts.FunctionDeclaration,\n    ): {\n      async: boolean;\n      statements: ts.Statement[];\n    } => {\n      const { type, async } = FunctionalGeneralProgrammer.getReturnType(\n        project.checker,\n      )(declaration);\n      const caller: ts.CallExpression = ts.factory.createCallExpression(\n        expression,\n        undefined,\n        declaration.parameters.map((p) =>\n          ts.factory.createIdentifier(p.name.getText()),\n        ),\n      );\n\n      const name: string = StringUtil.escapeDuplicate(\n        declaration.parameters.map((p) => p.name.getText()),\n      )(\"result\");\n      const statements: ts.Statement[] = [\n        StatementFactory.constant(\n          name,\n          ts.factory.createCallExpression(\n            ValidateProgrammer.write(project)(modulo)(equals)(type),\n            undefined,\n            [async ? ts.factory.createAwaitExpression(caller) : caller],\n          ),\n        ),\n        ts.factory.createIfStatement(\n          ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.ExclamationToken,\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier(name),\n              ts.factory.createIdentifier(\"success\"),\n            ),\n          ),\n          ts.factory.createExpressionStatement(\n            ts.factory.createBinaryExpression(\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier(name),\n                ts.factory.createIdentifier(\"errors\"),\n              ),\n              ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n              FunctionalValidateFunctionProgrammer.hookErrors({\n                expression: ts.factory.createPropertyAccessExpression(\n                  ts.factory.createIdentifier(name),\n                  ts.factory.createIdentifier(\"errors\"),\n                ),\n                replacer: ts.factory.createStringLiteral(\"$input.return\"),\n              }),\n            ),\n          ),\n        ),\n        ts.factory.createReturnStatement(ts.factory.createIdentifier(\"result\")),\n      ];\n      return {\n        async,\n        statements,\n      };\n    };\n}\n"]}