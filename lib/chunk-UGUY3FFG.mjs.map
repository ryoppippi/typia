{"version":3,"sources":["../src/transformers/internal/GenericTransformer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IProject } from \"../IProject\";\nimport { TransformerError } from \"../TransformerError\";\n\nexport namespace GenericTransformer {\n  export const scalar =\n    (method: string) =>\n    (\n      programmer: (\n        project: IProject,\n      ) => (\n        modulo: ts.LeftHandSideExpression,\n      ) => (type: ts.Type, name: string) => ts.ArrowFunction,\n    ) =>\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (expression: ts.CallExpression) => {\n      // CHECK PARAMETER\n      if (expression.arguments.length === 0)\n        throw new TransformerError({\n          code: `typia.${method}`,\n          message: `no input value.`,\n        });\n\n      // GET TYPE INFO\n      const [type, node, generic]: [ts.Type, ts.Node, boolean] =\n        expression.typeArguments && expression.typeArguments[0]\n          ? [\n              project.checker.getTypeFromTypeNode(expression.typeArguments[0]),\n              expression.typeArguments[0],\n              true,\n            ]\n          : [\n              project.checker.getTypeAtLocation(expression.arguments[0]!),\n              expression.arguments[0]!,\n              false,\n            ];\n      if (type.isTypeParameter())\n        throw new TransformerError({\n          code: `typia.${method}`,\n          message: `non-specified generic argument.`,\n        });\n\n      // DO TRANSFORM\n      return ts.factory.createCallExpression(\n        programmer(project)(modulo)(\n          type,\n          generic\n            ? node.getFullText().trim()\n            : name(project.checker)(type)(node),\n        ),\n        undefined,\n        expression.arguments,\n      );\n    };\n\n  export const factory =\n    (method: string) =>\n    (\n      programmer: (\n        project: IProject,\n      ) => (\n        modulo: ts.LeftHandSideExpression,\n      ) => (\n        type: ts.Type,\n        name: string,\n        init?: ts.Expression,\n      ) => ts.ArrowFunction,\n    ) =>\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (expression: ts.CallExpression) => {\n      // CHECK GENERIC ARGUMENT EXISTENCE\n      if (!expression.typeArguments?.[0])\n        throw new TransformerError({\n          code: `typia.${method}`,\n          message: `generic argument is not specified.`,\n        });\n\n      // GET TYPE INFO\n      const node: ts.TypeNode = expression.typeArguments[0];\n      const type: ts.Type = project.checker.getTypeFromTypeNode(node);\n\n      if (type.isTypeParameter())\n        throw new TransformerError({\n          code: `typia.${method}`,\n          message: `non-specified generic argument.`,\n        });\n\n      // DO TRANSFORM\n      return programmer(project)(modulo)(\n        type,\n        node.getFullText().trim(),\n        expression.arguments[0],\n      );\n    };\n\n  const name =\n    (checker: ts.TypeChecker) =>\n    (type: ts.Type) =>\n    (node: ts.Node): string =>\n      checker.typeToString(type, node, ts.TypeFormatFlags.NodeBuilderFlagsMask);\n}\n"],"mappings":";;;;;;;;AAAA,OAAOA,QAAQ;;UAKEC,qBAAAA;sBACFC,SACX,CAACC,WACD,CACEC,eAMF,CAACC,YACD,CAACC,WACD,CAACC,eAAAA;AAEC,QAAIA,WAAWC,UAAUC,WAAW,EAClC,OAAM,IAAIC,iBAAiB;MACzBC,MAAM,SAASR,MAAAA;MACfS,SAAS;IACX,CAAA;AAGF,UAAM,CAACC,MAAMC,MAAMC,OAAAA,IACjBR,WAAWS,iBAAiBT,WAAWS,cAAc,CAAA,IACjD;MACEX,QAAQY,QAAQC,oBAAoBX,WAAWS,cAAc,CAAA,CAAE;MAC/DT,WAAWS,cAAc,CAAA;MACzB;QAEF;MACEX,QAAQY,QAAQE,kBAAkBZ,WAAWC,UAAU,CAAA,CAAE;MACzDD,WAAWC,UAAU,CAAA;MACrB;;AAER,QAAIK,KAAKO,gBAAe,EACtB,OAAM,IAAIV,iBAAiB;MACzBC,MAAM,SAASR,MAAAA;MACfS,SAAS;IACX,CAAA;AAGF,WAAOS,GAAGC,QAAQC,qBAChBnB,WAAWC,OAAAA,EAASC,MAAAA,EAClBO,MACAE,UACID,KAAKU,YAAW,EAAGC,KAAI,IACvBC,KAAKrB,QAAQY,OAAO,EAAEJ,IAAAA,EAAMC,IAAAA,CAAAA,GAElCa,QACApB,WAAWC,SAAS;EAExB;sBAEWc,UACX,CAACnB,WACD,CACEC,eAUF,CAACC,YACD,CAACC,WACD,CAACC,eAAAA;AAEC,QAAI,CAACA,WAAWS,gBAAgB,CAAA,EAC9B,OAAM,IAAIN,iBAAiB;MACzBC,MAAM,SAASR,MAAAA;MACfS,SAAS;IACX,CAAA;AAGF,UAAME,OAAoBP,WAAWS,cAAc,CAAA;AACnD,UAAMH,OAAgBR,QAAQY,QAAQC,oBAAoBJ,IAAAA;AAE1D,QAAID,KAAKO,gBAAe,EACtB,OAAM,IAAIV,iBAAiB;MACzBC,MAAM,SAASR,MAAAA;MACfS,SAAS;IACX,CAAA;AAGF,WAAOR,WAAWC,OAAAA,EAASC,MAAAA,EACzBO,MACAC,KAAKU,YAAW,EAAGC,KAAI,GACvBlB,WAAWC,UAAU,CAAA,CAAE;EAE3B;AAEF,QAAMkB,OACJ,wBAACT,YACD,CAACJ,SACD,CAACC,SACCG,QAAQW,aAAaf,MAAMC,MAAMO,GAAGQ,gBAAgBC,oBAAoB,GAH1E;AAIJ,GAlGiB7B,uBAAAA,qBAAAA,CAAAA,EAAAA;","names":["ts","GenericTransformer","scalar","method","programmer","project","modulo","expression","arguments","length","TransformerError","code","message","type","node","generic","typeArguments","checker","getTypeFromTypeNode","getTypeAtLocation","isTypeParameter","ts","factory","createCallExpression","getFullText","trim","name","undefined","typeToString","TypeFormatFlags","NodeBuilderFlagsMask"]}