{"version":3,"sources":["../src/programmers/helpers/RandomJoiner.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nexport namespace RandomJoiner {\n  export type Decoder = (meta: Metadata) => ts.Expression;\n\n  export const array =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (explore: IExplore) =>\n    (length: ts.Expression | undefined) =>\n    (item: Metadata): ts.Expression => {\n      const generator: ts.Expression = ts.factory.createCallExpression(\n        coalesce(\"array\"),\n        undefined,\n        [\n          ts.factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            undefined,\n            decoder(item),\n          ),\n          ...(length ? [length] : []),\n        ],\n      );\n      if (explore.recursive === false) return generator;\n      return ts.factory.createConditionalExpression(\n        ts.factory.createGreaterThanEquals(\n          ExpressionFactory.number(5),\n          ts.factory.createIdentifier(\"_depth\"),\n        ),\n        undefined,\n        generator,\n        undefined,\n        ts.factory.createArrayLiteralExpression([]),\n      );\n    };\n\n  export const tuple = (decoder: Decoder) => (elements: Metadata[]) =>\n    ts.factory.createArrayLiteralExpression(\n      elements.map((elem) => decoder(elem.rest ?? elem)),\n      true,\n    );\n\n  export const object =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (obj: MetadataObject): ts.ConciseBody => {\n      if (obj.properties.length === 0) return ts.factory.createIdentifier(\"{}\");\n\n      // LIST UP PROPERTIES\n      const regular = obj.properties.filter((p) => p.key.isSoleLiteral());\n      const dynamic = obj.properties.filter((p) => !p.key.isSoleLiteral());\n\n      // REGULAR OBJECT\n      const literal: ts.ObjectLiteralExpression =\n        ts.factory.createObjectLiteralExpression(\n          regular.map((p) => {\n            const str: string = p.key.getSoleLiteral()!;\n            return ts.factory.createPropertyAssignment(\n              Escaper.variable(str) ? str : ts.factory.createStringLiteral(str),\n              decoder(p.value),\n            );\n          }),\n          true,\n        );\n      if (dynamic.length === 0) return literal;\n\n      const properties: ts.Statement[] = dynamic.map((p) =>\n        ts.factory.createExpressionStatement(\n          dynamicProperty(coalesce)(decoder)(p),\n        ),\n      );\n      return ts.factory.createBlock(\n        [\n          StatementFactory.constant(\n            \"output\",\n            ts.factory.createAsExpression(literal, TypeFactory.keyword(\"any\")),\n          ),\n          ...(obj.recursive\n            ? [\n                ts.factory.createIfStatement(\n                  ts.factory.createGreaterThanEquals(\n                    ExpressionFactory.number(5),\n                    ts.factory.createIdentifier(\"_depth\"),\n                  ),\n                  ts.factory.createBlock(properties, true),\n                ),\n              ]\n            : properties),\n          ts.factory.createReturnStatement(\n            ts.factory.createIdentifier(\"output\"),\n          ),\n        ],\n        true,\n      );\n    };\n\n  const dynamicProperty =\n    (coalesce: (method: string) => ts.Expression) =>\n    (decoder: Decoder) =>\n    (p: MetadataProperty) =>\n      ts.factory.createCallExpression(coalesce(\"array\"), undefined, [\n        ts.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          undefined,\n          ts.factory.createBinaryExpression(\n            ts.factory.createElementAccessExpression(\n              ts.factory.createIdentifier(\"output\"),\n              decoder(p.key),\n            ),\n            ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n            decoder(p.value),\n          ),\n        ),\n        ts.factory.createCallExpression(coalesce(\"integer\"), undefined, [\n          ExpressionFactory.number(0),\n          ExpressionFactory.number(3),\n        ]),\n      ]);\n}\n\ninterface IExplore {\n  function: boolean;\n  recursive: boolean;\n}\n"],"mappings":"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","names":["ts","RandomJoiner","array","coalesce","decoder","explore","length","item","generator","ts","factory","createCallExpression","undefined","createArrowFunction","recursive","createConditionalExpression","createGreaterThanEquals","ExpressionFactory","number","createIdentifier","createArrayLiteralExpression","tuple","elements","map","elem","rest","object","obj","properties","regular","filter","p","key","isSoleLiteral","dynamic","literal","createObjectLiteralExpression","str","getSoleLiteral","createPropertyAssignment","Escaper","variable","createStringLiteral","value","createExpressionStatement","dynamicProperty","createBlock","StatementFactory","constant","createAsExpression","TypeFactory","keyword","createIfStatement","createReturnStatement","createBinaryExpression","createElementAccessExpression","createToken","SyntaxKind","EqualsToken"]}