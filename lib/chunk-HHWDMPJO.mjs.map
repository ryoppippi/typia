{"version":3,"sources":["../src/programmers/protobuf/ProtobufDecodeProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { ProtobufFactory } from \"../../factories/ProtobufFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ProtobufAtomic } from \"../../typings/ProtobufAtomic\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { ProtobufUtil } from \"../helpers/ProtobufUtil\";\n\nexport namespace ProtobufDecodeProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const meta: Metadata = ProtobufFactory.metadata(modulo.getText())(\n        project.checker,\n        project.context,\n      )(collection)(type);\n\n      const functors = collection\n        .objects()\n        .filter((obj) => ProtobufUtil.isStaticObject(obj))\n        .map((obj) =>\n          StatementFactory.constant(\n            `${PREFIX}o${obj.index}`,\n            write_object_function(project)(importer)(obj),\n          ),\n        );\n      const reader = StatementFactory.constant(\n        \"reader\",\n        ts.factory.createNewExpression(importer.use(\"Reader\"), undefined, [\n          ts.factory.createIdentifier(\"input\"),\n        ]),\n      );\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\"Uint8Array\"),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...importer.declare(modulo),\n            ...functors,\n            reader,\n            ts.factory.createReturnStatement(\n              decode_regular_object(true)(meta.objects[0]!),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const write_object_function =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (obj: MetadataObject): ts.ArrowFunction =>\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\"reader\"),\n          IdentifierFactory.parameter(\n            \"length\",\n            TypeFactory.keyword(\"number\"),\n            ExpressionFactory.number(-1),\n          ),\n        ],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ts.factory.createExpressionStatement(\n              ts.factory.createBinaryExpression(\n                ts.factory.createIdentifier(\"length\"),\n                ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                ts.factory.createConditionalExpression(\n                  ts.factory.createLessThan(\n                    ts.factory.createIdentifier(\"length\"),\n                    ExpressionFactory.number(0),\n                  ),\n                  undefined,\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"size\"),\n                    undefined,\n                    undefined,\n                  ),\n                  undefined,\n                  ts.factory.createAdd(\n                    ts.factory.createCallExpression(\n                      IdentifierFactory.access(READER())(\"index\"),\n                      undefined,\n                      undefined,\n                    ),\n                    ts.factory.createIdentifier(\"length\"),\n                  ),\n                ),\n              ),\n            ),\n            ...write_object_function_body(project)(importer)({\n              condition: ts.factory.createLessThan(\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(READER())(\"index\"),\n                  undefined,\n                  undefined,\n                ),\n                ts.factory.createIdentifier(\"length\"),\n              ),\n              tag: \"tag\",\n              output: \"output\",\n            })(obj.properties),\n            ts.factory.createReturnStatement(\n              ts.factory.createIdentifier(\"output\"),\n            ),\n          ],\n          true,\n        ),\n      );\n\n  const write_object_function_body =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (props: { condition: ts.Expression; tag: string; output: string }) =>\n    (properties: MetadataProperty[]): ts.Statement[] => {\n      let i: number = 1;\n      const clauses: ts.CaseClause[] = properties\n        .map((p) => {\n          const clause = decode_property(project)(importer)(i)(\n            IdentifierFactory.access(ts.factory.createIdentifier(props.output))(\n              p.key.getSoleLiteral()!,\n            ),\n            p.value,\n          );\n          i += ProtobufUtil.size(p.value);\n          return clause;\n        })\n        .flat();\n      return [\n        StatementFactory.constant(\n          props.output,\n          ts.factory.createAsExpression(\n            ts.factory.createObjectLiteralExpression(\n              properties\n                .filter(\n                  (p) =>\n                    !(\n                      project.compilerOptions.exactOptionalPropertyTypes ===\n                        true && p.value.optional === true\n                    ),\n                )\n                .map((p) =>\n                  ts.factory.createPropertyAssignment(\n                    IdentifierFactory.identifier(p.key.getSoleLiteral()!),\n                    write_property_default_value(p.value),\n                  ),\n                ),\n              true,\n            ),\n            TypeFactory.keyword(\"any\"),\n          ),\n        ),\n        ts.factory.createWhileStatement(\n          props.condition,\n          ts.factory.createBlock([\n            StatementFactory.constant(\n              props.tag,\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(READER())(\"uint32\"),\n                undefined,\n                undefined,\n              ),\n            ),\n            ts.factory.createSwitchStatement(\n              ts.factory.createUnsignedRightShift(\n                ts.factory.createIdentifier(props.tag),\n                ExpressionFactory.number(3),\n              ),\n              ts.factory.createCaseBlock([\n                ...clauses,\n                ts.factory.createDefaultClause([\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createCallExpression(\n                      IdentifierFactory.access(READER())(\"skipType\"),\n                      undefined,\n                      [\n                        ts.factory.createBitwiseAnd(\n                          ts.factory.createIdentifier(props.tag),\n                          ExpressionFactory.number(7),\n                        ),\n                      ],\n                    ),\n                  ),\n                  ts.factory.createBreakStatement(),\n                ]),\n              ]),\n            ),\n          ]),\n        ),\n      ];\n    };\n\n  const write_property_default_value = (value: Metadata) =>\n    ts.factory.createAsExpression(\n      value.nullable\n        ? ts.factory.createNull()\n        : value.isRequired() === false\n          ? ts.factory.createIdentifier(\"undefined\")\n          : value.arrays.length\n            ? ts.factory.createArrayLiteralExpression()\n            : value.maps.length\n              ? ts.factory.createNewExpression(\n                  ts.factory.createIdentifier(\"Map\"),\n                  undefined,\n                  [],\n                )\n              : value.natives.length\n                ? ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    undefined,\n                    [],\n                  )\n                : value.atomics.some((a) => a.type === \"string\") ||\n                    value.constants.some(\n                      (c) =>\n                        c.type === \"string\" &&\n                        c.values.some((v) => v.value === \"\"),\n                    ) ||\n                    value.templates.some(\n                      (tpl) =>\n                        tpl.length === 1 && tpl[0]!.getName() === \"string\",\n                    )\n                  ? ts.factory.createStringLiteral(\"\")\n                  : value.objects.length &&\n                      value.objects.some(\n                        (obj) => !ProtobufUtil.isStaticObject(obj),\n                      )\n                    ? ts.factory.createObjectLiteralExpression()\n                    : ts.factory.createIdentifier(\"undefined\"),\n      TypeFactory.keyword(\"any\"),\n    );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode_property =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      meta: Metadata,\n    ): ts.CaseClause[] => {\n      const clauses: ts.CaseClause[] = [];\n      const emplace = (name: string) => (v: ts.Expression | ts.Statement[]) =>\n        clauses.push(\n          ts.factory.createCaseClause(\n            ExpressionFactory.number(index++),\n            Array.isArray(v)\n              ? [\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createIdentifier(`// type: ${name}`),\n                  ),\n                  ...v,\n                  ts.factory.createBreakStatement(),\n                ]\n              : [\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createIdentifier(`// ${name}`),\n                  ),\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createBinaryExpression(\n                      accessor,\n                      ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                      v,\n                    ),\n                  ),\n                  ts.factory.createBreakStatement(),\n                ],\n          ),\n        );\n\n      const required: boolean = meta.isRequired() && !meta.nullable;\n      for (const atomic of ProtobufUtil.getAtomics(meta))\n        emplace(atomic)(decode_atomic(meta)(atomic));\n      if (meta.natives.length) emplace(\"bytes\")(decode_bytes(\"bytes\"));\n      for (const array of meta.arrays)\n        emplace(`Array<${array.type.value.getName()}>`)(\n          decode_array(accessor, array, required),\n        );\n      for (const map of meta.maps)\n        emplace(`Map<string, ${map.value.getName()}>`)(\n          decode_map(project)(importer)(accessor, map, required),\n        );\n      for (const obj of meta.objects)\n        emplace(obj.name)(\n          ProtobufUtil.isStaticObject(obj)\n            ? decode_regular_object(false)(obj)\n            : decode_dynamic_object(project)(importer)(accessor, obj, required),\n        );\n      return clauses;\n    };\n\n  const decode_atomic =\n    (meta: Metadata) =>\n    (atomic: ProtobufAtomic): ts.Expression => {\n      if (atomic === \"string\") return decode_bytes(\"string\");\n\n      const call: ts.CallExpression = ts.factory.createCallExpression(\n        IdentifierFactory.access(ts.factory.createIdentifier(\"reader\"))(atomic),\n        undefined,\n        undefined,\n      );\n      if (atomic !== \"int64\" && atomic !== \"uint64\") return call;\n\n      const isNumber: boolean = ProtobufUtil.getNumbers(meta).some(\n        (n) => n === atomic,\n      );\n      return isNumber\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Number\"),\n            undefined,\n            [call],\n          )\n        : call;\n    };\n\n  const decode_bytes = (method: \"bytes\" | \"string\"): ts.Expression =>\n    ts.factory.createCallExpression(\n      IdentifierFactory.access(ts.factory.createIdentifier(\"reader\"))(method),\n      undefined,\n      undefined,\n    );\n\n  const decode_array = (\n    accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n    array: MetadataArray,\n    required: boolean,\n  ): ts.Statement[] => {\n    const statements: Array<ts.Expression | ts.Statement> = [];\n    if (required === false)\n      statements.push(\n        ts.factory.createBinaryExpression(\n          accessor,\n          ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n          ts.factory.createAsExpression(\n            ts.factory.createArrayLiteralExpression(),\n            ts.factory.createTypeReferenceNode(\"any[]\"),\n          ),\n        ),\n      );\n    const atomics = ProtobufUtil.getAtomics(array.type.value);\n    const decoder = atomics.length\n      ? () => decode_atomic(array.type.value)(atomics[0]!)\n      : array.type.value.natives.length\n        ? () => decode_bytes(\"bytes\")\n        : array.type.value.objects.length\n          ? () => decode_regular_object(false)(array.type.value.objects[0]!)\n          : null;\n    if (decoder === null) throw new Error(\"Never reach here.\");\n    else if (atomics.length && atomics[0] !== \"string\") {\n      statements.push(\n        ts.factory.createIfStatement(\n          ts.factory.createStrictEquality(\n            ExpressionFactory.number(2),\n            ts.factory.createBitwiseAnd(\n              ts.factory.createIdentifier(\"tag\"),\n              ExpressionFactory.number(7),\n            ),\n          ),\n          ts.factory.createBlock(\n            [\n              StatementFactory.constant(\n                \"piece\",\n                ts.factory.createAdd(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"uint32\"),\n                    undefined,\n                    undefined,\n                  ),\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"index\"),\n                    undefined,\n                    undefined,\n                  ),\n                ),\n              ),\n              ts.factory.createWhileStatement(\n                ts.factory.createLessThan(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"index\"),\n                    undefined,\n                    undefined,\n                  ),\n                  ts.factory.createIdentifier(\"piece\"),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(accessor)(\"push\"),\n                    undefined,\n                    [decoder()],\n                  ),\n                ),\n              ),\n            ],\n            true,\n          ),\n          ts.factory.createExpressionStatement(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(accessor)(\"push\"),\n              undefined,\n              [decoder()],\n            ),\n          ),\n        ),\n      );\n    } else\n      statements.push(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(accessor)(\"push\"),\n          undefined,\n          [decoder()],\n        ),\n      );\n    return statements.map((stmt) =>\n      ts.isExpression(stmt) ? ts.factory.createExpressionStatement(stmt) : stmt,\n    );\n  };\n\n  const decode_regular_object =\n    (top: boolean) =>\n    (obj: MetadataObject): ts.Expression =>\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(`${PREFIX}o${obj.index}`),\n        undefined,\n        [\n          ts.factory.createIdentifier(\"reader\"),\n          ...(top\n            ? []\n            : [\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(READER())(\"uint32\"),\n                  undefined,\n                  undefined,\n                ),\n              ]),\n        ],\n      );\n\n  const decode_dynamic_object =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      obj: MetadataObject,\n      required: boolean,\n    ): ts.Statement[] => {\n      const top = obj.properties[0]!;\n      return decode_entry(project)(importer)({\n        initializer: () =>\n          ts.factory.createBinaryExpression(\n            accessor,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n            ts.factory.createObjectLiteralExpression(),\n          ),\n        setter: () =>\n          ts.factory.createBinaryExpression(\n            ts.factory.createElementAccessExpression(\n              accessor,\n              ts.factory.createIdentifier(\"entry.key\"),\n            ),\n            ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n            ts.factory.createIdentifier(\"entry.value\"),\n          ),\n      })(\n        MetadataProperty.create({\n          ...top,\n          key: (() => {\n            const key: Metadata = Metadata.initialize();\n            key.atomics.push(\n              MetadataAtomic.create({\n                type: \"string\",\n                tags: [],\n              }),\n            );\n            return key;\n          })(),\n        }),\n        required,\n      );\n    };\n\n  const decode_map =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      map: Metadata.Entry,\n      required: boolean,\n    ): ts.Statement[] =>\n      decode_entry(project)(importer)({\n        initializer: () =>\n          ts.factory.createBinaryExpression(\n            accessor,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Map\"),\n              [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n              [],\n            ),\n          ),\n        setter: () =>\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(accessor)(\"set\"),\n            undefined,\n            [\n              ts.factory.createIdentifier(\"entry.key\"),\n              ts.factory.createIdentifier(\"entry.value\"),\n            ],\n          ),\n      })(map, required);\n\n  const decode_entry =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (props: {\n      initializer: () => ts.Expression;\n      setter: () => ts.Expression;\n    }) =>\n    (map: Metadata.Entry, required: boolean): ts.Statement[] => {\n      const statements: ts.Statement[] = [\n        ...(required\n          ? []\n          : [ts.factory.createExpressionStatement(props.initializer())]),\n        StatementFactory.constant(\n          \"piece\",\n          ts.factory.createAdd(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"uint32\"),\n              undefined,\n              undefined,\n            ),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"index\"),\n              undefined,\n              undefined,\n            ),\n          ),\n        ),\n        ...write_object_function_body(project)(importer)({\n          condition: ts.factory.createLessThan(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"index\"),\n              undefined,\n              undefined,\n            ),\n            ts.factory.createIdentifier(\"piece\"),\n          ),\n          tag: \"kind\",\n          output: \"entry\",\n        })([\n          MetadataProperty.create({\n            key: MetadataFactory.soleLiteral(\"key\"),\n            value: map.key,\n            description: null,\n            jsDocTags: [],\n          }),\n          MetadataProperty.create({\n            key: MetadataFactory.soleLiteral(\"value\"),\n            value: map.value,\n            description: null,\n            jsDocTags: [],\n          }),\n        ]),\n        ts.factory.createExpressionStatement(props.setter()),\n      ];\n      return [\n        ts.factory.createExpressionStatement(\n          ExpressionFactory.selfCall(ts.factory.createBlock(statements, true)),\n        ),\n      ];\n    };\n}\n\nconst PREFIX = \"$pd\";\nconst READER = () => ts.factory.createIdentifier(\"reader\");\n"],"mappings":"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","names":["ts","ProtobufDecodeProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","meta","ProtobufFactory","metadata","checker","context","functors","objects","filter","obj","ProtobufUtil","isStaticObject","map","StatementFactory","constant","PREFIX","index","write_object_function","reader","ts","factory","createNewExpression","use","undefined","createIdentifier","createArrowFunction","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","TypeFactory","getFullName","createBlock","declare","createReturnStatement","decode_regular_object","keyword","ExpressionFactory","number","createExpressionStatement","createBinaryExpression","createToken","SyntaxKind","EqualsToken","createConditionalExpression","createLessThan","createCallExpression","access","READER","createAdd","write_object_function_body","condition","tag","output","properties","props","i","clauses","p","clause","decode_property","key","getSoleLiteral","value","size","flat","createAsExpression","createObjectLiteralExpression","compilerOptions","exactOptionalPropertyTypes","optional","createPropertyAssignment","identifier","write_property_default_value","createWhileStatement","createSwitchStatement","createUnsignedRightShift","createCaseBlock","createDefaultClause","createBitwiseAnd","createBreakStatement","nullable","createNull","isRequired","arrays","length","createArrayLiteralExpression","maps","natives","atomics","some","a","constants","c","values","v","templates","tpl","getName","accessor","emplace","push","createCaseClause","Array","isArray","required","atomic","getAtomics","decode_atomic","decode_bytes","array","decode_array","decode_map","decode_dynamic_object","call","isNumber","getNumbers","n","method","statements","QuestionQuestionEqualsToken","decoder","Error","createIfStatement","createStrictEquality","stmt","isExpression","top","decode_entry","initializer","setter","createElementAccessExpression","MetadataProperty","create","Metadata","initialize","MetadataAtomic","tags","MetadataFactory","soleLiteral","description","jsDocTags","selfCall"]}