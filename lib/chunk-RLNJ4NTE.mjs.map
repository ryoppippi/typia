{"version":3,"sources":["../src/programmers/http/HttpFormDataProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { HttpMetadataUtil } from \"../helpers/HttpMetadataUtil\";\n\nexport namespace HttpFormDataProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      // GET OBJECT TYPE\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.http.${importer.method}`)(\n          result.errors,\n        );\n\n      // DO TRANSFORM\n      const object: MetadataObject = result.data.objects[0]!;\n      const statements: ts.Statement[] = decode_object(importer)(object);\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\"FormData\"),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo), ...statements],\n          true,\n        ),\n      );\n    };\n\n  export const validate = (\n    meta: Metadata,\n    explore: MetadataFactory.IExplore,\n  ): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (explore.top === true) {\n      // TOP MUST BE ONLY OBJECT\n      if (meta.objects.length !== 1 || meta.bucket() !== 1)\n        insert(\"only one object type is allowed.\");\n      if (meta.nullable === true) insert(\"formdata parameters cannot be null.\");\n      if (meta.isRequired() === false)\n        insert(\"formdata parameters cannot be undefined.\");\n    } else if (\n      explore.nested !== null &&\n      explore.nested instanceof MetadataArrayType\n    ) {\n      //----\n      // ARRAY\n      //----\n      const atomics = HttpMetadataUtil.atomics(meta);\n      const expected: number =\n        meta.atomics.length +\n        meta.templates.length +\n        meta.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0) +\n        meta.natives.filter((n) => n === \"Blob\" || n === \"File\").length;\n      if (atomics.size > 1) insert(\"union type is not allowed in array.\");\n      if (meta.size() !== expected)\n        insert(\n          \"only atomic, constant or blob (file) types are allowed in array.\",\n        );\n    } else if (explore.object && explore.property !== null) {\n      //----\n      // COMMON\n      //----\n      // PROPERTY MUST BE SOLE\n      if (typeof explore.property === \"object\")\n        insert(\"dynamic property is not allowed.\");\n      // DO NOT ALLOW TUPLE TYPE\n      if (meta.tuples.length) insert(\"tuple type is not allowed.\");\n      // DO NOT ALLOW UNION TYPE\n      if (HttpMetadataUtil.isUnion(meta)) insert(\"union type is not allowed.\");\n      // DO NOT ALLOW NESTED OBJECT\n      if (\n        meta.objects.length ||\n        meta.sets.length ||\n        meta.maps.length ||\n        meta.natives.filter((n) => n !== \"Blob\" && n !== \"File\").length\n      )\n        insert(\"nested object type is not allowed.\");\n    }\n    return errors;\n  };\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (object: MetadataObject): ts.Statement[] => {\n      // const input: ts.Identifier = ts.factory.createIdentifier(\"input\");\n      const output: ts.Identifier = ts.factory.createIdentifier(\"output\");\n      return [\n        StatementFactory.constant(\n          \"output\",\n          ts.factory.createObjectLiteralExpression(\n            object.properties.map((prop) =>\n              decode_regular_property(importer)(prop),\n            ),\n            true,\n          ),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createAsExpression(output, TypeFactory.keyword(\"any\")),\n        ),\n      ];\n    };\n\n  const decode_regular_property =\n    (importer: FunctionImporter) =>\n    (property: MetadataProperty): ts.PropertyAssignment => {\n      const key: string = property.key.constants[0]!.values[0]!.value as string;\n      const value: Metadata = property.value;\n\n      const [type, isArray]: [Atomic.Literal | \"blob\" | \"file\", boolean] = value\n        .atomics.length\n        ? [value.atomics[0]!.type, false]\n        : value.constants.length\n          ? [value.constants[0]!.type, false]\n          : value.templates.length\n            ? [\"string\", false]\n            : value.natives.includes(\"Blob\")\n              ? [\"blob\", false]\n              : value.natives.includes(\"File\")\n                ? [\"file\", false]\n                : (() => {\n                    const meta =\n                      value.arrays[0]?.type.value ??\n                      value.tuples[0]!.type.elements[0]!;\n                    return meta.atomics.length\n                      ? [meta.atomics[0]!.type, true]\n                      : meta.templates.length\n                        ? [\"string\", true]\n                        : meta.natives.includes(\"Blob\")\n                          ? [\"blob\", true]\n                          : meta.natives.includes(\"File\")\n                            ? [\"file\", true]\n                            : [meta.constants[0]!.type, true];\n                  })();\n      return ts.factory.createPropertyAssignment(\n        Escaper.variable(key) ? key : ts.factory.createStringLiteral(key),\n        isArray\n          ? decode_array(importer)(value)(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"input.getAll\"),\n                    undefined,\n                    [ts.factory.createStringLiteral(key)],\n                  ),\n                )(\"map\"),\n                undefined,\n                [\n                  ts.factory.createArrowFunction(\n                    undefined,\n                    undefined,\n                    [IdentifierFactory.parameter(\"elem\")],\n                    undefined,\n                    undefined,\n                    decode_value(importer)(type)(false)(\n                      ts.factory.createIdentifier(\"elem\"),\n                    ),\n                  ),\n                ],\n              ),\n            )\n          : decode_value(importer)(type)(\n              value.nullable === false && value.isRequired() === false,\n            )(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"input.get\"),\n                undefined,\n                [ts.factory.createStringLiteral(key)],\n              ),\n            ),\n      );\n    };\n\n  const decode_value =\n    (importer: FunctionImporter) =>\n    (type: Atomic.Literal | \"blob\" | \"file\") =>\n    (onlyUndefindable: boolean) =>\n    (value: ts.Expression) => {\n      const call = ts.factory.createCallExpression(\n        importer.use(type),\n        undefined,\n        [value],\n      );\n      return onlyUndefindable\n        ? ts.factory.createBinaryExpression(\n            call,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n            ts.factory.createIdentifier(\"undefined\"),\n          )\n        : call;\n    };\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (value: Metadata) =>\n    (expression: ts.Expression): ts.Expression =>\n      value.nullable || value.isRequired() === false\n        ? ts.factory.createCallExpression(importer.use(\"array\"), undefined, [\n            expression,\n            value.nullable\n              ? ts.factory.createNull()\n              : ts.factory.createIdentifier(\"undefined\"),\n          ])\n        : expression;\n}\n"],"mappings":"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","names":["ts","HttpFormDataProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","success","TransformerError","from","method","errors","object","data","objects","statements","decode_object","ts","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","meta","explore","insert","msg","push","top","length","bucket","nullable","isRequired","nested","MetadataArrayType","atomics","HttpMetadataUtil","expected","templates","constants","map","c","values","reduce","a","b","natives","filter","n","size","property","tuples","isUnion","sets","maps","output","StatementFactory","createObjectLiteralExpression","properties","prop","decode_regular_property","createReturnStatement","createAsExpression","keyword","key","value","isArray","includes","arrays","elements","createPropertyAssignment","Escaper","variable","decode_array","createCallExpression","access","decode_value","onlyUndefindable","call","use","createBinaryExpression","createToken","SyntaxKind","QuestionQuestionToken","expression","createNull"]}