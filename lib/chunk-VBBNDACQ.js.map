{"version":3,"sources":["../src/protobuf.ts"],"names":["protobuf_exports","message","halt","decode","decodePure","Object","assign","Namespace","protobuf","assertDecode","assertDecodePure","assert","isDecode","isDecodePure","is","validateDecode","validateDecodePure","validate","encode","encodePure","assertEncode","assertEncodePure","isEncode","isEncodePure","validateEncode","validateEncodePure","createDecode","createDecodePure","createIsDecode","createIsDecodePure","createAssertDecode","createAssertDecodePure","createValidateDecode","createValidateDecodePure","createEncode","createEncodePure","createIsEncode","createIsEncodePure","createAssertEncode","createAssertEncodePure","createValidateEncode","createValidateEncodePure","name","Error"],"mappings":"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","sourcesContent":["import * as Namespace from \"./functional/Namespace\";\n\nimport { IValidation } from \"./IValidation\";\nimport { Resolved } from \"./Resolved\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\n/* ===========================================================\n    PROTOCOL BUFFER\n      - MESSAGE\n      - DECODE\n      - ENCODE\n      - FACTORY FUNCTIONS\n==============================================================\n    SCHEMA\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Message Schema.\n *\n * Creates a Protocol Buffer Message Schema from a TypeScript type. The message\n * schema would be returned as a string value, and it can be used to share with\n * other developers/languages/frameworks.\n *\n * For reference, Protocol Buffer has lots of restrictions, so that expression power\n * of Protocol Buffer is not enough strong to fully meet the TypeScript type specs.\n * In such reason, if you put a TypeScript type that is not compatible with Protocol\n * Buffer, this function would throw compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Target type\n * @returns Protocol Buffer Message Schema.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function message(): never;\n\n/**\n * Protocol Buffer Message Schema.\n *\n * Creates a Protocol Buffer Message Schema from a TypeScript type. The message\n * schema would be returned as a string value, and it can be used to share with\n * other developers/languages/frameworks.\n *\n * For reference, Protocol Buffer has lots of restrictions, so that expression power\n * of Protocol Buffer is not enough strong to fully meet the TypeScript type specs.\n * In such reason, if you put a TypeScript type that is not compatible with Protocol\n * Buffer, this function would throw compilation errors.\n *\n * @template T Target type\n * @returns Protocol Buffer Message Schema.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function message<T>(): string;\n\n/**\n * @internal\n */\nexport function message(): never {\n  halt(\"message\");\n}\n\n/* -----------------------------------------------------------\n    DECODE\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder.\n *\n * `typia.protobuf.decode()` is a function decoding a binary data of Protocol Buffer\n * format to a TypeScript instance.\n *\n * For reference, as Protocol Buffer handles binary data directly, there's no way\n * when `input` binary data was not encoded from the `T` typed value. In that case,\n * unexpected behavior or internal error would be occured. Therefore, I recommend you\n * to encode binary data of Protocol Buffer from type safe encode functions like below.\n * Use {@link encode} function only when you can ensure it.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * Also, `typia` is providing type safe decoders like {@link assertDecode}, but it\n * is just for additional type validation like `number & Minimum<7>` or\n * `string & Format<\"uuid\">` cases, that are represented by\n * [custom tags](https://typia.io/docs/validators/tags). Thus, I repeat that,\n * you've to ensure the type safety when using decoder functions.\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction decode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder.\n *\n * `typia.protobuf.decode()` is a function decoding a binary data of Protocol Buffer\n * format to a TypeScript instance.\n *\n * For reference, as Protocol Buffer handles binary data directly, there's no way\n * when `input` binary data was not encoded from the `T` typed value. In that case,\n * unexpected behavior or internal error would be occured. Therefore, I recommend you\n * to encode binary data of Protocol Buffer from type safe encode functions like below.\n * Use {@link encode} function only when you can ensure it.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * Also, `typia` is providing type safe decoders like {@link assertDecode}, but it\n * is just for additional type validation like `number & Minimum<7>` or\n * `string & Format<\"uuid\">` cases, that are represented by\n * [custom tags](https://typia.io/docs/validators/tags). Thus, I repeat that,\n * you've to ensure the type safety when using decoder functions.\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction decode<T>(input: Uint8Array): Resolved<T>;\n\n/**\n * @internal\n */\nfunction decode(): never {\n  halt(\"decode\");\n}\nconst decodePure = /** @__PURE__ */ Object.assign<typeof decode, {}>(\n  decode,\n  /** @__PURE__ */ Namespace.protobuf.decode(\"decode\"),\n);\nexport { decodePure as decode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type assertion, but not safe.\n *\n * `typia.protobuf.assertDecode()` is a combination function of {@link decode} and\n * {@link assert} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type assertion process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it throws\n * {@link TypeGuardError} instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type assertion like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.assertDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertDecode(\n  input: Uint8Array,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Protocol Buffer Decoder wity type assertion, but not safe.\n *\n * `typia.protobuf.assertDecode()` is a combination function of {@link decode} and\n * {@link assert} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type assertion process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it throws\n * {@link TypeGuardError} instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type assertion like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.assertDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertDecode<T>(\n  input: Uint8Array,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Resolved<T>;\n\n/**\n * @internal\n */\nfunction assertDecode(): never {\n  halt(\"assertDecode\");\n}\n\nconst assertDecodePure = /** @__PURE__ */ Object.assign<\n  typeof assertDecode,\n  {},\n  {}\n>(\n  assertDecode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.assertDecode\"),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"assertDecode\"),\n);\nexport { assertDecodePure as assertDecode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type checking, but not safe.\n *\n * `typia.protobuf.isDecode()` is a combination function of {@link decode} and\n * {@link is} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type checking process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it returns\n * `null` value instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type checking like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.isDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isDecode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder wity type checking, but not safe.\n *\n * `typia.protobuf.isDecode()` is a combination function of {@link decode} and\n * {@link is} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type checking process. If decoded value is\n * following the type `T`, it returns the decoded value. Otherwise, it returns\n * `null` value instead.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type checking like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.isDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isDecode<T>(input: Uint8Array): Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction isDecode(): never {\n  halt(\"isDecode\");\n}\nconst isDecodePure = /** @__PURE__ */ Object.assign<typeof isDecode, {}, {}>(\n  isDecode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"isDecode\"),\n);\nexport { isDecodePure as isDecode };\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Protocol Buffer Decoder wity type validation, but not safe.\n *\n * `typia.protobuf.validateDecode()` is a combination function of {@link decode} and\n * {@link validate} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type validation process. If decoded value is\n * following the type `T`, it returns the decoded value with\n * {@link IValidation.ISuccess} typed instance. Otherwise, it returns\n * {@link IValidation.IFailure} value instead with detailed error reasons.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type validation like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.validateDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateDecode(input: Uint8Array): never;\n\n/**\n * Protocol Buffer Decoder wity type validation, but not safe.\n *\n * `typia.protobuf.validateDecode()` is a combination function of {@link decode} and\n * {@link validate} function. Therefore, it decodes a binary data of Protocol Buffer to\n * a TypeScript instance, and performs type validation process. If decoded value is\n * following the type `T`, it returns the decoded value with\n * {@link IValidation.ISuccess} typed instance. Otherwise, it returns\n * {@link IValidation.IFailure} value instead with detailed error reasons.\n *\n * However, note that, this validation is not always safe. It just performs additional\n * type validation like `number & Minimum<7>` or `string & Format<\"uuid\">` cases,\n * that are represented by [custom tags](https://typia.io/docs/validators/tags).\n * Therefore, when using `typia.protobuf.validateDecode<T>()` function, you have to\n * ensure the type safety by yourself.\n *\n * In such type safety reason, I recommend you to use type safe encode functions.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * @template T Expected type of decoded value\n * @param input Protobuf Buffer binary data\n * @returns Decoded value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateDecode<T>(input: Uint8Array): IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction validateDecode(): never {\n  halt(\"validateDecode\");\n}\nconst validateDecodePure = /** @__PURE__ */ Object.assign<\n  typeof validateDecode,\n  {},\n  {}\n>(\n  validateDecode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"validateDecode\"),\n);\nexport { validateDecodePure as validateDecode };\n\n/* -----------------------------------------------------------\n    ENCODE\n----------------------------------------------------------- */\n/**\n * Protocol Buffer Encoder.\n *\n * Converts an input value to a binary data of Protocol Buffer format.\n *\n * For reference, this `typia.protobuf.encode()` does not validate the `input` value.\n * It just believes that the `input` value is valid and converts it to a binary data\n * directly. Therefore, if you can't ensure the `input` value type, it would better to\n * call one of below functions intead.\n *\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction encode<T>(input: T): Uint8Array;\n\n/**\n * @internal\n */\nfunction encode(): never {\n  halt(\"encode\");\n}\nconst encodePure = /** @__PURE__ */ Object.assign<typeof encode, {}>(\n  encode,\n  /** @__PURE__ */ Namespace.protobuf.encode(\"encode\"),\n);\nexport { encodePure as encode };\n\n/**\n * Protocol Buffer Encoder with type assertion.\n *\n * `typia.protobuf.assertEncode()` is a combination function of {@link assert} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type assertion. If `input` value is not valid, it throws\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value,\n * Protocol Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEncode<T>(\n  input: T,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Uint8Array;\n\n/**\n * Protocol Buffer Encoder with type assertion.\n *\n * `typia.protobuf.assertEncode()` is a combination function of {@link assert} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type assertion. If `input` value is not valid, it throws\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value,\n * Protocol Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link isEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction assertEncode<T>(\n  input: unknown,\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): Uint8Array;\n\n/**\n * @internal\n */\nfunction assertEncode(): never {\n  halt(\"assertEncode\");\n}\nconst assertEncodePure = /** @__PURE__ */ Object.assign<\n  typeof assertEncode,\n  {},\n  {}\n>(\n  assertEncode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.assertEncode\"),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"assertEncode\"),\n);\nexport { assertEncodePure as assertEncode };\n\n/**\n * Protocol Buffer Encoder with type checking.\n *\n * `typia.protobuf.isEncode()` is a combination function of {@link is} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type checking. If `input` value is not valid, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, Protocol\n * Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isEncode<T>(input: T): Uint8Array | null;\n\n/**\n * Protocol Buffer Encoder with type checking.\n *\n * `typia.protobuf.isEncode()` is a combination function of {@link is} and\n * {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type checking. If `input` value is not valid, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, Protocol\n * Buffer binary data would be returned.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link validateEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction isEncode<T>(input: unknown): Uint8Array | null;\n\n/**\n * @internal\n */\nfunction isEncode(): never {\n  halt(\"isEncode\");\n}\nconst isEncodePure = /** @__PURE__ */ Object.assign<typeof isEncode, {}, {}>(\n  isEncode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"isEncode\"),\n);\nexport { isEncodePure as isEncode };\n\n/**\n * Protocol Buffer Encoder with type validation.\n *\n * `typia.protobuf.validateEncode()` is a combination function of\n * {@link validation} and {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type validation. If `input` value is not valid, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, Protocol Buffer binary data would be stored in\n * `data` property of the output {@link IValidation.ISuccess} instance.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEncode<T>(input: T): IValidation<Uint8Array>;\n\n/**\n * Protocol Buffer Encoder with type validation.\n *\n * `typia.protobuf.validateEncode()` is a combination function of\n * {@link validation} and {@link encode}.\n *\n * Therefore, it converts an `input` value to a binary data of\n * Protocol Buffer, with type validation. If `input` value is not valid, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, Protocol Buffer binary data would be stored in\n * `data` property of the output {@link IValidation.ISuccess} instance.\n *\n * If you can trust `input` value, or want to perform other type of validation, use\n * below functions intead.\n *\n *  - {@link encode}\n *  - {@link assertEncode}\n *  - {@link isEncode}\n *\n * By the way, you know what? Expression power of Protocol Buffer is not enough strong\n * to fully meet the TypeScript type specs. In such reason, if you put a TypeScript\n * type that is not compatible with Protocol Buffer, this function would throw\n * compilation errors.\n *\n *  - [Restrictions of Protocol Buffer](https://typia.io/docs/protobuf/message/#restrictions)\n *\n * @template T Type of the value input\n * @param input A value to encode\n * @returns Encoded binary data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction validateEncode<T>(input: unknown): IValidation<Uint8Array>;\n\n/**\n * @internal\n */\nfunction validateEncode(): never {\n  halt(\"validateEncode\");\n}\nconst validateEncodePure = /** @__PURE__ */ Object.assign<\n  typeof validateEncode,\n  {},\n  {}\n>(\n  validateEncode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"validateEncode\"),\n);\nexport { validateEncodePure as validateEncode };\n\n/* -----------------------------------------------------------\n    FACTORY FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link decode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createDecode(): never;\n\n/**\n * Creates a reusable {@link decode} function.\n *\n * @template T Target type\n * @returns A reusable `decode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createDecode<T>(): (input: Uint8Array) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createDecode<T>(): (input: Uint8Array) => Resolved<T> {\n  halt(\"createDecode\");\n}\nconst createDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createDecode,\n  {}\n>(createDecode, /** @__PURE__ */ Namespace.protobuf.decode(\"createDecode\"));\nexport { createDecodePure as createDecode };\n\n/**\n * Creates a reusable {@link isDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsDecode(): never;\n\n/**\n * Creates a reusable {@link isDecode} function.\n *\n * @template T Target type\n * @returns A reusable `isDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsDecode<T>(): (input: Uint8Array) => Resolved<T> | null;\n\n/**\n * @internal\n */\nfunction createIsDecode<T>(): (input: Uint8Array) => Resolved<T> | null {\n  halt(\"createIsDecode\");\n}\nconst createIsDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createIsDecode,\n  {},\n  {}\n>(\n  createIsDecode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createIsDecode\"),\n);\nexport { createIsDecodePure as createIsDecode };\n\n/**\n * Creates a reusable {@link assertDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertDecode(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertDecode} function.\n *\n * @template T Target type\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertDecode<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: Uint8Array) => Resolved<T>;\n\n/**\n * @internal\n */\nfunction createAssertDecode<T>(): (input: Uint8Array) => Resolved<T> {\n  halt(\"createAssertDecode\");\n}\nconst createAssertDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertDecode,\n  {},\n  {}\n>(\n  createAssertDecode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.createAssertDecode\"),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createAssertDecode\"),\n);\nexport { createAssertDecodePure as createAssertDecode };\n\n/**\n * Creates a reusable {@link validateDecode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateDecode(): never;\n\n/**\n * Creates a reusable {@link validateDecode} function.\n *\n * @template T Target type\n * @returns A reusable `validateDecode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateDecode<T>(): (\n  input: Uint8Array,\n) => IValidation<Resolved<T>>;\n\n/**\n * @internal\n */\nfunction createValidateDecode<T>(): (\n  input: Uint8Array,\n) => IValidation<Resolved<T>> {\n  halt(\"createValidateDecode\");\n}\nconst createValidateDecodePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateDecode,\n  {},\n  {}\n>(\n  createValidateDecode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.decode(\"createValidateDecode\"),\n);\nexport { createValidateDecodePure as createValidateDecode };\n\n/**\n * Creates a reusable {@link encode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEncode(): never;\n\n/**\n * Creates a reusable {@link encode} function.\n *\n * @template T Target type\n * @returns A reusable `encode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createEncode<T>(): (input: T) => Uint8Array;\n\n/**\n * @internal\n */\nfunction createEncode<T>(): (input: T) => Uint8Array {\n  halt(\"createEncode\");\n}\nconst createEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createEncode,\n  {}\n>(createEncode, /** @__PURE__ */ Namespace.protobuf.encode(\"createEncode\"));\nexport { createEncodePure as createEncode };\n\n/**\n * Creates a reusable {@link isEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsEncode(): never;\n\n/**\n * Creates a reusable {@link isEncode} function.\n *\n * @template T Target type\n * @returns A reusable `isEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createIsEncode<T>(): (input: T) => Uint8Array | null;\n\n/**\n * @internal\n */\nfunction createIsEncode<T>(): (input: T) => Uint8Array | null {\n  halt(\"createIsEncode\");\n}\nconst createIsEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createIsEncode,\n  {},\n  {}\n>(\n  createIsEncode,\n  /** @__PURE__ */ Namespace.is(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createIsEncode\"),\n);\nexport { createIsEncodePure as createIsEncode };\n\n/**\n * Creates a reusable {@link assertEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEncode(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): never;\n\n/**\n * Creates a reusable {@link assertEncode} function.\n *\n * @template T Target type\n * @param errorFactory Custom error factory. Default is `TypeGuardError`\n * @returns A reusable `assertEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createAssertEncode<T>(\n  errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n): (input: T) => Uint8Array;\n\n/**\n * @internal\n */\nfunction createAssertEncode<T>(): (input: T) => Uint8Array {\n  halt(\"createAssertEncode\");\n}\nconst createAssertEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createAssertEncode,\n  {},\n  {}\n>(\n  createAssertEncode,\n  /** @__PURE__ */ Namespace.assert(\"protobuf.createAssertEncode\"),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createAssertEncode\"),\n);\nexport { createAssertEncodePure as createAssertEncode };\n\n/**\n * Creates a reusable {@link validateEncode} function.\n *\n * @danger You must configure the generic argument `T`\n * @returns Nothing until you configure the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEncode(): never;\n\n/**\n * Creates a reusable {@link validateEncode} function.\n *\n * @template T Target type\n * @returns A reusable `validateEncode` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nfunction createValidateEncode<T>(): (input: T) => IValidation<Uint8Array>;\n\n/**\n * @internal\n */\nfunction createValidateEncode<T>(): (input: T) => IValidation<Uint8Array> {\n  halt(\"createValidateEncode\");\n}\nconst createValidateEncodePure = /** @__PURE__ */ Object.assign<\n  typeof createValidateEncode,\n  {},\n  {}\n>(\n  createValidateEncode,\n  /** @__PURE__ */ Namespace.validate(),\n  /** @__PURE__ */ Namespace.protobuf.encode(\"createValidateEncode\"),\n);\nexport { createValidateEncodePure as createValidateEncode };\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n  throw new Error(\n    `Error on typia.protobuf.${name}(): no transform has been configured. Read and follow https://typia.io/docs/setup please.`,\n  );\n}\n"]}