{"version":3,"sources":["../src/programmers/http/HttpQueryProgrammer.ts"],"names":["ts","HttpQueryProgrammer","INPUT_TYPE","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","result","MetadataFactory","analyze","checker","context","escape","constant","absorb","validate","success","TransformerError","from","method","errors","object","data","objects","statements","decode_object","factory","createArrowFunction","undefined","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","createIdentifier","TypeFactory","getFullName","createBlock","declare","meta","explore","insert","msg","push","top","length","bucket","nullable","isRequired","nested","MetadataArrayType","atomics","HttpMetadataUtil","expected","templates","constants","map","c","values","reduce","a","b","size","property","tuples","isUnion","sets","maps","natives","input","output","createExpressionStatement","createBinaryExpression","createToken","SyntaxKind","EqualsToken","createAsExpression","createCallExpression","use","StatementFactory","createObjectLiteralExpression","properties","prop","decode_regular_property","createReturnStatement","keyword","key","value","isArray","arrays","elements","createPropertyAssignment","Escaper","variable","decode_array","access","decode_value","onlyUndefindable","call","QuestionQuestionToken","expression","createNull"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArrayType } from \"../../schemas/metadata/MetadataArrayType\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { Atomic } from \"../../typings/Atomic\";\n\nimport { Escaper } from \"../../utils/Escaper\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { HttpMetadataUtil } from \"../helpers/HttpMetadataUtil\";\n\nexport namespace HttpQueryProgrammer {\n  export const INPUT_TYPE = \"string | URLSearchParams\";\n\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      // GET OBJECT TYPE\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n        validate,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.http.${importer.method}`)(\n          result.errors,\n        );\n\n      // DO TRANSFORM\n      const object: MetadataObject = result.data.objects[0]!;\n      const statements: ts.Statement[] = decode_object(importer)(object);\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(INPUT_TYPE),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [...importer.declare(modulo), ...statements],\n          true,\n        ),\n      );\n    };\n\n  export const validate = (\n    meta: Metadata,\n    explore: MetadataFactory.IExplore,\n  ): string[] => {\n    const errors: string[] = [];\n    const insert = (msg: string) => errors.push(msg);\n\n    if (explore.top === true) {\n      // TOP MUST BE ONLY OBJECT\n      if (meta.objects.length !== 1 || meta.bucket() !== 1)\n        insert(\"only one object type is allowed.\");\n      if (meta.nullable === true) insert(\"query parameters cannot be null.\");\n      if (meta.isRequired() === false)\n        insert(\"query parameters cannot be undefined.\");\n    } else if (\n      explore.nested !== null &&\n      explore.nested instanceof MetadataArrayType\n    ) {\n      //----\n      // ARRAY\n      //----\n      const atomics = HttpMetadataUtil.atomics(meta);\n      const expected: number =\n        meta.atomics.length +\n        meta.templates.length +\n        meta.constants.map((c) => c.values.length).reduce((a, b) => a + b, 0);\n      if (atomics.size > 1) insert(\"union type is not allowed in array.\");\n      if (meta.size() !== expected)\n        insert(\"only atomic or constant types are allowed in array.\");\n    } else if (explore.object && explore.property !== null) {\n      //----\n      // COMMON\n      //----\n      // PROPERTY MUST BE SOLE\n      if (typeof explore.property === \"object\")\n        insert(\"dynamic property is not allowed.\");\n      // DO NOT ALLOW TUPLE TYPE\n      if (meta.tuples.length) insert(\"tuple type is not allowed.\");\n      // DO NOT ALLOW UNION TYPE\n      if (HttpMetadataUtil.isUnion(meta)) insert(\"union type is not allowed.\");\n      // DO NOT ALLOW NESTED OBJECT\n      if (\n        meta.objects.length ||\n        meta.sets.length ||\n        meta.maps.length ||\n        meta.natives.length\n      )\n        insert(\"nested object type is not allowed.\");\n    }\n    return errors;\n  };\n\n  const decode_object =\n    (importer: FunctionImporter) =>\n    (object: MetadataObject): ts.Statement[] => {\n      const input: ts.Identifier = ts.factory.createIdentifier(\"input\");\n      const output: ts.Identifier = ts.factory.createIdentifier(\"output\");\n\n      return [\n        ts.factory.createExpressionStatement(\n          ts.factory.createBinaryExpression(\n            input,\n            ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n            ts.factory.createAsExpression(\n              ts.factory.createCallExpression(\n                importer.use(\"params\"),\n                undefined,\n                [input],\n              ),\n              ts.factory.createTypeReferenceNode(\"URLSearchParams\"),\n            ),\n          ),\n        ),\n        StatementFactory.constant(\n          \"output\",\n          ts.factory.createObjectLiteralExpression(\n            object.properties.map((prop) =>\n              decode_regular_property(importer)(prop),\n            ),\n            true,\n          ),\n        ),\n        ts.factory.createReturnStatement(\n          ts.factory.createAsExpression(output, TypeFactory.keyword(\"any\")),\n        ),\n      ];\n    };\n\n  const decode_regular_property =\n    (importer: FunctionImporter) =>\n    (property: MetadataProperty): ts.PropertyAssignment => {\n      const key: string = property.key.constants[0]!.values[0]!.value as string;\n      const value: Metadata = property.value;\n\n      const [type, isArray]: [Atomic.Literal, boolean] = value.atomics.length\n        ? [value.atomics[0]!.type, false]\n        : value.constants.length\n          ? [value.constants[0]!.type, false]\n          : value.templates.length\n            ? [\"string\", false]\n            : (() => {\n                const meta =\n                  value.arrays[0]?.type.value ??\n                  value.tuples[0]!.type.elements[0]!;\n                return meta.atomics.length\n                  ? [meta.atomics[0]!.type, true]\n                  : meta.templates.length\n                    ? [\"string\", true]\n                    : [meta.constants[0]!.type, true];\n              })();\n      return ts.factory.createPropertyAssignment(\n        Escaper.variable(key) ? key : ts.factory.createStringLiteral(key),\n        isArray\n          ? decode_array(importer)(value)(\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(\n                  ts.factory.createCallExpression(\n                    ts.factory.createIdentifier(\"input.getAll\"),\n                    undefined,\n                    [ts.factory.createStringLiteral(key)],\n                  ),\n                )(\"map\"),\n                undefined,\n                [\n                  ts.factory.createArrowFunction(\n                    undefined,\n                    undefined,\n                    [IdentifierFactory.parameter(\"elem\")],\n                    undefined,\n                    undefined,\n                    decode_value(importer)(type)(false)(\n                      ts.factory.createIdentifier(\"elem\"),\n                    ),\n                  ),\n                ],\n              ),\n            )\n          : decode_value(importer)(type)(\n              value.nullable === false && value.isRequired() === false,\n            )(\n              ts.factory.createCallExpression(\n                ts.factory.createIdentifier(\"input.get\"),\n                undefined,\n                [ts.factory.createStringLiteral(key)],\n              ),\n            ),\n      );\n    };\n\n  const decode_value =\n    (importer: FunctionImporter) =>\n    (type: Atomic.Literal) =>\n    (onlyUndefindable: boolean) =>\n    (value: ts.Expression) => {\n      const call = ts.factory.createCallExpression(\n        importer.use(type),\n        undefined,\n        [value],\n      );\n      return onlyUndefindable\n        ? ts.factory.createBinaryExpression(\n            call,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n            ts.factory.createIdentifier(\"undefined\"),\n          )\n        : call;\n    };\n\n  const decode_array =\n    (importer: FunctionImporter) =>\n    (value: Metadata) =>\n    (expression: ts.Expression): ts.Expression =>\n      value.nullable || value.isRequired() === false\n        ? ts.factory.createCallExpression(importer.use(\"array\"), undefined, [\n            expression,\n            value.nullable\n              ? ts.factory.createNull()\n              : ts.factory.createIdentifier(\"undefined\"),\n          ])\n        : expression;\n}\n"]}