{"version":3,"sources":["../src/programmers/TypiaProgrammer.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport ts from \"typescript\";\n\nimport { ImportTransformer } from \"../transformers/ImportTransformer\";\n\nimport transform from \"../transform\";\n\nexport namespace TypiaProgrammer {\n  export interface IProps {\n    input: string;\n    output: string;\n    project: string;\n  }\n\n  export const build = async (props: TypiaProgrammer.IProps): Promise<void> => {\n    props.input = path.resolve(props.input);\n    props.output = path.resolve(props.output);\n\n    if ((await is_directory(props.input)) === false)\n      throw new URIError(\n        \"Error on TypiaGenerator.generate(): input path is not a directory.\",\n      );\n    else if (fs.existsSync(props.output) === false)\n      await fs.promises.mkdir(props.output, { recursive: true });\n    else if ((await is_directory(props.output)) === false) {\n      const parent: string = path.join(props.output, \"..\");\n      if ((await is_directory(parent)) === false)\n        throw new URIError(\n          \"Error on TypiaGenerator.generate(): output path is not a directory.\",\n        );\n      await fs.promises.mkdir(props.output);\n    }\n\n    // CREATE PROGRAM\n    const { options: compilerOptions } = ts.parseJsonConfigFileContent(\n      ts.readConfigFile(props.project, ts.sys.readFile).config,\n      {\n        fileExists: ts.sys.fileExists,\n        readFile: ts.sys.readFile,\n        readDirectory: ts.sys.readDirectory,\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      path.dirname(props.project),\n    );\n\n    const program: ts.Program = ts.createProgram(\n      await (async () => {\n        const container: string[] = [];\n        await gather(props)(container)(props.input)(props.output);\n        return container;\n      })(),\n      compilerOptions,\n    );\n\n    // DO TRANSFORM\n    const diagnostics: ts.Diagnostic[] = [];\n    const result: ts.TransformationResult<ts.SourceFile> = ts.transform(\n      program\n        .getSourceFiles()\n        .filter(\n          (file) =>\n            !file.isDeclarationFile &&\n            path.resolve(file.fileName).indexOf(props.input) !== -1,\n        ),\n      [\n        ImportTransformer.transform(props.input)(props.output),\n        transform(\n          program,\n          ((compilerOptions.plugins as any[]) ?? []).find(\n            (p: any) =>\n              p.transform === \"typia/lib/transform\" ||\n              p.transform === \"../src/transform.ts\",\n          ) ?? {},\n          {\n            addDiagnostic: (diag) => diagnostics.push(diag),\n          },\n        ),\n      ],\n      program.getCompilerOptions(),\n    );\n\n    // TRACE ERRORS\n    for (const diag of diagnostics) {\n      const file: string = diag.file\n        ? path.relative(diag.file.fileName, process.cwd())\n        : \"(unknown file)\";\n      const category: string =\n        diag.category === ts.DiagnosticCategory.Warning\n          ? \"warning\"\n          : diag.category === ts.DiagnosticCategory.Error\n            ? \"error\"\n            : diag.category === ts.DiagnosticCategory.Suggestion\n              ? \"suggestion\"\n              : diag.category === ts.DiagnosticCategory.Message\n                ? \"message\"\n                : \"unkown\";\n      const [line, pos] = diag.file\n        ? (() => {\n            const lines: string[] = diag\n              .file!.text.substring(0, diag.start)\n              .split(\"\\n\");\n            if (lines.length === 0) return [0, 0];\n            return [lines.length, lines.at(-1)!.length + 1];\n          })()\n        : [0, 0];\n      console.error(\n        `${file}:${line}:${pos} - ${category} TS${diag.code}: ${diag.messageText}`,\n      );\n    }\n    if (diagnostics.length) process.exit(-1);\n\n    // ARCHIVE TRANSFORMED FILES\n    const printer: ts.Printer = ts.createPrinter({\n      newLine: ts.NewLineKind.LineFeed,\n    });\n    for (const file of result.transformed) {\n      const to: string = path\n        .resolve(file.fileName)\n        .replace(props.input, props.output);\n\n      const content: string = printer.printFile(file);\n      await fs.promises.writeFile(to, content, \"utf8\");\n    }\n  };\n\n  const is_directory = async (current: string): Promise<boolean> => {\n    const stat: fs.Stats = await fs.promises.stat(current);\n    return stat.isDirectory();\n  };\n\n  const gather =\n    (props: IProps) =>\n    (container: string[]) =>\n    (from: string) =>\n    async (to: string) => {\n      if (from === props.output) return;\n      else if (fs.existsSync(to) === false) await fs.promises.mkdir(to);\n\n      for (const file of await fs.promises.readdir(from)) {\n        const next: string = path.join(from, file);\n        const stat: fs.Stats = await fs.promises.stat(next);\n\n        if (stat.isDirectory()) {\n          await gather(props)(container)(next)(path.join(to, file));\n          continue;\n        } else if (is_supported_extension(file)) container.push(next);\n      }\n    };\n\n  const is_supported_extension = (filename: string): boolean => {\n    return (\n      (filename.endsWith(\".ts\") && !filename.endsWith(\".d.ts\")) ||\n      (filename.endsWith(\".tsx\") && !filename.endsWith(\".d.tsx\"))\n    );\n  };\n}\n"],"mappings":"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","names":["fs","path","ts","TypiaProgrammer","build","props","input","path","resolve","output","is_directory","URIError","fs","existsSync","promises","mkdir","recursive","parent","join","options","compilerOptions","ts","parseJsonConfigFileContent","readConfigFile","project","sys","readFile","config","fileExists","readDirectory","useCaseSensitiveFileNames","dirname","program","createProgram","container","gather","diagnostics","result","transform","getSourceFiles","filter","file","isDeclarationFile","fileName","indexOf","ImportTransformer","plugins","find","p","addDiagnostic","diag","push","getCompilerOptions","relative","process","cwd","category","DiagnosticCategory","Warning","Error","Suggestion","Message","line","pos","lines","text","substring","start","split","length","at","console","error","code","messageText","exit","printer","createPrinter","newLine","NewLineKind","LineFeed","transformed","to","replace","content","printFile","writeFile","current","stat","isDirectory","from","readdir","next","is_supported_extension","filename","endsWith"]}