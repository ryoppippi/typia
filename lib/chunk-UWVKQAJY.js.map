{"version":3,"sources":["../src/transformers/features/functional/FunctionalGenericTransformer.ts"],"names":["FunctionalGenericTransformer","transform","props","project","modulo","expression","arguments","length","TransformerError","code","method","message","type","typeArguments","checker","getTypeFromTypeNode","getTypeAtLocation","TypeFactory","isFunction","programmer","equals","symbol","declarations"],"mappings":";;;;;;;;;UAOiBA,+BAAAA;gCACFC,YACX,CAACC,UAeD,CAACC,YACD,CAACC,WACD,CAACC,eAAAA;AAEC,QAAIA,WAAWC,UAAUC,WAAW,EAClC,OAAM,IAAIC,iBAAiB;MACzBC,MAAM,oBAAoBP,MAAMQ,MAAM;MACtCC,SAAS;IACX,CAAA;AAGF,UAAMC,OACJP,WAAWQ,iBAAiBR,WAAWQ,cAAc,CAAA,IACjDV,QAAQW,QAAQC,oBAAoBV,WAAWQ,cAAc,CAAA,CAAE,IAC/DV,QAAQW,QAAQE,kBAAkBX,WAAWC,UAAU,CAAA,CAAE;AAO/D,QAAIW,YAAYC,WAAWN,IAAAA,MAAU,MACnC,OAAM,IAAIJ,iBAAiB;MACzBC,MAAM,oBAAoBP,MAAMQ,MAAM;MACtCC,SAAS;IACX,CAAA;AACF,WAAOT,MAAMiB,WAAWhB,OAAAA,EAASC,MAAAA,EAAQF,MAAMkB,MAAM,EACnDf,WAAWC,UAAU,CAAA,GACrBM,KAAKS,OAAQC,aAAc,CAAA,GAC3BjB,WAAWC,UAAU,CAAA,CAAE;EAE3B;AACJ,GAjDiBN,iCAAAA,+BAAAA,CAAAA,EAAAA","sourcesContent":["import ts from \"typescript\";\n\nimport { TypeFactory } from \"../../../factories/TypeFactory\";\n\nimport { IProject } from \"../../IProject\";\nimport { TransformerError } from \"../../TransformerError\";\n\nexport namespace FunctionalGenericTransformer {\n  export const transform =\n    (props: {\n      method: string;\n      programmer: (\n        project: IProject,\n      ) => (\n        modulo: ts.LeftHandSideExpression,\n      ) => (\n        equals: boolean,\n      ) => (\n        expression: ts.Expression,\n        declaration: ts.FunctionDeclaration,\n        init?: ts.Expression,\n      ) => ts.Expression;\n      equals: boolean;\n    }) =>\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (expression: ts.CallExpression) => {\n      // CHECK PARAMETER\n      if (expression.arguments.length === 0)\n        throw new TransformerError({\n          code: `typia.functional.${props.method}`,\n          message: `no input value.`,\n        });\n\n      // GET TYPE INFO\n      const type: ts.Type =\n        expression.typeArguments && expression.typeArguments[0]\n          ? project.checker.getTypeFromTypeNode(expression.typeArguments[0])\n          : project.checker.getTypeAtLocation(expression.arguments[0]!);\n      // if (type. === true)\n      //   throw new TransformerError({\n      //     code: `typia.functional.${props.method}`,\n      //     message: `non-specified generic argument.`,\n      //   });\n      // else\n      if (TypeFactory.isFunction(type) === false)\n        throw new TransformerError({\n          code: `typia.functional.${props.method}`,\n          message: `input value is not a function.`,\n        });\n      return props.programmer(project)(modulo)(props.equals)(\n        expression.arguments[0]!,\n        type.symbol!.declarations![0] as ts.FunctionDeclaration,\n        expression.arguments[1],\n      );\n    };\n}\n"]}