{"version":3,"sources":["../src/programmers/protobuf/ProtobufDecodeProgrammer.ts"],"names":["ts","ProtobufDecodeProgrammer","write","project","modulo","type","name","importer","FunctionImporter","getText","collection","MetadataCollection","meta","ProtobufFactory","metadata","checker","context","functors","objects","filter","obj","ProtobufUtil","isStaticObject","map","StatementFactory","constant","PREFIX","index","write_object_function","reader","factory","createNewExpression","use","undefined","createIdentifier","createArrowFunction","IdentifierFactory","parameter","createTypeReferenceNode","createImportTypeNode","createLiteralTypeNode","createStringLiteral","TypeFactory","getFullName","createBlock","declare","createReturnStatement","decode_regular_object","keyword","ExpressionFactory","number","createExpressionStatement","createBinaryExpression","createToken","SyntaxKind","EqualsToken","createConditionalExpression","createLessThan","createCallExpression","access","READER","createAdd","write_object_function_body","condition","tag","output","properties","props","i","clauses","p","clause","decode_property","key","getSoleLiteral","value","size","flat","createAsExpression","createObjectLiteralExpression","compilerOptions","exactOptionalPropertyTypes","optional","createPropertyAssignment","identifier","write_property_default_value","createWhileStatement","createSwitchStatement","createUnsignedRightShift","createCaseBlock","createDefaultClause","createBitwiseAnd","createBreakStatement","nullable","createNull","isRequired","arrays","length","createArrayLiteralExpression","maps","natives","atomics","some","a","constants","c","values","v","templates","tpl","getName","accessor","emplace","push","createCaseClause","Array","isArray","required","atomic","getAtomics","decode_atomic","decode_bytes","array","decode_array","decode_map","decode_dynamic_object","call","isNumber","getNumbers","n","method","statements","QuestionQuestionEqualsToken","decoder","Error","createIfStatement","createStrictEquality","stmt","isExpression","top","decode_entry","initializer","setter","createElementAccessExpression","MetadataProperty","create","Metadata","initialize","MetadataAtomic","tags","MetadataFactory","soleLiteral","description","jsDocTags","selfCall"],"mappings":"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","sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { ProtobufFactory } from \"../../factories/ProtobufFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\nimport { MetadataObject } from \"../../schemas/metadata/MetadataObject\";\nimport { MetadataProperty } from \"../../schemas/metadata/MetadataProperty\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ProtobufAtomic } from \"../../typings/ProtobufAtomic\";\n\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { ProtobufUtil } from \"../helpers/ProtobufUtil\";\n\nexport namespace ProtobufDecodeProgrammer {\n  export const write =\n    (project: IProject) =>\n    (modulo: ts.LeftHandSideExpression) =>\n    (type: ts.Type, name?: string): ts.ArrowFunction => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      const collection: MetadataCollection = new MetadataCollection();\n      const meta: Metadata = ProtobufFactory.metadata(modulo.getText())(\n        project.checker,\n        project.context,\n      )(collection)(type);\n\n      const functors = collection\n        .objects()\n        .filter((obj) => ProtobufUtil.isStaticObject(obj))\n        .map((obj) =>\n          StatementFactory.constant(\n            `${PREFIX}o${obj.index}`,\n            write_object_function(project)(importer)(obj),\n          ),\n        );\n      const reader = StatementFactory.constant(\n        \"reader\",\n        ts.factory.createNewExpression(importer.use(\"Reader\"), undefined, [\n          ts.factory.createIdentifier(\"input\"),\n        ]),\n      );\n\n      return ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\n            \"input\",\n            ts.factory.createTypeReferenceNode(\"Uint8Array\"),\n          ),\n        ],\n        ts.factory.createImportTypeNode(\n          ts.factory.createLiteralTypeNode(\n            ts.factory.createStringLiteral(\"typia\"),\n          ),\n          undefined,\n          ts.factory.createIdentifier(\"Resolved\"),\n          [\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          ],\n          false,\n        ),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ...importer.declare(modulo),\n            ...functors,\n            reader,\n            ts.factory.createReturnStatement(\n              decode_regular_object(true)(meta.objects[0]!),\n            ),\n          ],\n          true,\n        ),\n      );\n    };\n\n  const write_object_function =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (obj: MetadataObject): ts.ArrowFunction =>\n      ts.factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          IdentifierFactory.parameter(\"reader\"),\n          IdentifierFactory.parameter(\n            \"length\",\n            TypeFactory.keyword(\"number\"),\n            ExpressionFactory.number(-1),\n          ),\n        ],\n        TypeFactory.keyword(\"any\"),\n        undefined,\n        ts.factory.createBlock(\n          [\n            ts.factory.createExpressionStatement(\n              ts.factory.createBinaryExpression(\n                ts.factory.createIdentifier(\"length\"),\n                ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                ts.factory.createConditionalExpression(\n                  ts.factory.createLessThan(\n                    ts.factory.createIdentifier(\"length\"),\n                    ExpressionFactory.number(0),\n                  ),\n                  undefined,\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"size\"),\n                    undefined,\n                    undefined,\n                  ),\n                  undefined,\n                  ts.factory.createAdd(\n                    ts.factory.createCallExpression(\n                      IdentifierFactory.access(READER())(\"index\"),\n                      undefined,\n                      undefined,\n                    ),\n                    ts.factory.createIdentifier(\"length\"),\n                  ),\n                ),\n              ),\n            ),\n            ...write_object_function_body(project)(importer)({\n              condition: ts.factory.createLessThan(\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(READER())(\"index\"),\n                  undefined,\n                  undefined,\n                ),\n                ts.factory.createIdentifier(\"length\"),\n              ),\n              tag: \"tag\",\n              output: \"output\",\n            })(obj.properties),\n            ts.factory.createReturnStatement(\n              ts.factory.createIdentifier(\"output\"),\n            ),\n          ],\n          true,\n        ),\n      );\n\n  const write_object_function_body =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (props: { condition: ts.Expression; tag: string; output: string }) =>\n    (properties: MetadataProperty[]): ts.Statement[] => {\n      let i: number = 1;\n      const clauses: ts.CaseClause[] = properties\n        .map((p) => {\n          const clause = decode_property(project)(importer)(i)(\n            IdentifierFactory.access(ts.factory.createIdentifier(props.output))(\n              p.key.getSoleLiteral()!,\n            ),\n            p.value,\n          );\n          i += ProtobufUtil.size(p.value);\n          return clause;\n        })\n        .flat();\n      return [\n        StatementFactory.constant(\n          props.output,\n          ts.factory.createAsExpression(\n            ts.factory.createObjectLiteralExpression(\n              properties\n                .filter(\n                  (p) =>\n                    !(\n                      project.compilerOptions.exactOptionalPropertyTypes ===\n                        true && p.value.optional === true\n                    ),\n                )\n                .map((p) =>\n                  ts.factory.createPropertyAssignment(\n                    IdentifierFactory.identifier(p.key.getSoleLiteral()!),\n                    write_property_default_value(p.value),\n                  ),\n                ),\n              true,\n            ),\n            TypeFactory.keyword(\"any\"),\n          ),\n        ),\n        ts.factory.createWhileStatement(\n          props.condition,\n          ts.factory.createBlock([\n            StatementFactory.constant(\n              props.tag,\n              ts.factory.createCallExpression(\n                IdentifierFactory.access(READER())(\"uint32\"),\n                undefined,\n                undefined,\n              ),\n            ),\n            ts.factory.createSwitchStatement(\n              ts.factory.createUnsignedRightShift(\n                ts.factory.createIdentifier(props.tag),\n                ExpressionFactory.number(3),\n              ),\n              ts.factory.createCaseBlock([\n                ...clauses,\n                ts.factory.createDefaultClause([\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createCallExpression(\n                      IdentifierFactory.access(READER())(\"skipType\"),\n                      undefined,\n                      [\n                        ts.factory.createBitwiseAnd(\n                          ts.factory.createIdentifier(props.tag),\n                          ExpressionFactory.number(7),\n                        ),\n                      ],\n                    ),\n                  ),\n                  ts.factory.createBreakStatement(),\n                ]),\n              ]),\n            ),\n          ]),\n        ),\n      ];\n    };\n\n  const write_property_default_value = (value: Metadata) =>\n    ts.factory.createAsExpression(\n      value.nullable\n        ? ts.factory.createNull()\n        : value.isRequired() === false\n          ? ts.factory.createIdentifier(\"undefined\")\n          : value.arrays.length\n            ? ts.factory.createArrayLiteralExpression()\n            : value.maps.length\n              ? ts.factory.createNewExpression(\n                  ts.factory.createIdentifier(\"Map\"),\n                  undefined,\n                  [],\n                )\n              : value.natives.length\n                ? ts.factory.createNewExpression(\n                    ts.factory.createIdentifier(\"Uint8Array\"),\n                    undefined,\n                    [],\n                  )\n                : value.atomics.some((a) => a.type === \"string\") ||\n                    value.constants.some(\n                      (c) =>\n                        c.type === \"string\" &&\n                        c.values.some((v) => v.value === \"\"),\n                    ) ||\n                    value.templates.some(\n                      (tpl) =>\n                        tpl.length === 1 && tpl[0]!.getName() === \"string\",\n                    )\n                  ? ts.factory.createStringLiteral(\"\")\n                  : value.objects.length &&\n                      value.objects.some(\n                        (obj) => !ProtobufUtil.isStaticObject(obj),\n                      )\n                    ? ts.factory.createObjectLiteralExpression()\n                    : ts.factory.createIdentifier(\"undefined\"),\n      TypeFactory.keyword(\"any\"),\n    );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode_property =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (index: number) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      meta: Metadata,\n    ): ts.CaseClause[] => {\n      const clauses: ts.CaseClause[] = [];\n      const emplace = (name: string) => (v: ts.Expression | ts.Statement[]) =>\n        clauses.push(\n          ts.factory.createCaseClause(\n            ExpressionFactory.number(index++),\n            Array.isArray(v)\n              ? [\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createIdentifier(`// type: ${name}`),\n                  ),\n                  ...v,\n                  ts.factory.createBreakStatement(),\n                ]\n              : [\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createIdentifier(`// ${name}`),\n                  ),\n                  ts.factory.createExpressionStatement(\n                    ts.factory.createBinaryExpression(\n                      accessor,\n                      ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n                      v,\n                    ),\n                  ),\n                  ts.factory.createBreakStatement(),\n                ],\n          ),\n        );\n\n      const required: boolean = meta.isRequired() && !meta.nullable;\n      for (const atomic of ProtobufUtil.getAtomics(meta))\n        emplace(atomic)(decode_atomic(meta)(atomic));\n      if (meta.natives.length) emplace(\"bytes\")(decode_bytes(\"bytes\"));\n      for (const array of meta.arrays)\n        emplace(`Array<${array.type.value.getName()}>`)(\n          decode_array(accessor, array, required),\n        );\n      for (const map of meta.maps)\n        emplace(`Map<string, ${map.value.getName()}>`)(\n          decode_map(project)(importer)(accessor, map, required),\n        );\n      for (const obj of meta.objects)\n        emplace(obj.name)(\n          ProtobufUtil.isStaticObject(obj)\n            ? decode_regular_object(false)(obj)\n            : decode_dynamic_object(project)(importer)(accessor, obj, required),\n        );\n      return clauses;\n    };\n\n  const decode_atomic =\n    (meta: Metadata) =>\n    (atomic: ProtobufAtomic): ts.Expression => {\n      if (atomic === \"string\") return decode_bytes(\"string\");\n\n      const call: ts.CallExpression = ts.factory.createCallExpression(\n        IdentifierFactory.access(ts.factory.createIdentifier(\"reader\"))(atomic),\n        undefined,\n        undefined,\n      );\n      if (atomic !== \"int64\" && atomic !== \"uint64\") return call;\n\n      const isNumber: boolean = ProtobufUtil.getNumbers(meta).some(\n        (n) => n === atomic,\n      );\n      return isNumber\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"Number\"),\n            undefined,\n            [call],\n          )\n        : call;\n    };\n\n  const decode_bytes = (method: \"bytes\" | \"string\"): ts.Expression =>\n    ts.factory.createCallExpression(\n      IdentifierFactory.access(ts.factory.createIdentifier(\"reader\"))(method),\n      undefined,\n      undefined,\n    );\n\n  const decode_array = (\n    accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n    array: MetadataArray,\n    required: boolean,\n  ): ts.Statement[] => {\n    const statements: Array<ts.Expression | ts.Statement> = [];\n    if (required === false)\n      statements.push(\n        ts.factory.createBinaryExpression(\n          accessor,\n          ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n          ts.factory.createAsExpression(\n            ts.factory.createArrayLiteralExpression(),\n            ts.factory.createTypeReferenceNode(\"any[]\"),\n          ),\n        ),\n      );\n    const atomics = ProtobufUtil.getAtomics(array.type.value);\n    const decoder = atomics.length\n      ? () => decode_atomic(array.type.value)(atomics[0]!)\n      : array.type.value.natives.length\n        ? () => decode_bytes(\"bytes\")\n        : array.type.value.objects.length\n          ? () => decode_regular_object(false)(array.type.value.objects[0]!)\n          : null;\n    if (decoder === null) throw new Error(\"Never reach here.\");\n    else if (atomics.length && atomics[0] !== \"string\") {\n      statements.push(\n        ts.factory.createIfStatement(\n          ts.factory.createStrictEquality(\n            ExpressionFactory.number(2),\n            ts.factory.createBitwiseAnd(\n              ts.factory.createIdentifier(\"tag\"),\n              ExpressionFactory.number(7),\n            ),\n          ),\n          ts.factory.createBlock(\n            [\n              StatementFactory.constant(\n                \"piece\",\n                ts.factory.createAdd(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"uint32\"),\n                    undefined,\n                    undefined,\n                  ),\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"index\"),\n                    undefined,\n                    undefined,\n                  ),\n                ),\n              ),\n              ts.factory.createWhileStatement(\n                ts.factory.createLessThan(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(READER())(\"index\"),\n                    undefined,\n                    undefined,\n                  ),\n                  ts.factory.createIdentifier(\"piece\"),\n                ),\n                ts.factory.createExpressionStatement(\n                  ts.factory.createCallExpression(\n                    IdentifierFactory.access(accessor)(\"push\"),\n                    undefined,\n                    [decoder()],\n                  ),\n                ),\n              ),\n            ],\n            true,\n          ),\n          ts.factory.createExpressionStatement(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(accessor)(\"push\"),\n              undefined,\n              [decoder()],\n            ),\n          ),\n        ),\n      );\n    } else\n      statements.push(\n        ts.factory.createCallExpression(\n          IdentifierFactory.access(accessor)(\"push\"),\n          undefined,\n          [decoder()],\n        ),\n      );\n    return statements.map((stmt) =>\n      ts.isExpression(stmt) ? ts.factory.createExpressionStatement(stmt) : stmt,\n    );\n  };\n\n  const decode_regular_object =\n    (top: boolean) =>\n    (obj: MetadataObject): ts.Expression =>\n      ts.factory.createCallExpression(\n        ts.factory.createIdentifier(`${PREFIX}o${obj.index}`),\n        undefined,\n        [\n          ts.factory.createIdentifier(\"reader\"),\n          ...(top\n            ? []\n            : [\n                ts.factory.createCallExpression(\n                  IdentifierFactory.access(READER())(\"uint32\"),\n                  undefined,\n                  undefined,\n                ),\n              ]),\n        ],\n      );\n\n  const decode_dynamic_object =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      obj: MetadataObject,\n      required: boolean,\n    ): ts.Statement[] => {\n      const top = obj.properties[0]!;\n      return decode_entry(project)(importer)({\n        initializer: () =>\n          ts.factory.createBinaryExpression(\n            accessor,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n            ts.factory.createObjectLiteralExpression(),\n          ),\n        setter: () =>\n          ts.factory.createBinaryExpression(\n            ts.factory.createElementAccessExpression(\n              accessor,\n              ts.factory.createIdentifier(\"entry.key\"),\n            ),\n            ts.factory.createToken(ts.SyntaxKind.EqualsToken),\n            ts.factory.createIdentifier(\"entry.value\"),\n          ),\n      })(\n        MetadataProperty.create({\n          ...top,\n          key: (() => {\n            const key: Metadata = Metadata.initialize();\n            key.atomics.push(\n              MetadataAtomic.create({\n                type: \"string\",\n                tags: [],\n              }),\n            );\n            return key;\n          })(),\n        }),\n        required,\n      );\n    };\n\n  const decode_map =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (\n      accessor: ts.ElementAccessExpression | ts.PropertyAccessExpression,\n      map: Metadata.Entry,\n      required: boolean,\n    ): ts.Statement[] =>\n      decode_entry(project)(importer)({\n        initializer: () =>\n          ts.factory.createBinaryExpression(\n            accessor,\n            ts.factory.createToken(ts.SyntaxKind.QuestionQuestionEqualsToken),\n            ts.factory.createNewExpression(\n              ts.factory.createIdentifier(\"Map\"),\n              [TypeFactory.keyword(\"any\"), TypeFactory.keyword(\"any\")],\n              [],\n            ),\n          ),\n        setter: () =>\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(accessor)(\"set\"),\n            undefined,\n            [\n              ts.factory.createIdentifier(\"entry.key\"),\n              ts.factory.createIdentifier(\"entry.value\"),\n            ],\n          ),\n      })(map, required);\n\n  const decode_entry =\n    (project: IProject) =>\n    (importer: FunctionImporter) =>\n    (props: {\n      initializer: () => ts.Expression;\n      setter: () => ts.Expression;\n    }) =>\n    (map: Metadata.Entry, required: boolean): ts.Statement[] => {\n      const statements: ts.Statement[] = [\n        ...(required\n          ? []\n          : [ts.factory.createExpressionStatement(props.initializer())]),\n        StatementFactory.constant(\n          \"piece\",\n          ts.factory.createAdd(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"uint32\"),\n              undefined,\n              undefined,\n            ),\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"index\"),\n              undefined,\n              undefined,\n            ),\n          ),\n        ),\n        ...write_object_function_body(project)(importer)({\n          condition: ts.factory.createLessThan(\n            ts.factory.createCallExpression(\n              IdentifierFactory.access(READER())(\"index\"),\n              undefined,\n              undefined,\n            ),\n            ts.factory.createIdentifier(\"piece\"),\n          ),\n          tag: \"kind\",\n          output: \"entry\",\n        })([\n          MetadataProperty.create({\n            key: MetadataFactory.soleLiteral(\"key\"),\n            value: map.key,\n            description: null,\n            jsDocTags: [],\n          }),\n          MetadataProperty.create({\n            key: MetadataFactory.soleLiteral(\"value\"),\n            value: map.value,\n            description: null,\n            jsDocTags: [],\n          }),\n        ]),\n        ts.factory.createExpressionStatement(props.setter()),\n      ];\n      return [\n        ts.factory.createExpressionStatement(\n          ExpressionFactory.selfCall(ts.factory.createBlock(statements, true)),\n        ),\n      ];\n    };\n}\n\nconst PREFIX = \"$pd\";\nconst READER = () => ts.factory.createIdentifier(\"reader\");\n"]}