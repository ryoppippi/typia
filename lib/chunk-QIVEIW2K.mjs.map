{"version":3,"sources":["../src/programmers/internal/check_number.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\n\nimport { MetadataAtomic } from \"../../schemas/metadata/MetadataAtomic\";\n\nimport { IProject } from \"../../transformers/IProject\";\n\nimport { ICheckEntry } from \"../helpers/ICheckEntry\";\nimport { OptionPredicator } from \"../helpers/OptionPredicator\";\n\n/**\n * @internal\n */\nexport const check_number =\n  (project: IProject, numeric: boolean) =>\n  (atomic: MetadataAtomic) =>\n  (input: ts.Expression): ICheckEntry => {\n    const base = ts.factory.createStrictEquality(\n      ts.factory.createStringLiteral(\"number\"),\n      ts.factory.createTypeOfExpression(input),\n    );\n    const addition: ts.Expression | null =\n      numeric === true\n        ? OptionPredicator.finite(project.options)\n          ? ts.factory.createCallExpression(\n              ts.factory.createIdentifier(\"Number.isFinite\"),\n              undefined,\n              [input],\n            )\n          : OptionPredicator.numeric(project.options)\n            ? ts.factory.createLogicalNot(\n                ts.factory.createCallExpression(\n                  ts.factory.createIdentifier(\"Number.isNaN\"),\n                  undefined,\n                  [input],\n                ),\n              )\n            : null\n        : null;\n\n    const conditions: ICheckEntry.ICondition[][] =\n      check_numeric_type_tags(project)(atomic)(addition)(input);\n\n    return {\n      expected: atomic.getName(),\n      expression:\n        addition !== null && conditions.length === 0\n          ? ts.factory.createLogicalAnd(base, addition)\n          : base,\n      conditions,\n    };\n  };\n\n/**\n * @internal\n */\nconst check_numeric_type_tags =\n  (project: IProject) =>\n  (atomic: MetadataAtomic) =>\n  (addition: ts.Expression | null) =>\n  (input: ts.Expression): ICheckEntry.ICondition[][] =>\n    atomic.tags\n      .map((row) => row.filter((tag) => !!tag.validate))\n      .filter((row) => !!row.length)\n      .map((row) => [\n        ...(addition === null\n          ? []\n          : row.some(\n                (tag) =>\n                  tag.kind === \"type\" &&\n                  (tag.value === \"int32\" ||\n                    tag.value === \"uint32\" ||\n                    tag.value === \"int64\" ||\n                    tag.value === \"uint64\" ||\n                    tag.value === \"float\"),\n              ) ||\n              row.some(\n                (tag) =>\n                  tag.kind === \"multipleOf\" && typeof tag.value === \"number\",\n              ) ||\n              (row.some(\n                (tag) =>\n                  (tag.kind === \"minimum\" || tag.kind === \"exclusiveMinimum\") &&\n                  typeof tag.value === \"number\",\n              ) &&\n                row.some(\n                  (tag) =>\n                    (tag.kind === \"maximum\" ||\n                      tag.kind === \"exclusiveMaximum\") &&\n                    typeof tag.value === \"number\",\n                ))\n            ? []\n            : [\n                {\n                  expected: \"number\",\n                  expression: addition!,\n                },\n              ]),\n        ...row.map((tag) => ({\n          expected: `number & ${tag.name}`,\n          expression: (\n            tag.predicate ??\n            ExpressionFactory.transpile(project.context)(tag.validate!)\n          )(input),\n        })),\n      ]);\n"],"mappings":";;;;;;;;;;;AAAA,OAAOA,QAAQ;AAcR,IAAMC,eACX,wBAACC,SAAmBC,YACpB,CAACC,WACD,CAACC,UAAAA;AACC,QAAMC,OAAOC,GAAGC,QAAQC,qBACtBF,GAAGC,QAAQE,oBAAoB,QAAA,GAC/BH,GAAGC,QAAQG,uBAAuBN,KAAAA,CAAAA;AAEpC,QAAMO,WACJT,YAAY,OACRU,iBAAiBC,OAAOZ,QAAQa,OAAO,IACrCR,GAAGC,QAAQQ,qBACTT,GAAGC,QAAQS,iBAAiB,iBAAA,GAC5BC,QACA;IAACb;GAAM,IAETQ,iBAAiBV,QAAQD,QAAQa,OAAO,IACtCR,GAAGC,QAAQW,iBACTZ,GAAGC,QAAQQ,qBACTT,GAAGC,QAAQS,iBAAiB,cAAA,GAC5BC,QACA;IAACb;GAAM,CAAA,IAGX,OACJ;AAEN,QAAMe,aACJC,wBAAwBnB,OAAAA,EAASE,MAAAA,EAAQQ,QAAAA,EAAUP,KAAAA;AAErD,SAAO;IACLiB,UAAUlB,OAAOmB,QAAO;IACxBC,YACEZ,aAAa,QAAQQ,WAAWK,WAAW,IACvClB,GAAGC,QAAQkB,iBAAiBpB,MAAMM,QAAAA,IAClCN;IACNc;EACF;AACF,GArCA;AA0CF,IAAMC,0BACJ,wBAACnB,YACD,CAACE,WACD,CAACQ,aACD,CAACP,UACCD,OAAOuB,KACJC,IAAI,CAACC,QAAQA,IAAIC,OAAO,CAACC,QAAQ,CAAC,CAACA,IAAIC,QAAQ,CAAA,EAC/CF,OAAO,CAACD,QAAQ,CAAC,CAACA,IAAIJ,MAAM,EAC5BG,IAAI,CAACC,QAAQ;KACRjB,aAAa,OACb,CAAA,IACAiB,IAAII,KACA,CAACF,QACCA,IAAIG,SAAS,WACZH,IAAII,UAAU,WACbJ,IAAII,UAAU,YACdJ,IAAII,UAAU,WACdJ,IAAII,UAAU,YACdJ,IAAII,UAAU,QAAM,KAE1BN,IAAII,KACF,CAACF,QACCA,IAAIG,SAAS,gBAAgB,OAAOH,IAAII,UAAU,QAAA,KAErDN,IAAII,KACH,CAACF,SACEA,IAAIG,SAAS,aAAaH,IAAIG,SAAS,uBACxC,OAAOH,IAAII,UAAU,QAAA,KAEvBN,IAAII,KACF,CAACF,SACEA,IAAIG,SAAS,aACZH,IAAIG,SAAS,uBACf,OAAOH,IAAII,UAAU,QAAA,IAE3B,CAAA,IACA;IACE;MACEb,UAAU;MACVE,YAAYZ;IACd;;KAELiB,IAAID,IAAI,CAACG,SAAS;IACnBT,UAAU,YAAYS,IAAIK,IAAI;IAC9BZ,aACEO,IAAIM,aACJC,kBAAkBC,UAAUrC,QAAQsC,OAAO,EAAET,IAAIC,QAAQ,GACzD3B,KAAAA;EACJ,EAAA;CACD,GAhDL;","names":["ts","check_number","project","numeric","atomic","input","base","ts","factory","createStrictEquality","createStringLiteral","createTypeOfExpression","addition","OptionPredicator","finite","options","createCallExpression","createIdentifier","undefined","createLogicalNot","conditions","check_numeric_type_tags","expected","getName","expression","length","createLogicalAnd","tags","map","row","filter","tag","validate","some","kind","value","name","predicate","ExpressionFactory","transpile","context"]}