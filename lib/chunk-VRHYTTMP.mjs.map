{"version":3,"sources":["../src/programmers/misc/MiscPruneProgrammer.ts"],"sourcesContent":["import ts from \"typescript\";\n\nimport { ExpressionFactory } from \"../../factories/ExpressionFactory\";\nimport { IdentifierFactory } from \"../../factories/IdentifierFactory\";\nimport { MetadataCollection } from \"../../factories/MetadataCollection\";\nimport { MetadataFactory } from \"../../factories/MetadataFactory\";\nimport { StatementFactory } from \"../../factories/StatementFactory\";\nimport { TypeFactory } from \"../../factories/TypeFactory\";\n\nimport { Metadata } from \"../../schemas/metadata/Metadata\";\nimport { MetadataArray } from \"../../schemas/metadata/MetadataArray\";\nimport { MetadataTuple } from \"../../schemas/metadata/MetadataTuple\";\nimport { MetadataTupleType } from \"../../schemas/metadata/MetadataTupleType\";\n\nimport { IProject } from \"../../transformers/IProject\";\nimport { TransformerError } from \"../../transformers/TransformerError\";\n\nimport { FeatureProgrammer } from \"../FeatureProgrammer\";\nimport { IsProgrammer } from \"../IsProgrammer\";\nimport { FunctionImporter } from \"../helpers/FunctionImporter\";\nimport { PruneJoiner } from \"../helpers/PruneJoiner\";\nimport { UnionExplorer } from \"../helpers/UnionExplorer\";\nimport { decode_union_object } from \"../internal/decode_union_object\";\nimport { wrap_metadata_rest_tuple } from \"../internal/wrap_metadata_rest_tuple\";\n\nexport namespace MiscPruneProgrammer {\n  export const write =\n    (project: IProject) => (modulo: ts.LeftHandSideExpression) => {\n      const importer: FunctionImporter = new FunctionImporter(modulo.getText());\n      return FeatureProgrammer.write(project)({\n        ...configure(project)(importer),\n        addition: (collection) => [\n          ...IsProgrammer.write_function_statements(project)(importer)(\n            collection,\n          ),\n          ...importer.declare(modulo),\n        ],\n      })(importer);\n    };\n\n  const write_array_functions =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .arrays()\n        .filter((a) => a.recursive)\n        .map((type, i) =>\n          StatementFactory.constant(\n            `${config.prefix}a${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_array_inline(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                MetadataArray.create({\n                  type,\n                  tags: [],\n                }),\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  const write_tuple_functions =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (collection: MetadataCollection): ts.VariableStatement[] =>\n      collection\n        .tuples()\n        .filter((t) => t.recursive)\n        .map((tuple, i) =>\n          StatementFactory.constant(\n            `${config.prefix}t${i}`,\n            ts.factory.createArrowFunction(\n              undefined,\n              undefined,\n              FeatureProgrammer.parameterDeclarations(config)(\n                TypeFactory.keyword(\"any\"),\n              )(ts.factory.createIdentifier(\"input\")),\n              TypeFactory.keyword(\"any\"),\n              undefined,\n              decode_tuple_inline(project)(config)(importer)(\n                ts.factory.createIdentifier(\"input\"),\n                tuple,\n                {\n                  tracable: config.trace,\n                  source: \"function\",\n                  from: \"array\",\n                  postfix: \"\",\n                },\n              ),\n            ),\n          ),\n        );\n\n  /* -----------------------------------------------------------\n        DECODERS\n    ----------------------------------------------------------- */\n  const decode =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.ConciseBody => {\n      if (filter(meta) === false) return ts.factory.createBlock([]);\n\n      interface IUnion {\n        type: string;\n        is: () => ts.Expression;\n        value: () => ts.Expression | ts.Block | ts.ReturnStatement;\n      }\n      const unions: IUnion[] = [];\n\n      //----\n      // LIST UP UNION TYPES\n      //----\n      // TUPLES\n      for (const tuple of meta.tuples.filter((tuple) =>\n        tuple.type.elements.some((e) => filter(e.rest ?? e)),\n      ))\n        unions.push({\n          type: \"tuple\",\n          is: () =>\n            IsProgrammer.decode(project)(importer)(\n              input,\n              (() => {\n                const partial = Metadata.initialize();\n                partial.tuples.push(tuple);\n                return partial;\n              })(),\n              explore,\n            ),\n          value: () =>\n            decode_tuple(project)(config)(importer)(input, tuple, explore),\n        });\n\n      // ARRAYS\n      if (meta.arrays.filter((a) => filter(a.type.value)).length)\n        unions.push({\n          type: \"array\",\n          is: () => ExpressionFactory.isArray(input),\n          value: () =>\n            explore_arrays(project)(config)(importer)(input, meta.arrays, {\n              ...explore,\n              from: \"array\",\n            }),\n        });\n\n      // BUILT-IN CLASSES\n      if (meta.natives.length)\n        for (const native of meta.natives)\n          unions.push({\n            type: \"native\",\n            is: () => ExpressionFactory.isInstanceOf(native)(input),\n            value: () => ts.factory.createReturnStatement(),\n          });\n      if (meta.sets.length)\n        unions.push({\n          type: \"set\",\n          is: () => ExpressionFactory.isInstanceOf(\"Set\")(input),\n          value: () => ts.factory.createReturnStatement(),\n        });\n      if (meta.maps.length)\n        unions.push({\n          type: \"map\",\n          is: () => ExpressionFactory.isInstanceOf(\"Map\")(input),\n          value: () => ts.factory.createReturnStatement(),\n        });\n\n      // OBJECTS\n      if (meta.objects.length)\n        unions.push({\n          type: \"object\",\n          is: () =>\n            ExpressionFactory.isObject({\n              checkNull: true,\n              checkArray: false,\n            })(input),\n          value: () =>\n            explore_objects(config)(importer)(input, meta, {\n              ...explore,\n              from: \"object\",\n            }),\n        });\n\n      //----\n      // STATEMENTS\n      //----\n      const converter = (v: ts.Expression | ts.Block | ts.ReturnStatement) =>\n        ts.isReturnStatement(v) || ts.isBlock(v)\n          ? v\n          : ts.factory.createExpressionStatement(v);\n\n      const statements: ts.Statement[] = unions.map((u) =>\n        ts.factory.createIfStatement(u.is(), converter(u.value())),\n      );\n      return ts.factory.createBlock(statements, true);\n    };\n\n  const decode_object = (importer: FunctionImporter) =>\n    FeatureProgrammer.decode_object({\n      trace: false,\n      path: false,\n      prefix: PREFIX,\n    })(importer);\n\n  const decode_array =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ) =>\n      array.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}a${array.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n              from: \"array\",\n            })(input),\n          )\n        : decode_array_inline(config)(importer)(input, array, explore);\n\n  const decode_array_inline =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      array: MetadataArray,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      FeatureProgrammer.decode_array(config)(importer)(PruneJoiner.array)(\n        input,\n        array,\n        explore,\n      );\n\n  const decode_tuple =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTuple,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression | ts.Block =>\n      tuple.type.recursive\n        ? ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\n              importer.useLocal(`${config.prefix}t${tuple.type.index}`),\n            ),\n            undefined,\n            FeatureProgrammer.argumentsArray(config)({\n              ...explore,\n              source: \"function\",\n            })(input),\n          )\n        : decode_tuple_inline(project)(config)(importer)(\n            input,\n            tuple.type,\n            explore,\n          );\n\n  const decode_tuple_inline =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      tuple: MetadataTupleType,\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Block => {\n      const children: ts.ConciseBody[] = tuple.elements\n        .map((elem, index) => [elem, index] as const)\n        .filter(([elem]) => filter(elem) && elem.rest === null)\n        .map(([elem, index]) =>\n          decode(project)(config)(importer)(\n            ts.factory.createElementAccessExpression(input, index),\n            elem,\n            {\n              ...explore,\n              from: \"array\",\n              postfix: explore.postfix.length\n                ? `${explore.postfix.slice(0, -1)}[${index}]\"`\n                : `\"[${index}]\"`,\n            },\n          ),\n        );\n      const rest = (() => {\n        if (tuple.elements.length === 0) return null;\n\n        const last: Metadata = tuple.elements.at(-1)!;\n        const rest: Metadata | null = last.rest;\n        if (rest === null || filter(rest) === false) return null;\n\n        return decode(project)(config)(importer)(\n          ts.factory.createCallExpression(\n            IdentifierFactory.access(input)(\"slice\"),\n            undefined,\n            [ExpressionFactory.number(tuple.elements.length - 1)],\n          ),\n          wrap_metadata_rest_tuple(tuple.elements.at(-1)!.rest!),\n          {\n            ...explore,\n            start: tuple.elements.length - 1,\n          },\n        );\n      })();\n      return PruneJoiner.tuple(children, rest);\n    };\n\n  /* -----------------------------------------------------------\n        UNION TYPE EXPLORERS\n    ----------------------------------------------------------- */\n  const explore_objects =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      meta: Metadata,\n      explore: FeatureProgrammer.IExplore,\n    ) => {\n      if (meta.objects.length === 1)\n        return decode_object(importer)(input, meta.objects[0]!, explore);\n\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.useLocal(`${PREFIX}u${meta.union_index!}`),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  const explore_arrays =\n    (project: IProject) =>\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    (\n      input: ts.Expression,\n      elements: MetadataArray[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression =>\n      explore_array_like_union_types(config)(importer)(\n        UnionExplorer.array({\n          checker: IsProgrammer.decode(project)(importer),\n          decoder: decode_array(config)(importer),\n          empty: ts.factory.createStringLiteral(\"[]\"),\n          success: ts.factory.createTrue(),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        }),\n      )(input, elements, explore);\n\n  const explore_array_like_union_types =\n    (config: FeatureProgrammer.IConfig) =>\n    (importer: FunctionImporter) =>\n    <T extends MetadataArray | MetadataTuple>(\n      factory: (\n        parameters: ts.ParameterDeclaration[],\n      ) => (\n        input: ts.Expression,\n        elements: T[],\n        explore: FeatureProgrammer.IExplore,\n      ) => ts.ArrowFunction,\n    ) =>\n    (\n      input: ts.Expression,\n      elements: T[],\n      explore: FeatureProgrammer.IExplore,\n    ): ts.Expression => {\n      const arrow =\n        (parameters: ts.ParameterDeclaration[]) =>\n        (explore: FeatureProgrammer.IExplore) =>\n        (input: ts.Expression): ts.ArrowFunction =>\n          factory(parameters)(input, elements, explore);\n      if (elements.every((e) => e.type.recursive === false))\n        ts.factory.createCallExpression(\n          arrow([])(explore)(input),\n          undefined,\n          [],\n        );\n\n      explore = {\n        ...explore,\n        source: \"function\",\n        from: \"array\",\n      };\n      return ts.factory.createCallExpression(\n        ts.factory.createIdentifier(\n          importer.emplaceUnion(\n            config.prefix,\n            elements.map((e) => e.type.name).join(\" | \"),\n            () =>\n              arrow(\n                FeatureProgrammer.parameterDeclarations(config)(\n                  TypeFactory.keyword(\"any\"),\n                )(ts.factory.createIdentifier(\"input\")),\n              )({\n                ...explore,\n                postfix: \"\",\n              })(ts.factory.createIdentifier(\"input\")),\n          ),\n        ),\n        undefined,\n        FeatureProgrammer.argumentsArray(config)(explore)(input),\n      );\n    };\n\n  // @todo -> must filter out recursive visit\n  const filter = (meta: Metadata): boolean =>\n    meta.any === false &&\n    (meta.objects.length !== 0 ||\n      meta.tuples.some(\n        (t) =>\n          !!t.type.elements.length &&\n          t.type.elements.some((e) => filter(e.rest ?? e)),\n      ) ||\n      meta.arrays.some((e) => filter(e.type.value)));\n\n  /* -----------------------------------------------------------\n        CONFIGURATIONS\n    ----------------------------------------------------------- */\n  const PREFIX = \"$p\";\n\n  const configure =\n    (project: IProject) =>\n    (importer: FunctionImporter): FeatureProgrammer.IConfig => {\n      const config: FeatureProgrammer.IConfig = {\n        types: {\n          input: (type, name) =>\n            ts.factory.createTypeReferenceNode(\n              name ?? TypeFactory.getFullName(project.checker)(type),\n            ),\n          output: () => TypeFactory.keyword(\"void\"),\n        },\n        prefix: PREFIX,\n        trace: false,\n        path: false,\n        initializer,\n        decoder: () => decode(project)(config)(importer),\n        objector: {\n          checker: () => IsProgrammer.decode(project)(importer),\n          decoder: () => decode_object(importer),\n          joiner: PruneJoiner.object,\n          unionizer: decode_union_object(\n            IsProgrammer.decode_object(project)(importer),\n          )(decode_object(importer))((exp) => exp)((value, expected) =>\n            create_throw_error(importer)(expected)(value),\n          ),\n          failure: (input, expected) =>\n            create_throw_error(importer)(expected)(input),\n        },\n        generator: {\n          arrays: () => write_array_functions(config)(importer),\n          tuples: () => write_tuple_functions(project)(config)(importer),\n        },\n      };\n      return config;\n    };\n\n  const initializer: FeatureProgrammer.IConfig[\"initializer\"] =\n    (project) => (importer) => (type) => {\n      const collection = new MetadataCollection();\n      const result = MetadataFactory.analyze(\n        project.checker,\n        project.context,\n      )({\n        escape: false,\n        constant: true,\n        absorb: true,\n      })(collection)(type);\n      if (result.success === false)\n        throw TransformerError.from(`typia.misc.${importer.method}`)(\n          result.errors,\n        );\n      return [collection, result.data];\n    };\n\n  const create_throw_error =\n    (importer: FunctionImporter) =>\n    (expected: string) =>\n    (value: ts.Expression) =>\n      ts.factory.createExpressionStatement(\n        ts.factory.createCallExpression(\n          importer.use(\"throws\"),\n          [],\n          [\n            ts.factory.createObjectLiteralExpression(\n              [\n                ts.factory.createPropertyAssignment(\n                  \"expected\",\n                  ts.factory.createStringLiteral(expected),\n                ),\n                ts.factory.createPropertyAssignment(\"value\", value),\n              ],\n              true,\n            ),\n          ],\n        ),\n      );\n}\n"],"mappings":"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","names":["ts","MiscPruneProgrammer","write","project","modulo","importer","FunctionImporter","getText","FeatureProgrammer","configure","addition","collection","IsProgrammer","write_function_statements","declare","write_array_functions","config","arrays","filter","a","recursive","map","type","i","StatementFactory","constant","prefix","ts","factory","createArrowFunction","undefined","parameterDeclarations","TypeFactory","keyword","createIdentifier","decode_array_inline","MetadataArray","create","tags","tracable","trace","source","from","postfix","write_tuple_functions","tuples","t","tuple","decode_tuple_inline","decode","input","meta","explore","createBlock","unions","elements","some","e","rest","push","is","partial","Metadata","initialize","value","decode_tuple","length","ExpressionFactory","isArray","explore_arrays","natives","native","isInstanceOf","createReturnStatement","sets","maps","objects","isObject","checkNull","checkArray","explore_objects","converter","v","isReturnStatement","isBlock","createExpressionStatement","statements","u","createIfStatement","decode_object","path","PREFIX","decode_array","array","createCallExpression","useLocal","index","argumentsArray","PruneJoiner","children","elem","createElementAccessExpression","slice","last","at","IdentifierFactory","access","number","wrap_metadata_rest_tuple","start","union_index","explore_array_like_union_types","UnionExplorer","checker","decoder","empty","createStringLiteral","success","createTrue","failure","expected","create_throw_error","arrow","parameters","every","emplaceUnion","name","join","any","types","createTypeReferenceNode","getFullName","output","initializer","objector","joiner","object","unionizer","decode_union_object","exp","generator","MetadataCollection","result","MetadataFactory","analyze","context","escape","absorb","TransformerError","method","errors","data","use","createObjectLiteralExpression","createPropertyAssignment"]}