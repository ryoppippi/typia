---
title: Guide Documents > JSON > Schema
---
import { Tabs } from 'nextra/components'

## `schemas()` function
<Tabs items={[
  <code>typia</code>, 
  <code>IJsonSchemaCollection.ts</code>, 
]}>
  <Tabs.Tab>
```typescript copy
export namespace json {
  export function schemas<
    Schemas extends unknown[],
    Version extends "3.0" | "3.1" = "3.1",
  >(): IJsonSchemaCollection<Version>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```typescript copy
import type { OpenApi, OpenApiV3 } from "@samchon/openapi";

export type IJsonSchemaCollection<Version extends "3.0" | "3.1" = "3.1"> =
  Version extends "3.0" ? IV3_0 : IV3_1;

interface IV3_0<Types = unknown[]> {
  version: "3.0";
  schemas: OpenApiV3.IJsonSchema[];
  components: OpenApiV3.IComponents;
  __types?: Types | undefined;
}
interface IV3_1<Types = unknown[]> {
  version: "3.1";
  components: OpenApi.IComponents;
  schemas: OpenApi.IJsonSchema[];
  __types?: Types | undefined;
}
```
  </Tabs.Tab>
</Tabs>

JSON schema generator.

  - Definitions:
    - [`IJsonSchemaCollection`](https://github.com/samchon/typia/blob/master/src/schemas/json/IJsonSchemaCollection.ts)
    - [OpenAPI v3.0](https://github.com/samchon/openapi/blob/master/src/OpenApiV3.ts)
    - [OpenAPI v3.1](https://github.com/samchon/openapi/blob/master/src/OpenApi.ts)

When you need JSON schema, do not write it by yourself, but just call `typia.json.schemas()` function. 

If you call the `typia.json.schemas()` with specialization of target `Schemas`, `typia` will analyze your `Schemas` and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of "OpenAPI v3.0" and "OpenAPI v3.1" are a little bit different. Therefore, you have to consider which value to assign in the `Version` argument.

  - Swagger can't express tuple type
  - Swagger can't express pattern property

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
```typescript copy filename="examples/src/application.ts" showLineNumbers
import typia, { tags } from "typia";

export const MemberSchema = typia.json.schemas<[IMember], "3.0">();

interface IMember {
  /**
   * Unique user ID generated by server.
   */
  id: string & tags.Format<"uuid">;

  /**
   * Email address of the member.
   */
  email: string & tags.Format<"email">;

  /**
   * Age of the member.
   *
   * For reference, only adult can be a member.
   */
  age: number &
    tags.Type<"uint32"> &
    tags.ExclusiveMinimum<19> &
    tags.Maximum<100>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```javascript filename="examples/bin/application.js" showLineNumbers
import typia from "typia";
export const MemberSchema = {
  version: "3.0",
  components: {
    schemas: {
      IMember: {
        type: "object",
        properties: {
          id: {
            type: "string",
            format: "uuid",
            title: "Unique user ID generated by server",
            description: "Unique user ID generated by server.",
          },
          email: {
            type: "string",
            format: "email",
            title: "Email address of the member",
            description: "Email address of the member.",
          },
          age: {
            type: "integer",
            exclusiveMinimum: true,
            minimum: 19,
            maximum: 100,
            title: "Age of the member",
            description:
              "Age of the member.\n\nFor reference, only adult can be a member.",
          },
        },
        required: ["id", "email", "age"],
      },
    },
  },
  schemas: [
    {
      $ref: "#/components/schemas/IMember",
    },
  ],
};
```
  </Tabs.Tab>
</Tabs>




## Specialization
You can utilize [type tags](../validators/tags/#type-tags) (or [validator's comment tags](../validators/tags/#comment-tags)) to constructing special fields of JSON schema. 

If you write any comment on a property, it would fill the `IJsonSchema.description` value. Also, there're special comment tags only for JSON schema definition that are different with [validator's comment tags](../validators/tags/#comment-tags) like below.

  - `@deprecated`
  - `@hidden`
  - `@internal`
  - `@title {string}`

Let's see how those [type tags](../validators/tags/#type-tags), comment tags and description comments are working with example code.


<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
```typescript copy filename="examples/src/application-comment-tags.ts" showLineNumbers
import typia, { tags } from "typia";

export const SpecialTagSchema = typia.json.schemas<[Special], "3.1">();

interface Special {
  /**
   * Deprecated tags are just used for marking.
   *
   * @title Unsigned integer
   * @deprecated
   */
  type: number & tags.Type<"int32">;

  /**
   * Internal tagged property never be shown in JSON schema.
   *
   * It even doesn't be shown in other `typia` functions like `assert<T>()`.
   *
   * @internal
   */
  internal: number[];

  /**
   * Hidden tagged property never be shown in JSON schema.
   *
   * However, it would be shown in other `typia` functions like `stringify<T>()`.
   *
   * @hidden
   */
  hidden: boolean;

  /**
   * You can limit the range of number.
   *
   * @exclusiveMinimum 19
   * @maximum 100
   */
  number?: number;

  /**
   * You can limit the length of string.
   *
   * Also, multiple range conditions are also possible.
   */
  string: string &
    (
      | (tags.MinLength<3> & tags.MaxLength<24>)
      | (tags.MinLength<40> & tags.MaxLength<100>)
    );

  /**
   * You can limit the pattern of string.
   *
   * @pattern ^[a-z]+$
   */
  pattern: string;

  /**
   * You can limit the format of string.
   *
   * @format date-time
   */
  format: string | null;

  /**
   * In the Array case, possible to restrict its elements.
   */
  array: Array<string & tags.Format<"uuid">> & tags.MinItems<3>;
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```javascript filename="examples/bin/application-comment-tags.js" showLineNumbers
import typia from "typia";
export const SpecialTagSchema = {
  version: "3.1",
  components: {
    schemas: {
      Special: {
        type: "object",
        properties: {
          type: {
            type: "integer",
            deprecated: true,
            title: "Unsigned integer",
            description: "Deprecated tags are just used for marking.",
          },
          number: {
            type: "number",
            exclusiveMinimum: true,
            minimum: 19,
            maximum: 100,
            title: "You can limit the range of number",
            description: "You can limit the range of number.",
          },
          string: {
            oneOf: [
              {
                type: "string",
                minLength: 3,
                maxLength: 24,
              },
              {
                type: "string",
                minLength: 40,
                maxLength: 100,
              },
            ],
            title: "You can limit the length of string",
            description:
              "You can limit the length of string.\n\nAlso, multiple range conditions are also possible.",
          },
          pattern: {
            type: "string",
            pattern: "^[a-z]+$",
            title: "You can limit the pattern of string",
            description: "You can limit the pattern of string.",
          },
          format: {
            oneOf: [
              {
                type: "null",
              },
              {
                type: "string",
                format: "date-time",
              },
            ],
            title: "You can limit the format of string",
            description: "You can limit the format of string.",
          },
          array: {
            type: "array",
            items: {
              type: "string",
              format: "uuid",
            },
            minItems: 3,
            title: "In the Array case, possible to restrict its elements",
            description:
              "In the Array case, possible to restrict its elements.",
          },
        },
        required: ["type", "string", "pattern", "format", "array"],
      },
    },
  },
  schemas: [
    {
      $ref: "#/components/schemas/Special",
    },
  ],
};
```
  </Tabs.Tab>
</Tabs>



## Customization
If what you want is not just filling regular properties of JSON schema specification, but to adding custom properties into the JSON schema definition, you can do it through the `tags.TagBase.schema` property type or `tags.JsonSchemaPlugin` type. 

For reference, the custom property must be started with `x-` prefix. It's a rule of JSON schema.

<Tabs items={['TypeScript Source Code', 'Compiled JavaScript File']}>
  <Tabs.Tab>
```typescript copy filename="examples/src/json-schema-custom.ts" copy showLineNumbers {7-9, 13, 17-18}
import typia, { tags } from "typia";
 
type Monetary<Value extends string> = tags.TagBase<{
  target: "number";
  kind: "monetary";
  value: Value;
  schema: {
    "x-monetary": Value;
  };
}>;

type Placeholder<Value extends string> = tags.JsonSchemaPlugin<{
  "x-placeholder": Value;
}>;

interface IAccount {
  code: string & Placeholder<"Write you account code please">;
  balance: number & Monetary<"dollar">;
};
 
typia.json.schemas<[IAccount]>();
```
  </Tabs.Tab>
  <Tabs.Tab>
```javascript copy filename="examples/bin/json-schema-custom.js" showLineNumbers {11, 15}
import typia from "typia";
({
  version: "3.1",
  components: {
    schemas: {
      IAccount: {
        type: "object",
        properties: {
          code: {
            type: "string",
            "x-placeholder": "Write you account code please",
          },
          balance: {
            type: "number",
            "x-monetary": "dollar",
          },
        },
        required: ["code", "balance"],
      },
    },
  },
  schemas: [
    {
      $ref: "#/components/schemas/IAccount",
    },
  ],
});

```
  </Tabs.Tab>
</Tabs>




## Restrictions
JSON schema does not support `bigint` type.

So if you use `bigint` type in one of your onetarget schemas, `typia` will make compile error like below.

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tabs.Tab>
```typescript filename="json.schemas.ts" copy showLineNumbers 
import typia, { tags } from "typia";

interface Something {
  bigint: bigint;
  array: bigint[];
  nested: Nested;
}
interface Nested {
  uint64: bigint & tags.Type<"uint64">;
}

typia.json.schemas<[Something]>();
```
  </Tabs.Tab>
  <Tabs.Tab>
```bash
main.ts:12:1 - error TS(typia.json.schemas): unsupported type detected

- Something.bigint: bigint
  - JSON does not support bigint type.

- Something.array: bigint
  - JSON does not support bigint type.

- Nested.uint64: (bigint & Type<"uint64">)
  - JSON does not support bigint type.
```
  </Tabs.Tab>
</Tabs>

Also, if you put any type of native classes like `Map` or `Uint8Array`, it would also be error, either. By the way, only `Date` class is exceptional, and it would be considered as `string & Format<"date-time">` type like below.

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tabs.Tab>
```typescript filename="json.schemas.native.ts" showLineNumbers copy
import typia from "typia";

interface Native {
  date: Date;
}
typia.json.schemas<[Native]>();
```
  </Tabs.Tab>
  <Tabs.Tab>
```typescript filename="json.schemas.native.js" showLineNumbers
import typia from "typia";
({
  version: "3.1",
  components: {
    schemas: {
      Native: {
        type: "object",
        properties: {
          date: {
            type: "string",
            format: "date-time",
          },
        },
        required: ["date"],
      },
    },
  },
  schemas: [
    {
      $ref: "#/components/schemas/Native",
    },
  ],
});
```
  </Tabs.Tab>
</Tabs>
